from collections.abc import Generator

from wxc_sdk.api_child import ApiChild
from wxc_sdk.base import ApiModel, enum_str
from wxc_sdk.base import SafeEnum as Enum
from typing import List, Optional
from pydantic import Field, parse_obj_as


__all__ = ['AcdObject', 'Action', 'Action11', 'Action15', 'Action6', 'Action9', 'Actions', 'ActivationStates',
           'AdaptiveCard', 'AddNewEventForPersonsScheduleResponse', 'AddPhoneNumbersTolocationBody', 'Address',
           'Address5', 'Addresses', 'AdminAuditEventsApi', 'Aggregation', 'Aggregation1', 'Alarm', 'AlarmSeverity',
           'AlternateNumberSettings', 'AlternateNumbersObject', 'AlternateNumbersWithPattern',
           'AlternateNumbersWithPattern1', 'Always', 'AnnouncementMode', 'Announcements', 'Announcements3',
           'AnswerForCustomizedQuestion', 'AnswerObject', 'AnswerSummaryItem', 'Answers', 'Arguments',
           'AtaDtmfMethodObject', 'AtaDtmfModeObject', 'AtaObject', 'Attachment', 'AttachmentActionsApi',
           'AttendeePrivileges', 'Audio', 'Audio1', 'AudioCodecPriorityObject', 'AudioConnectionOptions',
           'AudioConnectionType', 'AudioFileObject', 'AudioType', 'AuditEvent', 'Authorization', 'AuthorizationsApi',
           'AutoAttendantCallForwardSettingsDetailsObject', 'AutoAttendantCallForwardSettingsModifyDetailsObject',
           'AvailableSharedLineMemberItem', 'BackgroundImage', 'BacklightTimerObject',
           'BatchRegisterMeetingRegistrantsResponse', 'BehaviorType', 'BlockContiguousSequences',
           'BlockPreviousPasscodes', 'BlockRepeatedDigits', 'BlrClusterDetails', 'BlrNode1', 'BlrNodeLocation', 'Body',
           'Body6', 'Booking', 'BreakoutSessionObject', 'BroadWorksBillingReportsApi',
           'BroadWorksDeviceProvisioningApi', 'BroadWorksEnterprisesApi', 'BroadWorksSubscribersApi',
           'BroadworksDirectorySync', 'BusinessContinuity', 'CDR', 'CLIDPolicySelection', 'Calendar1', 'Call',
           'CallBounce', 'CallControlsApi', 'CallForwardRulesGet', 'CallForwardRulesModifyObject',
           'CallForwardRulesObject', 'CallForwardSelectiveCallsFromCustomNumbersObject',
           'CallForwardSelectiveCallsFromObject', 'CallForwardSelectiveCallsToNumbersObject',
           'CallForwardSelectiveCallsToObject', 'CallForwardSelectiveForwardToObject', 'CallForwarding',
           'CallForwarding1', 'CallForwarding4', 'CallForwardingPlaceSettingGet', 'CallForwardingPlaceSettingPatch',
           'CallHistoryRecord', 'CallHistoryRecordTypeEnum', 'CallInNumbers', 'CallParkSettingsObject',
           'CallPersonalityEnum', 'CallQueueAudioFilesObject', 'CallQueueHolidaySchedulesObject', 'CallQueueObject',
           'CallQueueQueueSettingsObject', 'CallSourceInfo', 'CallSourceType', 'CallStateEnum', 'CallType',
           'CallType3', 'CallTypeEnum', 'CallerIdSelectedType', 'Calling', 'CallingLineId', 'CallingPermissionObject',
           'CallingPermissions', 'Callparkextension', 'CallsFrom', 'CallsTo', 'CapabilityMap', 'ChatObject',
           'ClosedCaptionObject', 'CloudOverflowTrend1', 'Cluster', 'ClusterAvailability',
           'ClusterAvailabilityCollection', 'ClusterAvailableTimeline', 'ClusterDetailsCollection',
           'ClusterRedirectBlr1', 'ClusterRedirectDetailsBlr1a', 'ClusterUpgradeScheduleBlr',
           'ClusterUtilizationCollection', 'ClusterUtilizationT1Blr', 'ClusterUtilizationT1SJ',
           'ClusterUtilizationTrend1', 'CoHosts', 'ComfortMessage', 'ComfortMessageBypass', 'Condition',
           'Configuration_key', 'ConfigureCallRecordingSettingsForPersonBody',
           'ConfigureCallerIDSettingsForPersonBody', 'Configured', 'ConfigurepersonsCallingBehaviorBody',
           'ConnectivityTestResultsClustersObject1', 'ConnectivityTestResultsClustersObject2',
           'ConnectivityTestResultsClustersObject3', 'ConnectivityTestResultsForNode', 'Connector', 'ConnectorStatus',
           'ConnectorType', 'Content', 'CountObject', 'CreateAttachmentActionBody', 'CreateAttachmentActionResponse',
           'CreateAutoAttendantResponse', 'CreateBroadWorksBillingReportResponse', 'CreateCallParkBody',
           'CreateCallParkExtensionResponse', 'CreateCallParkResponse', 'CreateCallPickupBody',
           'CreateCallPickupResponse', 'CreateCallQueueResponse', 'CreateDeviceActivationCodeResponse',
           'CreateDialPlanResponse', 'CreateGroupResponse', 'CreateHuntGroupResponse',
           'CreateInvitationSourcesResponse', 'CreateInviteesItemObject', 'CreateLocationBody',
           'CreateLocationFloorBody', 'CreateLocationResponse', 'CreateMeetingBody', 'CreateMeetingInterpreterBody',
           'CreateMeetingInviteesResponse', 'CreateMeetingResponse', 'CreateMembershipBody', 'CreateMessageResponse',
           'CreatePersonBody', 'CreateReceptionistContactDirectoryResponse', 'CreateReportResponse', 'CreateRoomBody',
           'CreateRoomTabBody', 'CreateRouteGroupForOrganizationBody', 'CreateRouteGroupForOrganizationResponse',
           'CreateRouteListResponse', 'CreateScheduleEventResponse', 'CreateScheduleForPersonBody',
           'CreateScheduleForPersonResponse', 'CreateScheduleResponse',
           'CreateSelectiveCallForwardingRuleForAutoAttendantBody',
           'CreateSelectiveCallForwardingRuleForAutoAttendantResponse',
           'CreateSelectiveCallForwardingRuleForCallQueueBody',
           'CreateSelectiveCallForwardingRuleForCallQueueResponse',
           'CreateSelectiveCallForwardingRuleForHuntGroupResponse', 'CreateTeamMembershipBody',
           'CreateTrackingCodeBody', 'CreateTrunkResponse', 'CreateWebhookBody',
           'CreateWholesaleBillingReportResponse', 'CreateWorkspaceLocationBody', 'CreatenewPagingGroupBody',
           'CreatenewPagingGroupResponse', 'CreatenewVoicemailGroupForLocationResponse', 'Customer2', 'CustomerInfo',
           'CustomerInfo1', 'CustomizationDeviceLevelObject', 'CustomizationObject',
           'CustomizedQuestionForCreateMeeting', 'CustomizedQuestionForGetMeeting', 'CustomizedRegistrant',
           'DNSResolutionTest', 'Data', 'Data1', 'Data3', 'Day', 'DectDeviceList', 'DectObject', 'Default',
           'DefaultAudioType', 'DefaultLoggingLevelObject', 'DefaultSchedulerOptions', 'DefaultVoicemailPinRules',
           'DeleteTranscriptBody', 'DestinationType', 'Device', 'Device1', 'DeviceConfiguration',
           'DeviceConfigurationsApi', 'DeviceConnectionStatus', 'DeviceObject', 'DeviceOwner', 'DeviceStatus',
           'DeviceType', 'Devices', 'DevicesApi', 'DialPattern', 'DialPatternAction', 'DialPatternStatus',
           'DialPatternValidate', 'DialPlan', 'DialResponse', 'DirectMessage', 'DirectorySyncStatus',
           'DisplayCallqueueAgentSoftkeysObject', 'DisplayNameSelection', 'DistinctiveRing', 'DurationMetric',
           'EditMessageBody', 'Editability', 'Editability1', 'EffectiveBehaviorType', 'EmailCopyOfMessage',
           'Emergency', 'EnableLocationForWebexCallingResponse', 'EntryAndExitTone', 'EntryAndExitTone10',
           'ErrorMessageObject', 'ErrorObject', 'Errors', 'Event', 'Event1', 'EventLongDetails', 'EventResourceEnum',
           'EventTypeEnum', 'EventsApi', 'ExecuteCommandResponse', 'ExpirePasscode', 'ExtensionDialing',
           'ExtensionStatusObject', 'ExternalCallerIdNamePolicy', 'ExternalTransfer', 'FailedAttempts',
           'FailureDetails1', 'FaxMessage', 'FeatureAccessCode', 'FetchEventForpersonsScheduleResponse',
           'FetchSubscriptionResponse', 'Floor', 'Format', 'GenerateExamplePasswordForLocationResponse',
           'GetAllCustomersManagedBypartnerAdminResponse', 'GetAllPartnerAdminsAssignedTocustomerResponse',
           'GetAnnouncementFileInfo', 'GetAvailableAgentsFromCallParksResponse',
           'GetAvailableAgentsFromCallPickupsResponse', 'GetAvailableRecallHuntGroupsFromCallParksResponse',
           'GetBreakoutSessionObject', 'GetBroadWorksBillingReportResponse', 'GetCallForwardAlwaysSettingObject',
           'GetCallForwardingSettingsForAutoAttendantResponse', 'GetCallForwardingSettingsForCallQueueResponse',
           'GetCallForwardingSettingsForHuntGroupResponse', 'GetCallParkSettingsResponse',
           'GetCallRecordingSettingsResponse', 'GetCallRecordingTermsOfServiceSettingsResponse',
           'GetClusterAvailabilityResponse', 'GetClusterDetailsResponse', 'GetClusterRedirectDetailsResponse',
           'GetClusterUtilizationDetailsResponse', 'GetCustomerOrganizationsTagsResponse',
           'GetDetailedCallHistoryResponse', 'GetDetailedInformationForMeetingRegistrantResponse',
           'GetDetailsForAutoAttendantResponse', 'GetDetailsForCallParkExtensionResponse',
           'GetDetailsForCallParkResponse', 'GetDetailsForCallPickupResponse',
           'GetDetailsForCallQueueForcedForwardResponse', 'GetDetailsForCallQueueHolidayServiceResponse',
           'GetDetailsForCallQueueNightServiceResponse', 'GetDetailsForCallQueueResponse',
           'GetDetailsForCallQueueStrandedCallsResponse', 'GetDetailsForHuntGroupResponse',
           'GetDetailsForPagingGroupResponse', 'GetDetailsForScheduleResponse', 'GetDeviceMembersResponse',
           'GetDeviceSettingsResponse', 'GetDialPlanResponse', 'GetInviteeObject',
           'GetListOfPhoneNumbersForPersonResponse', 'GetLocalGatewayCallToOnPremisesExtensionUsageForTrunkResponse',
           'GetLocalGatewayDialPlanUsageForTrunkResponse', 'GetLocalGatewayUsageCountResponse',
           'GetLocationInterceptResponse', 'GetLocationOutgoingPermissionResponse',
           'GetLocationVoicemailGroupResponse', 'GetLocationVoicemailResponse',
           'GetLocationWebexCallingDetailsResponse', 'GetLocationsUsingLocalGatewayAsPSTNConnectionRoutingResponse',
           'GetManageNumbersJobStatusResponse', 'GetMediaHealthMonitoringToolClusterResultsResponse',
           'GetMediaHealthMonitoringToolNodeResultsResponse', 'GetMeetingArchiveDetailsResponse',
           'GetMeetingCommonSettingsConfigurationResponse', 'GetMeetingControlStatusResponse',
           'GetMeetingPollResultsResponse', 'GetMeetingPreferenceDetailsResponse', 'GetMeetingQualitiesResponse',
           'GetMeetingSurveyResponse', 'GetMeetingTemplateResponse', 'GetMessageSummaryResponse',
           'GetMonitoredElementsObject', 'GetMusicOnHoldResponse', 'GetNetworkTestResultsForClusterResponse',
           'GetNetworkTestResultsForNodeResponse', 'GetNodeAvailabilityResponse',
           'GetNumbersAssignedToRouteListResponse', 'GetOutgoingPermissionAutoTransferNumberResponse',
           'GetOutgoingPermissionLocationAccessCodeResponse', 'GetPagingGroupAgentObject',
           'GetPersonPlaceVirtualLineCallParksObject', 'GetPersonPlaceVirtualLineCallPickupObject',
           'GetPersonPlaceVirtualLineCallQueueObject', 'GetPersonPlaceVirtualLineHuntGroupObject',
           'GetPersonalMeetingRoomOptionsResponse', 'GetPersonalizationTaskResponse',
           'GetPhoneNumbersForOrganizationWithGivenCriteriasResponse', 'GetPrivateNetworkConnectResponse',
           'GetReachabilityTestResultsForClusterResponse', 'GetReachabilityTestResultsForNodeResponse',
           'GetRecallHuntGroupObject', 'GetRecordingAuditReportDetailsResponse', 'GetRecordingDetailsResponse',
           'GetRegistrationFormFormeetingResponse', 'GetRoomMeetingDetailsResponse',
           'GetRouteGroupsUsingLocalGatewayResponse', 'GetRouteListResponse', 'GetScheduleDetailsResponse',
           'GetScheduleEventObject', 'GetSelectiveCallForwardingRuleForAutoAttendantResponse',
           'GetSelectiveCallForwardingRuleForCallQueueResponse', 'GetSharedLineAppearanceMembersResponse',
           'GetSharedLineMemberItem', 'GetSiteListResponse', 'GetTrackingCodeItemForUserObject',
           'GetTrackingCodeObject', 'GetTriggeredTestResultsResponse', 'GetTrunkResponse', 'GetUserDevicesResponse',
           'GetUserNumberItemObject', 'GetUserTrackingCodesResponse', 'GetVideoOptionsResponse',
           'GetVoicePortalPasscodeRuleResponse', 'GetVoicePortalResponse', 'GetVoicemailGroupObject',
           'GetVoicemailRulesResponse', 'GetVoicemailSettingsResponse', 'GetWholesaleBillingReportResponse',
           'GetWorkspaceCapabilitiesResponse', 'GetWorkspaceDevicesResponse', 'GetpersonsPrivacySettingsResponse',
           'Greeting', 'Greeting29', 'GroupsApi', 'HistoricalAnalyticsApi', 'HistoricalDataRelatedToMeetingsResponse',
           'HistoricalDataRelatedToMessagingResponse', 'HolidayScheduleLevel', 'HostProfileCode', 'HostedAgent',
           'HostedFeature', 'Hoteling', 'HoursMenuObject', 'HuntPolicySelection', 'HuntRoutingTypeSelection',
           'HybridClustersApi', 'HybridConnectorsApi', 'HydraClassification', 'IdentityManagedOrg', 'InProgressDevice',
           'Incoming', 'Info', 'InputMode', 'Inputs', 'InterceptAnnouncementsGet', 'InterceptIncomingGet',
           'InterceptIncomingPatch', 'InterpreterObjectForSimultaneousInterpretationOfCreateOrUpdateMeeting',
           'InterpreterObjectForSimultaneousInterpretationOfGetOrListMeeting', 'InvitationSourceCreateObject',
           'InvitationSourceObject', 'InviteeObjectForCreateMeeting', 'ItemObject', 'JobExecutionStatusObject',
           'JobExecutionStatusObject1', 'JoinMeetingResponse', 'KemModuleTypeObject', 'Key', 'KeyConfigurationsObject',
           'Length', 'License', 'LicensesApi', 'LineKeyLEDPattern', 'LineKeyLabelSelection', 'LineType', 'Link',
           'Links', 'ListAdminAuditEventCategoriesResponse', 'ListAdminAuditEventsResponse',
           'ListAndSearchGroupsResponse', 'ListAnswersOfQuestionResponse', 'ListAuthorizationsForuserResponse',
           'ListAutoAttendantObject', 'ListBroadWorksBillingReportsResponse', 'ListBroadWorksEnterprisesResponse',
           'ListBroadWorksSubscribersResponse', 'ListCPCallParkExtensionObject', 'ListCallHistoryResponse',
           'ListCallParkExtensionObject', 'ListCallParkObject', 'ListCallQueueObject', 'ListCallsResponse',
           'ListChangeDeviceSettingsJobErrorsResponse', 'ListChangeDeviceSettingsJobsResponse',
           'ListClassificationsResponse', 'ListClusterDetailsResponse', 'ListClusterRedirectDetailsResponse',
           'ListClustersAvailabilityResponse', 'ListClustersUtilizationResponse',
           'ListDeviceConfigurationsForDeviceResponse', 'ListDevicesResponse', 'ListDirectMessagesResponse',
           'ListEventsResponse', 'ListHybridClustersResponse', 'ListHybridConnectorsResponse',
           'ListInvitationSourcesResponse', 'ListLicensesResponse', 'ListLocationFloorsResponse', 'ListLocationObject',
           'ListLocationsResponse', 'ListLocationsWebexCallingDetailsResponse', 'ListManageNumbersJobErrorsResponse',
           'ListManageNumbersJobsResponse', 'ListMediaHealthMonitoringToolResultsResponse',
           'ListMeetingArchiveSummariesResponse', 'ListMeetingAttendeeReportsResponse',
           'ListMeetingBreakoutSessionsResponse', 'ListMeetingChatsResponse',
           'ListMeetingClosedCaptionSnippetsResponse', 'ListMeetingClosedCaptionsResponse',
           'ListMeetingInterpretersResponse', 'ListMeetingInviteesResponse', 'ListMeetingParticipantsResponse',
           'ListMeetingPollsResponse', 'ListMeetingQAndAResponse', 'ListMeetingRegistrantsResponse',
           'ListMeetingSessionTypesResponse', 'ListMeetingSurveyResultsResponse', 'ListMeetingTemplatesResponse',
           'ListMeetingTrackingCodesResponse', 'ListMeetingTranscriptsForComplianceOfficerResponse',
           'ListMeetingTranscriptsResponse', 'ListMeetingUsageReportsResponse', 'ListMeetingsOfMeetingSeriesResponse',
           'ListMeetingsResponse', 'ListMembershipsResponse', 'ListMessage', 'ListMessagesResponse',
           'ListMessagesResponse1', 'ListNetworkTestResultsResponse', 'ListNodeAvailabilityResponse',
           'ListOfRecordingAuditReportSummariesResponse', 'ListOfSchedulesForPersonResponse',
           'ListOrganizationsResponse', 'ListOverflowToCloudDetailsResponse', 'ListPeopleResponse',
           'ListReachabilityTestResultsResponse', 'ListRecordingsForAdminOrComplianceOfficerResponse',
           'ListRecordingsResponse', 'ListReport', 'ListReport1', 'ListReportTemplatesResponse', 'ListReportsResponse',
           'ListResourceGroupMembershipsResponse', 'ListResourceGroupsResponse', 'ListRespondentsOfQuestionResponse',
           'ListRolesResponse', 'ListRoomTabsResponse', 'ListRoomsResponse', 'ListScheduleObject',
           'ListSecurityAuditEventsResponse', 'ListSiteSessionTypesResponse',
           'ListSnippetsOfMeetingTranscriptResponse', 'ListTeamMembershipsResponse', 'ListTeamsResponse',
           'ListTrackingCodesResponse', 'ListUserSessionTypeResponse', 'ListVirtualLineObject',
           'ListVoicemailGroupResponse', 'ListWebhooksResponse', 'ListWholesaleBillingReportsResponse',
           'ListWholesaleCustomersResponse', 'ListWholesaleSubscribersResponse', 'ListWorkspaceLocationFloorsResponse',
           'ListWorkspaceLocationsResponse', 'ListWorkspacesResponse', 'LocalGateways', 'Location', 'Location16',
           'Location19', 'LocationsApi', 'MHMTestResults', 'MacStatusObject', 'ManagedByObject', 'ManufacturerObject',
           'Measurement', 'MediaHealthMonitoringResultsCollectionforcluster',
           'MediaHealthMonitoringResultsCollectionfornode', 'MediaHealthMonitoringResultsCollectionfororganization',
           'MediaHealthMonitoringTestResultsFailure', 'MediaHealthMonitoringclusters',
           'MediaHealthMonitoringforfirstcluster', 'MediaHealthMonitoringsecondnode', 'MediaSessionQuality',
           'MediaSignallingtestResultFailure', 'MediaType', 'MeetingAttendeeReportObject', 'MeetingChatsApi',
           'MeetingClosedCaptionsApi', 'MeetingInviteesApi', 'MeetingMessagesApi', 'MeetingOptions',
           'MeetingParticipantsApi', 'MeetingPollsApi', 'MeetingPreferencesApi', 'MeetingQandAApi',
           'MeetingQualitiesApi', 'MeetingRecordingArchiveChat', 'MeetingRecordingArchiveParticipant',
           'MeetingRecordingArchivePoll', 'MeetingRecordingArchivePollAnswerSummary',
           'MeetingRecordingArchivePollQuestion', 'MeetingRecordingArchivePollRespondent', 'MeetingRecordingArchiveQA',
           'MeetingRecordingArchiveQAAnswer', 'MeetingRecordingArchiveSystemInfo', 'MeetingRecordingArchiveUser',
           'MeetingSeriesObjectForListMeeting', 'MeetingSessionTypeObject', 'MeetingTranscriptsApi', 'MeetingType',
           'MeetingUsageReportObject', 'MeetingsApi', 'MeetingsSummaryReportApi', 'Member', 'Member5', 'MemberObject',
           'MemberType', 'Membership', 'MembershipsApi', 'MessageStorage', 'MessageStorage3', 'MessagesApi',
           'MetricName', 'Metrics', 'ModifyDialPlanBody', 'ModifyNumbersForRouteListResponse',
           'ModifyPersonPlaceVirtualLineCallQueueObject', 'ModifyRouteListBody', 'ModifyScheduleEventListObject',
           'ModifyTrunkBody', 'ModifypersonsApplicationServicesSettingsBody', 'ModifypersonsMonitoringSettingsBody',
           'MohMessage', 'MonitoredElementItem', 'MonitoredElementUser', 'MonitoredMemberObject',
           'MonitoredPersonObject', 'Month', 'MoveRecordingsIntoRecycleBinBody', 'MppAudioCodecPriorityObject',
           'MppObject', 'MppVlanObject', 'Name', 'NetworkConnectionType', 'NetworkConnectivtyType', 'NetworkType',
           'NewNumber', 'NoAnswer', 'NoAnswer3', 'NodeAvailability', 'NodeAvailabilityCollection',
           'NodeAvailableTimeline', 'NodeStatusList1', 'NodesResult', 'NormalSource', 'NoteType', 'Notification',
           'NumberItem', 'NumberListGetObject', 'NumberStatus', 'Numbers', 'OfficeNumber', 'OnboardingMethodObject',
           'Op', 'Op1', 'Operation', 'Option', 'Option1', 'Options', 'OptionsForTrackingCodeObject', 'OrderBy',
           'OrderType', 'Organization', 'OrganizationsApi', 'OriginatorType', 'Outgoing', 'Overflow',
           'OverflowDetails1', 'OverflowtoCloudCollection', 'Owner', 'Package', 'Package6', 'Package8', 'ParkResponse',
           'Participant', 'ParticipantsByRoles', 'PartnerAdminUser', 'PartnerManagementApi', 'PartnerTagsApi',
           'PartyInformation', 'Passcode', 'PasswordCriteria', 'PatchMeetingBody', 'PatchMeetingResponse',
           'PatchMemberWithOperation', 'PbxUser', 'PeopleApi', 'PerClusterConnectivityResult1',
           'PerClusterConnectivityResult2', 'PerNodeConnectivityResult1', 'PerclusterMediaHealthMonitoringclusters',
           'PernodeMediaHealthMonitoringclusters', 'PernodeMediaHealthMonitoringresult', 'Person',
           'PersonalMeetingRoom', 'PhoneLanguage', 'PhoneNumber', 'PhoneNumbers', 'PhoneNumbers7', 'PlaceDevices',
           'Poll', 'PollResult', 'PostCallQueueCallPolicyObject', 'PostHoursMenuObject',
           'PostHuntGroupCallPolicyObject', 'PostPersonPlaceVirtualLineCallQueueObject',
           'PostPersonPlaceVirtualLineHuntGroupObject', 'PrecheckBroadworksSubscriberProvisioningResponse',
           'ProvisionBroadWorksSubscriberBody', 'ProvisionBroadWorksWorkspaceBody',
           'ProvisionBroadWorksWorkspaceResponse', 'ProvisionWholesaleCustomerBody',
           'ProvisionWholesaleCustomerResponse', 'ProvisionWholesaleSubscriberBody', 'ProvisioningParameters',
           'ProvisioningParameters4', 'PstnNumber', 'PushToTalkAccessType', 'PushToTalkConnectionType',
           'PutMemberObject', 'PutRecallHuntGroupObject', 'PutSharedLineMemberItem', 'QAObject',
           'QueryMeetingParticipantsWithEmailResponse', 'QueryMeetingRegistrantsResponse', 'QueryStatusResponse',
           'Question', 'Question1', 'Question8', 'QuestionObject', 'QuestionResult', 'QuestionWithAnswersObject',
           'ReachabilityTestResultsforcluster', 'ReachabilityTestResultsforfirstcluster',
           'ReachabilityTestResultsforoneclusteronenode', 'ReachabilityTestResultsforsinglecluster',
           'ReachabilityTestresultsFailure', 'ReachabilityTestresultsStunresults1',
           'ReachabilityTestresultsdestinationcluster', 'ReachabilityTestresultsfirstnode',
           'ReachabilityTestresultsforcluster', 'ReachabilityTestresultsfornode',
           'ReachabilityTestresultsfororganization', 'ReadBargeInSettingsForPersonResponse',
           'ReadCallInterceptSettingsForWorkspaceResponse', 'ReadCallRecordingSettingsForPersonResponse',
           'ReadCallToExtensionLocationsOfRoutingGroupResponse', 'ReadCallWaitingSettingsForPersonResponse',
           'ReadCallerIDSettingsForPersonResponse', 'ReadDECTDeviceTypeListResponse',
           'ReadDialPlanLocationsOfRoutingGroupResponse', 'ReadDoNotDisturbSettingsForPersonResponse',
           'ReadForwardingSettingsForPersonResponse', 'ReadHotelingSettingsForPersonResponse',
           'ReadIncomingPermissionSettingsForPersonResponse', 'ReadInternalDialingConfigurationForlocationResponse',
           'ReadListOfAnnouncementLanguagesResponse', 'ReadListOfAutoAttendantsResponse',
           'ReadListOfCallParkExtensionsResponse', 'ReadListOfCallParksResponse', 'ReadListOfCallPickupsResponse',
           'ReadListOfCallQueueAnnouncementFilesResponse', 'ReadListOfCallQueuesResponse',
           'ReadListOfDialPatternsResponse', 'ReadListOfDialPlansResponse', 'ReadListOfHuntGroupsResponse',
           'ReadListOfPagingGroupsResponse', 'ReadListOfReceptionistContactDirectoriesResponse',
           'ReadListOfRouteListsResponse', 'ReadListOfRoutingChoicesResponse', 'ReadListOfRoutingGroupsResponse',
           'ReadListOfSchedulesResponse', 'ReadListOfSupportedDevicesResponse', 'ReadListOfTrunkTypesResponse',
           'ReadListOfTrunksResponse', 'ReadListOfUCManagerProfilesResponse', 'ReadListOfVirtualLinesResponse',
           'ReadPSTNConnectionLocationsOfRoutingGroupResponse', 'ReadPersonsCallingBehaviorResponse',
           'ReadPushtoTalkSettingsForPersonResponse', 'ReadReceptionistClientSettingsForPersonResponse',
           'ReadRouteGroupForOrganizationResponse', 'ReadRouteListsOfRoutingGroupResponse',
           'ReadUsageOfRoutingGroupResponse', 'ReadVoicemailSettingsForPersonResponse',
           'ReaddeviceOverrideSettingsFororganizationResponse', 'Reason', 'ReassignMeetingErrorDescriptionObject',
           'ReassignMeetingResponseObject', 'ReassignMeetingsToNewHostResponse', 'RecallInformation', 'RecallTypeEnum',
           'Record', 'RecordingAchriveSummaryObject', 'RecordingObject', 'RecordingReportApi', 'RecordingReportObject',
           'RecordingReportSummaryObject', 'RecordingStateEnum', 'RecordingsApi', 'RecurWeekly2', 'RecurWeeklyObject',
           'RecurYearlyByDateObject', 'RecurYearlyByDayObject', 'Recurrence', 'RecurrenceObject1',
           'RedirectCollectionForCluster', 'RedirectCollectionForOrg', 'RedirectTrend1', 'RedirectionInformation',
           'RedirectionReasonEnum', 'RegisterMeetingRegistrantBody', 'RegisterMeetingRegistrantResponse',
           'Registration', 'Registration1', 'RejectActionEnum', 'Repeat', 'Report', 'ReportError',
           'ReportTemplatesApi', 'ReportsApi', 'Resource', 'ResourceDetails', 'ResourceGroup',
           'ResourceGroupMembership', 'ResourceGroupMembershipsApi', 'ResourceGroupsApi', 'Resources', 'Respondent',
           'RespondentsReferenceLinks', 'ResponseStatus', 'ResponseStatusType', 'Result', 'Result9', 'Results',
           'RetrieveAccessCodesForWorkspaceResponse', 'RetrieveCallForwardingSettingsForWorkspaceResponse',
           'RetrieveCallQueueAgentsCallerIDInformationResponse', 'RetrieveCallWaitingSettingsForWorkspaceResponse',
           'RetrieveCallerIDSettingsForWorkspaceResponse', 'RetrieveExecutiveAssistantSettingsForPersonResponse',
           'RetrieveListOfCallQueueCallerIDInformationResponse', 'RetrieveMonitoringSettingsForWorkspaceResponse',
           'RetrieveOutgoingPermissionSettingsForWorkspaceResponse',
           'RetrievepersonsApplicationServicesSettingsResponse', 'RetrievepersonsMonitoringSettingsResponse',
           'RetrievepersonsOutgoingCallingPermissionsSettingsResponse', 'RingPattern', 'Role', 'RolesApi', 'Room',
           'RoomTab', 'RoomTabsApi', 'RoomType', 'RoomsApi', 'RouteGroup', 'RouteGroupUsageRouteListGet',
           'RouteIdentity', 'RouteList', 'RouteListNumberPatch', 'RouteListNumberPatchResponse', 'RouteType', 'Rules',
           'ScheduleEventObject', 'ScheduleShortDetails', 'ScheduleStartCodeObject', 'ScheduledMeetingObject',
           'ScheduledType', 'SchedulingOptionsObject', 'SearchMemberObject', 'SearchMembersResponse',
           'SearchSharedLineAppearanceMembersResponse', 'SecurityAuditEventsApi', 'SecurityOptions', 'Selection1',
           'Selection2', 'SelectionType', 'SendAllCalls', 'SendBusyCalls', 'SendBusyCalls1', 'SendUnansweredCalls',
           'Sender', 'Service', 'ServiceType', 'ServiceType5', 'ServiceTypeResult1', 'SessionType', 'SessionTypesApi',
           'Sharing', 'SimultaneousInterpretation', 'SimultaneousInterpretation1', 'SingleNodeAvailability',
           'SingleNodeAvailabilityCollection', 'SingleNodeAvailableTimeline', 'SipAddressesType', 'SiteApi',
           'SiteSessionType', 'SiteType', 'Sites', 'SnippetObject', 'SnippetObject1', 'SortBy', 'Source', 'Sources',
           'SpaceClassificationsApi', 'StandardRegistrationApproveRule', 'StartJobResponse', 'State', 'State10',
           'State11', 'State13', 'State3', 'State4', 'Status', 'Status15', 'Status2', 'Status23', 'Status27',
           'Status3', 'Status30', 'Status32', 'Status39', 'Status40', 'Status43', 'Status7', 'Status9',
           'StepExecutionStatusesObject', 'StorageType', 'Subscriber', 'Subscriber1', 'SupportAndConfiguredInfo',
           'SupportedDevices', 'SurveyResultObject', 'SystemInfoCatalog', 'TagsObj', 'Team', 'TeamMembership',
           'TeamMembershipsApi', 'TeamsApi', 'Telephony', 'Telephony6', 'TelephonyConfig', 'TelephonySupport',
           'Template', 'TemplateObject', 'TemplateType', 'TemporaryDirectDownloadLinks', 'TestCallRoutingResponse',
           'TestClustersResult', 'Time', 'TrackingCodeItemForCreateMeetingObject', 'TrackingCodesApi',
           'TranscriptObject', 'TransportType', 'TriggerDirectorySyncForUserResponse',
           'TriggerOndemandTestForClusterResponse', 'Trunk', 'TrunkType', 'TrunkTypeWithDeviceType', 'Type', 'Type1',
           'Type12', 'Type14', 'Type15', 'Type24', 'Type3', 'Type32', 'Type34', 'Type37', 'Type48', 'Type49', 'Type54',
           'Type61', 'Type62', 'Type63', 'Type7', 'Type70', 'Type73', 'TypeObject', 'Unit',
           'UnknownExtensionRouteIdentity', 'UnlockedMeetingJoinSecurity', 'UpdateBroadworksWorkspaceBody',
           'UpdateCallParkResponse', 'UpdateCallPickupResponse', 'UpdateDeviceSettingsBody',
           'UpdateEventForpersonsScheduleResponse', 'UpdateLocationBody', 'UpdateLocationWebexCallingDetailsBody',
           'UpdateMeetingBreakoutSessionsResponse', 'UpdateMeetingCommonSettingsConfigurationBody',
           'UpdateParticipantResponse', 'UpdatePersonalMeetingRoomOptionsBody', 'UpdateResourceGroupMembershipBody',
           'UpdateScheduleEventResponse', 'UpdateScheduleResponse', 'UpdateScheduleResponse1',
           'UpdateSelectiveCallForwardingRuleForAutoAttendantResponse',
           'UpdateSelectiveCallForwardingRuleForCallQueueResponse',
           'UpdateSelectiveCallForwardingRuleForHuntGroupResponse', 'UpdateVideoOptionsResponse',
           'UpdateWholesaleCustomerBody', 'UpdateWholesaleCustomerResponse', 'UpdateWholesaleSubscriberBody',
           'UpdateWorkspaceBody', 'UserNumberItem', 'UserResponse', 'UserSessionTypes',
           'UtilizationForClusterCollection', 'UtilizationForClusterTrend1', 'UtilizationMetricsT1SJ',
           'ValidateDialPatternResponse', 'ValidateExtensionsResponse',
           'ValidateLocalGatewayFQDNAndDomainForTrunkBody', 'ValidatelistOfMACAddressResponse', 'ValidationRules',
           'ValidationRulesCollection', 'Video', 'Video4', 'VideoDevices', 'VideoIn', 'VideoMeshApi',
           'VirtualExtension', 'VirtualExtensionRange', 'VlanObject', 'VoiceMailPartyInformation',
           'VoiceMessageDetails', 'WaitMessage', 'WaitMode', 'WebexCallingDetailedCallHistoryApi',
           'WebexCallingDeviceSettingsApi', 'WebexCallingOrganizationSettingsApi', 'WebexCallingPersonSettingsApi',
           'WebexCallingVoiceMessagingApi', 'WebexCallingWorkspaceSettingsApi', 'Webhook', 'WebhooksApi', 'Week',
           'WelcomeMessage', 'WholesaleBillingReportsApi', 'WholesaleCustomersApi', 'WholesaleSubscribersApi',
           'WifiNetworkObject', 'Workspace', 'WorkspaceDurationMetricsResponse', 'WorkspaceLocationsApi',
           'WorkspaceMetricsApi', 'WorkspaceMetricsResponse', 'WorkspacePersonalizationApi', 'WorkspacesApi',
           'xAPIApi']


class Data3(ApiModel):
    #: The display name of the organization.
    actor_org_name: Optional[str]
    #: A description for the event.
    event_description: Optional[str]
    #: The name of the person who performed the action.
    actor_name: Optional[str]
    #: The email of the person who performed the action.
    actor_email: Optional[str]
    #: The browser user agent of the person who performed the action.
    actor_user_agent: Optional[str]
    #: A tracking identifier for the event.
    tracking_id: Optional[str]
    #: The category of resource changed by the event.
    event_category: Optional[str]
    #: The IP address of the person who performed the action.
    actor_ip: Optional[str]
    #: A more detailed description of the change made by the person.
    action_text: Optional[str]


class Data(Data3):
    #: The name of the resource being acted upon.
    target_name: Optional[str]
    #: Admin roles for the person.
    admin_roles: Optional[list[str]]
    #: The type of resource changed by the event.
    target_type: Optional[str]
    #: The identifier for the resource changed by the event.
    target_id: Optional[str]
    #: The orgId of the organization.
    target_org_id: Optional[str]
    #: The name of the organization being acted upon.
    target_org_name: Optional[str]


class AuditEvent(ApiModel):
    data: Optional[Data]
    #: The date and time the event took place.
    created: Optional[str]
    #: The orgId of the person who made the change.
    actor_org_id: Optional[str]
    #: A unique identifier for the event.
    id: Optional[str]
    #: The personId of the person who made the change.
    actor_id: Optional[str]


class ListAdminAuditEventsResponse(ApiModel):
    #: An array of audit event objects. See this article for details about each event type.
    items: Optional[list[AuditEvent]]


class ListAdminAuditEventCategoriesResponse(ApiModel):
    #: An array of audit event categories.
    event_categories: Optional[list[str]]


class AdminAuditEventsApi(ApiChild, base='adminAudit/event'):
    """
    Admin Audit Events are available to full administrators for certain events performed in Webex Control Hub.
    Administrators with accounts created before 2019 who have never logged into Webex Control Hub will need to log into
    Webex Control Hub at least once to enable access to this API.
    An administrator account with the audit:events_read scope is required to use this API.
    """

    def list_admin_audit_events(self, org_id: str, from_: , to_: , actor_id: str = None, offset: int = None, event_categories: list = None, **params) -> Generator[AuditEvent, None, None]:
        """
        List admin audit events in your organization. Several query parameters are available to filter the response.
        Long result sets will be split into pages.
        NOTE: A maximum of one year of audit events can be returned per request.

        :param org_id: List events in this organization, by ID.
        :type org_id: str
        :param from_: List events which occurred after a specific date and time.
        :type from_: 
        :param to_: List events which occurred before a specific date and time.
        :type to_: 
        :param actor_id: List events performed by this person, by ID.
        :type actor_id: str
        :param offset: Offset from the first result that you want to fetch.
        :type offset: int
        :param event_categories: List events, by event categories.
        :type event_categories: list

        documentation: https://developer.webex.com/docs/api/v1/admin-audit-events/list-admin-audit-events
        """
        params['orgId'] = org_id
        params['from'] = from_
        params['to'] = to_
        if actor_id is not None:
            params['actorId'] = actor_id
        if offset is not None:
            params['offset'] = offset
        if event_categories is not None:
            params['eventCategories'] = event_categories
        url = self.ep('s')
        return self.session.follow_pagination(url=url, model=AuditEvent, params=params)

    def list_admin_audit_event_categories(self) -> List[str]:
        """
        Get the list of all admin event categories.

        documentation: https://developer.webex.com/docs/api/v1/admin-audit-events/list-admin-audit-event-categories
        """
        url = self.ep('Categories')
        data = super().get(url=url)
        return data["eventCategories"]

class Inputs(ApiModel):
    name: Optional[str]
    url: Optional[str]
    email: Optional[str]
    tel: Optional[str]


class CreateAttachmentActionBody(ApiModel):
    #: The type of action to perform.
    type: Optional[str]
    #: The ID of the message which contains the attachment.
    message_id: Optional[str]
    #: The attachment action's inputs.
    inputs: Optional[Inputs]


class CreateAttachmentActionResponse(CreateAttachmentActionBody):
    #: A unique identifier for the action.
    id: Optional[str]
    #: The ID of the person who performed the action.
    person_id: Optional[str]
    #: The ID of the room in which the action was performed.
    room_id: Optional[str]
    #: The date and time the action was created.
    created: Optional[str]


class AttachmentActionsApi(ApiChild, base='attachment/actions'):
    """
    Users create attachment actions by interacting with message attachments such as clicking on a submit button in a
    card.
    """

    def create_action(self, type_: str, message_id: str, inputs: Inputs) -> CreateAttachmentActionResponse:
        """
        Create a new attachment action.

        :param type_: The type of action to perform.
        :type type_: str
        :param message_id: The ID of the message which contains the attachment.
        :type message_id: str
        :param inputs: The attachment action's inputs.
        :type inputs: Inputs

        documentation: https://developer.webex.com/docs/api/v1/attachment-actions/create-an-attachment-action
        """
        body = CreateAttachmentActionBody()
        if type_ is not None:
            body.type_ = type_
        if message_id is not None:
            body.message_id = message_id
        if inputs is not None:
            body.inputs = inputs
        url = self.ep()
        data = super().post(url=url, data=body.json())
        return CreateAttachmentActionResponse.parse_obj(data)

    def action_details(self, id: str) -> CreateAttachmentActionResponse:
        """
        Shows details for a attachment action, by ID.
        Specify the attachment action ID in the id URI parameter.

        :param id: A unique identifier for the attachment action.
        :type id: str

        documentation: https://developer.webex.com/docs/api/v1/attachment-actions/get-attachment-action-details
        """
        url = self.ep(f'{id}')
        data = super().get(url=url)
        return CreateAttachmentActionResponse.parse_obj(data)

class Type(str, Enum):
    #: refresh authorization used to create access tokens
    refresh = 'refresh'
    #: access token authorization
    access = 'access'


class Authorization(ApiModel):
    #: The unique authorization identifier.
    id: Optional[str]
    #: The unique identifier for the application.
    application_id: Optional[str]
    #: The name of the Integration.
    application_name: Optional[str]
    #: The unique oAuth client id.
    client_id: Optional[str]
    #: The date and time the authorization was created.
    created: Optional[str]
    #: The type of token associated with the authorization.
    type: Optional[Type]


class ListAuthorizationsForuserResponse(ApiModel):
    items: Optional[list[Authorization]]


class AuthorizationsApi(ApiChild, base='authorizations'):
    """
    Admin API. You need full or user level admin privileges to call this API.
    Authorizations are user grants to applications to act on the user's behalf. Authorizations are how Integrations get
    authorized with specific access scopes in the oAuth client life-cycle. Integrations and some of the Webex service
    portals, like developer.webex.com, are all oAuth clients.
    Your application receives an API access token and a refresh token through the oAuth process. The access token is
    used to call Webex APIs for which the user authorized the scopes. Access tokens expire fairly frequently, while
    refresh tokens (when being regularly used) will be refreshed to last forever (see Using the Refresh Token for
    details).
    In this API an authorization is synonymous with an API access token.
    To provide admins with fine-grained token management control, you use the /authorizations API with
    the DELETE HTTP method to revoke access and refresh tokens.
    Deleting a refresh token will revoke all associated access tokens as well. Deleting an access token will revoke the
    developers ability to call the APIs with it.
    Webex subsystems may cache the validity of the token for a short while longer after the authorization was deleted.
    Admins can revoke user authorizations for users in their organization.
    To use the authorizations API in an Integration the scopes must include:
    identity:tokens_write,identity:tokens_read.
    """

    def list_authorizations_foruser(self, person_id: str, person_email: str) -> list[Authorization]:
        """
        Lists all authorizations for a user. Either personId or personEmail must be provided. This API does not support
        pagination.

        :param person_id: List authorizations for this user id.
        :type person_id: str
        :param person_email: List authorizations for this user email.
        :type person_email: str

        documentation: https://developer.webex.com/docs/api/v1/authorizations/list-authorizations-for-a-user
        """
        params = {}
        params['personId'] = person_id
        params['personEmail'] = person_email
        url = self.ep()
        data = super().get(url=url, params=params)
        return parse_obj_as(list[Authorization], data["items"])

    def delete_authorization(self, authorization_id: str):
        """
        Deletes an authorization, by authorization ID.
        Specify the authorization Id in the authorizationId parameter in the URI which was listed in the list resource.

        :param authorization_id: The unique identifier for the message.
        :type authorization_id: str

        documentation: https://developer.webex.com/docs/api/v1/authorizations/delete-authorization
        """
        url = self.ep(f'{authorization_id}')
        super().delete(url=url)
        return

    def delete_authorization_of_org_and_client_id(self, client_id: str, org_id: str = None):
        """
        Deletes an authorization, by org ID and client ID.

        :param client_id: The unique oAuth client id.
        :type client_id: str
        :param org_id: The ID of the organization to which this person belongs. If no orgId is specified, use orgId
            from the OAuth token.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/authorizations/delete-authorization-of-org-and-client-id
        """
        params = {}
        params['clientId'] = client_id
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep()
        super().delete(url=url, params=params)
        return

class Status(str, Enum):
    #: Report generation is in progress.
    in_progress = 'IN_PROGRESS'
    #: Report generation is complete.
    completed = 'COMPLETED'
    #: Report generation failed.
    failed = 'FAILED'


class ListReport(ApiModel):
    #: A unique report ID that corresponds to a billing report.
    id: Optional[str]
    #: The year and month (YYYY-MM) for which the billing report was generated.
    billing_period: Optional[str]
    #: The status of the billing report.
    status: Optional[Status]


class ReportError(ApiModel):
    #: The error code itself.
    code: Optional[int]
    #: A textual representation of the error code.
    description: Optional[str]


class ListBroadWorksBillingReportsResponse(ApiModel):
    #: An array of reports objects.
    items: Optional[list[ListReport]]


class GetBroadWorksBillingReportResponse(ListReport):
    #: The date and time the report was generated.
    created: Optional[str]
    #: The person ID of the partner administrator who created the report.
    created_by: Optional[str]
    #: The URL for partners to download the billing report.
    temp_download_url: Optional[str]
    #: List of errors that occurred during report generation.
    #: Note:
    #:   * Captures errors that occurred during asynchronous or background report generation, after the request has
    #:     been accepted and a 202 OK response is returned.
    errors: Optional[list[ReportError]]


class CreateBroadWorksBillingReportBody(ApiModel):
    #: The year and month (YYYY-MM) for which the billing report is to be generated.
    billing_period: Optional[str]


class CreateBroadWorksBillingReportResponse(ApiModel):
    #: A unique report ID that corresponds to a billing report.
    id: Optional[str]


class BroadWorksBillingReportsApi(ApiChild, base='broadworks/billing/reports'):
    """
    These are a set of APIs that are specifically targeted at BroadWorks Service Providers who sign up to the Webex for
    BroadWorks solution. These APIs helps Service Providers to generate monthly billing reports with user billing data.
    Service Providers can use these reports to reconcile their monthly invoice. Please note
    these APIs require a functional BroadWorks system configured for Webex for BroadWorks. Read more about using this
    API
    at https://www.cisco.com/go/WebexBroadworksAPI.
    Viewing Webex for BroadWorks billing reports information requires a partner administrator auth token with
    spark-admin:broadworks_billing_reports_read scope. Creating, Deleting billing reports require a partner
    administrator auth token with spark-admin:broadworks_billing_reports_write scope.
    """

    def list_works_billing_reports(self, before: str = None, after: str = None, sort_by: str = None) -> list[ListReport]:
        """
        Search for reports. There are a number of filter options which can be combined in a single request.

        :param before: Only include billing reports created before this date.
        :type before: str
        :param after: Only include billing reports created after this date.
        :type after: str
        :param sort_by: Sort the reports. * Members: id status billingPeriod
        :type sort_by: str

        documentation: https://developer.webex.com/docs/api/v1/broadworks-billing-reports/list-broadworks-billing-reports
        """
        params = {}
        if before is not None:
            params['before'] = before
        if after is not None:
            params['after'] = after
        if sort_by is not None:
            params['sortBy'] = sort_by
        url = self.ep()
        data = super().get(url=url, params=params)
        return parse_obj_as(list[ListReport], data["items"])

    def works_billing_report(self, id: str) -> GetBroadWorksBillingReportResponse:
        """
        Retrieve a specific billing reconciliation report.

        :param id: A unique identifier for the report in request.
        :type id: str

        documentation: https://developer.webex.com/docs/api/v1/broadworks-billing-reports/get-a-broadworks-billing-report
        """
        url = self.ep(f'{id}')
        data = super().get(url=url)
        return GetBroadWorksBillingReportResponse.parse_obj(data)

    def create_works_billing_report(self, billing_period: str) -> str:
        """
        Generate a monthly reconciliation report.

        :param billing_period: The year and month (YYYY-MM) for which the billing report is to be generated.
        :type billing_period: str

        documentation: https://developer.webex.com/docs/api/v1/broadworks-billing-reports/create-a-broadworks-billing-report
        """
        body = CreateBroadWorksBillingReportBody()
        if billing_period is not None:
            body.billing_period = billing_period
        url = self.ep()
        data = super().post(url=url, data=body.json())
        return data["id"]

    def delete_works_billing_report(self, id: str):
        """
        Delete a monthly reconciliation report using a report ID.

        :param id: A unique report ID that corresponds to a billing report.
        :type id: str

        documentation: https://developer.webex.com/docs/api/v1/broadworks-billing-reports/delete-a-broadworks-billing-report
        """
        url = self.ep(f'{id}')
        super().delete(url=url)
        return

class UpdateBroadworksWorkspaceBody(ApiModel):
    #: The user ID of the workspace on BroadWorks.
    user_id: Optional[str]
    #: The primary phone number configured against the workspace on BroadWorks.
    primary_phone_number: Optional[str]
    #: The extension number configured against the workspace on BroadWorks.
    extension: Optional[str]


class ProvisionBroadWorksWorkspaceBody(UpdateBroadworksWorkspaceBody):
    #: Provisioning ID that defines how this workspace is to be provisioned for Cisco Webex Services. Each Customer
    #: Template will have their own unique Provisioning ID. This ID will be displayed under the chosen Customer
    #: Template on Cisco Webex Control Hub.
    provisioning_id: Optional[str]
    #: The Service Provider supplied unique identifier for the workspace's enterprise.
    sp_enterprise_id: Optional[str]
    #: The display name of the workspace.
    display_name: Optional[str]


class ProvisionBroadWorksWorkspaceResponse(ProvisionBroadWorksWorkspaceBody):
    #: A unique Cisco identifier for the workspace.
    id: Optional[str]
    #: The date and time the workspace was provisioned.
    created: Optional[str]


class BroadWorksDeviceProvisioningApi(ApiChild, base='broadworks/workspaces'):
    """
    Not supported for Webex for Government (FedRAMP)
    These are a set of APIs that are specifically targeted at BroadWorks Service Providers who sign up to the Webex for
    BroadWorks solution. They enable Service Providers to provision Cisco Webex Services for their workspaces. Please
    note these APIs require a
    functional BroadWorks system configured for Webex for BroadWorks. Read more about using this API at
    https://www.cisco.com/go/WebexBroadworksAPI.
    Provisioning, updating, and removing workspaces requires an administrator auth token with the
    spark-admin:places_write scope.
    """

    def provision_broad_works(self, provisioning_id: str, sp_enterprise_id: str, display_name: str, user_id: str = None, primary_phone_number: str = None, extension: str = None) -> ProvisionBroadWorksWorkspaceResponse:
        """
        Provision a new BroadWorks workspace for Cisco Webex services.
        This API allows a Service Provider to provision a workspace for an existing customer.

        :param provisioning_id: Provisioning ID that defines how this workspace is to be provisioned for Cisco Webex
            Services. Each Customer Template will have their own unique Provisioning ID. This ID will be displayed
            under the chosen Customer Template on Cisco Webex Control Hub.
        :type provisioning_id: str
        :param sp_enterprise_id: The Service Provider supplied unique identifier for the workspace's enterprise.
        :type sp_enterprise_id: str
        :param display_name: The display name of the workspace.
        :type display_name: str
        :param user_id: The user ID of the workspace on BroadWorks.
        :type user_id: str
        :param primary_phone_number: The primary phone number configured against the workspace on BroadWorks.
        :type primary_phone_number: str
        :param extension: The extension number configured against the workspace on BroadWorks.
        :type extension: str

        documentation: https://developer.webex.com/docs/api/v1/broadworks-device-provisioning/provision-a-broadworks-workspace
        """
        body = ProvisionBroadWorksWorkspaceBody()
        if provisioning_id is not None:
            body.provisioning_id = provisioning_id
        if sp_enterprise_id is not None:
            body.sp_enterprise_id = sp_enterprise_id
        if display_name is not None:
            body.display_name = display_name
        if user_id is not None:
            body.user_id = user_id
        if primary_phone_number is not None:
            body.primary_phone_number = primary_phone_number
        if extension is not None:
            body.extension = extension
        url = self.ep()
        data = super().post(url=url, data=body.json())
        return ProvisionBroadWorksWorkspaceResponse.parse_obj(data)

    def update_broadworks(self, workspace_id: str, user_id: str = None, primary_phone_number: str = None, extension: str = None) -> ProvisionBroadWorksWorkspaceResponse:
        """
        Update certain details of a provisioned BroadWorks workspace on Cisco Webex.

        :param workspace_id: A unique Cisco identifier for the workspace.
        :type workspace_id: str
        :param user_id: The user ID of the workspace on BroadWorks.
        :type user_id: str
        :param primary_phone_number: The primary phone number configured against the workspace on BroadWorks.
        :type primary_phone_number: str
        :param extension: The extension number configured against the workspace on BroadWorks.
        :type extension: str

        documentation: https://developer.webex.com/docs/api/v1/broadworks-device-provisioning/update-a-broadworks-workspace
        """
        body = UpdateBroadworksWorkspaceBody()
        if user_id is not None:
            body.user_id = user_id
        if primary_phone_number is not None:
            body.primary_phone_number = primary_phone_number
        if extension is not None:
            body.extension = extension
        url = self.ep(f'{workspace_id}')
        data = super().put(url=url, data=body.json())
        return ProvisionBroadWorksWorkspaceResponse.parse_obj(data)

    def remove_broad_works(self, workspace_id: str):
        """
        Remove the mapping between a BroadWorks workspace and Cisco Webex device.

        :param workspace_id: A unique Cisco identifier for the workspace.
        :type workspace_id: str

        documentation: https://developer.webex.com/docs/api/v1/broadworks-device-provisioning/remove-a-broadworks-workspace
        """
        url = self.ep(f'{workspace_id}')
        super().delete(url=url)
        return

class Errors(ApiModel):
    #: An error code that identifies the reason for the error
    #: Possible values: 6003
    error_code: Optional[int]
    #: A textual representation of the error code.
    #: Possible values: Broadworks External Directory User Sync failed while trying to connect to Broadworks cluster.
    description: Optional[str]


class DirectorySyncStatus(ApiModel):
    #: The start date and time of the last sync.
    last_sync_start_time: Optional[str]
    #: The end date and time of the last sync.
    last_sync_end_time: Optional[str]
    #: The sync status of the enterprise.
    sync_status: Optional[str]
    #: The number of users added to Common Identity (CI) in this sync.
    users_added: Optional[int]
    #: The number of users updated in Common Identity (CI) in this sync.
    users_updated: Optional[int]
    #: The number of users deleted from Common Identity (CI) in this sync.
    users_deleted: Optional[int]
    #: The number of machines added to Common Identity (CI) in this sync.
    machines_added: Optional[int]
    #: The number of machines updated in Common Identity (CI) in this sync.
    machines_updated: Optional[int]
    #: The number of machines deleted from Common Identity (CI) in this sync.
    machines_deleted: Optional[int]
    #: The number of total external users that have been added to CI across all syncs.
    total_external_users_in_ci: Optional[int]
    #: The number of total external machines that have been added to Common Identity (CI) across all syncs.
    total_external_machines_in_ci: Optional[int]
    #: The date and time of the last successful sync.
    last_successful_sync_time: Optional[str]
    #: Unique tracking identifier.
    last_sync_tracking_id: Optional[str]
    #: List of errors that occurred during that last attempt to sync this BroadWorks enterprise. This list captures
    #: errors that occurred during directory sync of the BroadWorks enterprise, after the API has been accepted and 200
    #: OK response returned. Any errors that occur during initial API request validation will be captured directly in
    #: error response with appropriate HTTP status code.
    errors: Optional[list[Errors]]
    #: The number of user contacts added to Contact service in this sync.
    user_contacts_added: Optional[int]
    #: The number of user contacts updated in Contact service in this sync.
    user_contacts_updated: Optional[int]
    #: The number of user contacts deleted from Contact service in this sync.
    user_contacts_deleted: Optional[int]
    #: The number of org contacts added to Contact service in this sync.
    org_contacts_added: Optional[int]
    #: The number of org contacts updated in Contact service in this sync.
    org_contacts_updated: Optional[int]
    #: The number of org contacts deleted from Contact service in this sync.
    org_contacts_deleted: Optional[int]
    #: The total number of user contacts in Contact service.
    total_user_contacts_in_contact_service: Optional[int]
    #: The total number of org contacts in Contact service.
    total_org_contacts_in_contact_service: Optional[int]


class BroadworksDirectorySync(ApiModel):
    #: The toggle to enable/disable directory sync.
    enable_dir_sync: Optional[bool]
    #: Directory sync status
    directory_sync_status: Optional[DirectorySyncStatus]


class UserResponse(ApiModel):
    #: The UserID of the user on Broadworks (A non-webex user).
    user_id: Optional[str]
    #: First name of the user on Broadworks.
    first_name: Optional[str]
    #: Last name of the user on Broadworks.
    last_name: Optional[str]
    #: Extension of the user on Broadworks.
    extension: Optional[str]
    #: Phone number of the user on Broadworks.
    number: Optional[str]
    #: Mobile number of the user on Broadworks.
    mobile: Optional[str]


class DialPatternAction(ApiModel):
    #: Add action, when adding a new dial pattern
    add: Optional[str]
    #: Delete action, when deleting an existing dial pattern
    delete: Optional[str]


class Status2(DialPatternAction):
    #: The external user is updated in this sync
    update = 'UPDATE'
    #: No changes made on the external user in this sync
    no_operation = 'NO_OPERATION'


class ListBroadWorksEnterprisesResponse(ApiModel):
    #: A unique Cisco identifier for the enterprise.
    id: Optional[str]
    #: The Organization ID of the enterprise on Webex.
    org_id: Optional[str]
    #: The Provisioning ID associated with the enterprise.
    provisioning_id: Optional[str]
    #: The Service Provider supplied unique identifier for the subscriber's enterprise.
    sp_enterprise_id: Optional[str]
    #: BroadWorks Directory sync
    broadworks_directory_sync: Optional[BroadworksDirectorySync]


class UpdateDirectorySyncForBroadWorksEnterpriseBody(ApiModel):
    #: The toggle to enable/disable directory sync.
    enable_dir_sync: Optional[bool]


class TriggerDirectorySyncForEnterpriseBody(ApiModel):
    #: At this time, the only value allowed for this attribute is SYNC_NOW which will trigger the directory sync for
    #: the BroadWorks enterprise.
    sync_status: Optional[str]


class TriggerDirectorySyncForUserBody(ApiModel):
    #: The user ID of the Broadworks user to be synced (A non-webex user).
    user_id: Optional[str]


class TriggerDirectorySyncForUserResponse(ApiModel):
    #: User Directory sync response
    user_response: Optional[UserResponse]
    #: The Status of the operation being performed.
    status: Optional[Status2]


class BroadWorksEnterprisesApi(ApiChild, base='broadworks/enterprises'):
    """
    Not supported for Webex for Government (FedRAMP)
    These are a set of APIs that are specifically targeted at BroadWorks Service Providers who sign up to the Webex for
    BroadWorks solution. They enable Service Providers to provision Webex Services for their subscribers. Please note
    these APIs require a functional BroadWorks system configured for Webex for BroadWorks. Read more about using this
    API
    at https://www.cisco.com/go/WebexBroadworksAPI.
    Viewing Webex for BroadWorks enterprise information requires an administrator auth token with
    spark-admin:broadworks_enterprises_read scope.
    Updating directory sync configuration or trigger directory sync for a Webex for BroadWorks enterprise require an
    administrator auth token with spark-admin:broadworks_enterprises_write scope.
    """

    def list_broad_works_enterprises(self, sp_enterprise_id: str = None, starts_with: str = None, max: int = None) -> ListBroadWorksEnterprisesResponse:
        """
        List the provisioned enterprises for a Service Provider. This API also lets a Service Provider search for their
        provisioned enterprises on Webex. A search on enterprises can be performed by either a full or partial
        enterprise identifier.

        :param sp_enterprise_id: The Service Provider supplied unique identifier for the subscriber's enterprise.
        :type sp_enterprise_id: str
        :param starts_with: The starting string of the enterprise identifiers to match against.
        :type starts_with: str
        :param max: Limit the number of enterprises returned in the search, up to 1000.
        :type max: int

        documentation: https://developer.webex.com/docs/api/v1/broadworks-enterprises/list-broadworks-enterprises
        """
        params = {}
        if sp_enterprise_id is not None:
            params['spEnterpriseId'] = sp_enterprise_id
        if starts_with is not None:
            params['startsWith'] = starts_with
        if max is not None:
            params['max'] = max
        url = self.ep()
        data = super().get(url=url, params=params)
        return ListBroadWorksEnterprisesResponse.parse_obj(data)

    def update_sync_for_broad_works_enterprise(self, id: str, enable_dir_sync: bool) -> BroadworksDirectorySync:
        """
        This API lets a Partner Admin enable or disable directory sync for the customer's Broadworks enterprise on
        Webex.

        :param id: A unique identifier for the enterprise in question.
        :type id: str
        :param enable_dir_sync: The toggle to enable/disable directory sync.
        :type enable_dir_sync: bool

        documentation: https://developer.webex.com/docs/api/v1/broadworks-enterprises/update-directory-sync-for-a-broadworks-enterprise
        """
        body = UpdateDirectorySyncForBroadWorksEnterpriseBody()
        if enable_dir_sync is not None:
            body.enable_dir_sync = enable_dir_sync
        url = self.ep(f'{id}/broadworksDirectorySync')
        data = super().put(url=url, data=body.json())
        return BroadworksDirectorySync.parse_obj(data)

    def trigger_sync_for_enterprise(self, id: str, sync_status: str) -> BroadworksDirectorySync:
        """
        This API lets a Partner Admin trigger a directory sync for the customer's Broadworks enterprise on Webex.

        :param id: A unique identifier for the enterprise in question.
        :type id: str
        :param sync_status: At this time, the only value allowed for this attribute is SYNC_NOW which will trigger the
            directory sync for the BroadWorks enterprise.
        :type sync_status: str

        documentation: https://developer.webex.com/docs/api/v1/broadworks-enterprises/trigger-directory-sync-for-an-enterprise
        """
        body = TriggerDirectorySyncForEnterpriseBody()
        if sync_status is not None:
            body.sync_status = sync_status
        url = self.ep(f'{id}/broadworksDirectorySync')
        data = super().post(url=url, data=body.json())
        return BroadworksDirectorySync.parse_obj(data)

    def sync_status_for_enterprise(self, id: str) -> BroadworksDirectorySync:
        """
        This API lets a Partner Admin get the most recent directory sync status for a customer's Broadworks enterprise
        on Webex.

        :param id: A unique identifier for the enterprise in question.
        :type id: str

        documentation: https://developer.webex.com/docs/api/v1/broadworks-enterprises/get-directory-sync-status-for-an-enterprise
        """
        url = self.ep(f'{id}/broadworksDirectorySync')
        data = super().get(url=url)
        return BroadworksDirectorySync.parse_obj(data)

    def trigger_sync_for_user(self, id: str, user_id: str = None) -> TriggerDirectorySyncForUserResponse:
        """
        This API lets a Partner Admin trigger a directory sync for an external user (real or virtual user) on
        Broadworks enterprise with Webex.

        :param id: A unique identifier for the enterprise in question.
        :type id: str
        :param user_id: The user ID of the Broadworks user to be synced (A non-webex user).
        :type user_id: str

        documentation: https://developer.webex.com/docs/api/v1/broadworks-enterprises/trigger-directory-sync-for-a-user
        """
        body = TriggerDirectorySyncForUserBody()
        if user_id is not None:
            body.user_id = user_id
        url = self.ep(f'{id}/broadworksDirectorySync/externalUser')
        data = super().post(url=url, data=body.json())
        return TriggerDirectorySyncForUserResponse.parse_obj(data)

class Package(str, Enum):
    #: Softphone package.
    softphone = 'softphone'
    #: Basic package.
    basic = 'basic'
    #: Standard package.
    standard = 'standard'
    #: Premium package.
    premium = 'premium'


class Status43(str, Enum):
    #: The subscriber is fully provisioned on Cisco Webex.
    provisioned = 'provisioned'
    #: The subscriber user migration is pending.
    pending_user_migration = 'pending_user_migration'


class Status3(Status43):
    #: Subscriber Provisioning is paused, pending input of email address.
    pending_email_input = 'pending_email_input'
    #: Subscriber Provisioning is paused. The subscriber has entered an email address but has yet to complete
    #: validation.
    pending_email_validation = 'pending_email_validation'
    #: Subscriber provisioning is in progress.
    provisioning = 'provisioning'
    #: An update is in progress for a provisioned subscriber.
    updating = 'updating'
    #: An error occurred provisioning the subscriber on Webex.
    error = 'error'


class Subscriber(UpdateBroadworksWorkspaceBody):
    #: A unique Cisco identifier for the subscriber.
    id: Optional[str]
    #: The Person Id of the subscriber on Webex. To be used when referencing this subscriber on other Webex APIs. Only
    #: presented when status is provisioned.
    person_id: Optional[str]
    #: The Service Provider supplied unique identifier for the subscriber's enterprise.
    sp_enterprise_id: Optional[str]
    #: The first name of the subscriber.
    first_name: Optional[str]
    #: The last name of the subscriber.
    last_name: Optional[str]
    #: The email address of the subscriber.
    email: Optional[str]
    #: The mobile phone number configured against the subscriber on BroadWorks.
    mobile_phone_number: Optional[str]
    #: The Webex for BroadWorks Package assigned to the subscriber.
    package: Optional[Package]
    #: The provisioning status of the user.
    status: Optional[Status3]
    #: List of errors that occurred during that last attempt to provision/update this subscriber.
    #: Note:
    #:   * This list captures errors that occurred during asynchronous or background provisioning of the subscriber,
    #:     after the API has been accepted and 200 OK response returned.
    #:   * Any errors that occur during initial API request validation will be captured directly in error response with
    #:     appropriate HTTP status code.
    errors: Optional[list[Errors]]
    #: The date and time the subscriber was provisioned.
    created: Optional[str]
    #: The date and time the provisioning status of the subscriber last changed.
    last_status_change: Optional[str]
    #: This Provisioning ID associated with this subscriber.
    provisioning_id: Optional[str]
    #: Indicates if the subscriber was self activated, rather than provisioned via these APIs.
    self_activated: Optional[bool]


class ProvisionBroadWorksSubscriberBody(UpdateBroadworksWorkspaceBody):
    #: This Provisioning ID defines how this subscriber is to be provisioned for Webex Services.
    #: Each Customer Template will have their own unique Provisioning ID. This ID will be displayed under the chosen
    #: Customer Template
    #: on Webex Control Hub.
    provisioning_id: Optional[str]
    #: The Service Provider supplied unique identifier for the subscriber's enterprise.
    sp_enterprise_id: Optional[str]
    #: The first name of the subscriber.
    first_name: Optional[str]
    #: The last name of the subscriber.
    last_name: Optional[str]
    #: The Webex for BroadWorks package to be assigned to the subscriber.
    package: Optional[Package]
    #: The mobile phone number configured against the subscriber on BroadWorks. Any empty value on update will remove
    #: the already configured mobile phone number.
    mobile_phone_number: Optional[str]
    #: The email address of the subscriber (mandatory for the trusted email provisioning flow).
    email: Optional[str]
    #: The {ISO-639-1}_{ISO-3166} or {ISO-639-1} locale or language code used as preferred language for organization
    #: and Webex Meeting Sites. Refer to the help page for more information.
    language: Optional[str]
    #: The time zone associated with the subscriber. Refer to the Webex Meetings Site Timezone section of the Webex for
    #: BroadWorks guide for more information.
    timezone: Optional[str]


class Info(ApiModel):
    #: Provisioning Precheck infoCode.
    info_code: Optional[int]
    #: A textual description of the infoCode.
    description: Optional[str]


class ListBroadWorksSubscribersResponse(ApiModel):
    #: An array of Subscriber objects.
    items: Optional[list[Subscriber]]


class UpdateBroadWorksSubscriberBody(UpdateBroadworksWorkspaceBody):
    #: The first name of the subscriber.
    first_name: Optional[str]
    #: The last name of the subscriber.
    last_name: Optional[str]
    #: The mobile phone number configured against the subscriber on BroadWorks. Any empty value on update will remove
    #: the already configured mobile phone number.
    mobile_phone_number: Optional[str]
    #: The time zone associated with the subscriber. Refer to the Webex Meetings Site Timezone section of the Webex for
    #: BroadWorks guide for more information.
    timezone: Optional[str]
    #: The Webex for BroadWorks Package to be assigned to the subscriber.
    package: Optional[str]


class PrecheckBroadworksSubscriberProvisioningBody(ProvisionBroadWorksSubscriberBody):
    #: Email address of the customer org user to be provisioned.
    customer_info: Optional[object]


class PrecheckBroadworksSubscriberProvisioningResponse(ApiModel):
    #: A textual representation of the Precheck response message containing the infoCode object in the case of a
    #: success response and the errorCode object in the case of failure.
    message: Optional[str]
    #: A list of ProvisioningPreCheckResponseInfo objects.
    info: Optional[Info]


class BroadWorksSubscribersApi(ApiChild, base='broadworks/subscribers'):
    """
    These are a set of APIs that are specifically targeted at BroadWorks Service Providers who sign up to the Webex for
    BroadWorks solution. They enable Service Providers to provision Webex Services for their subscribers. Please note
    these APIs require a functional BroadWorks system configured for Webex for BroadWorks. Read more about using this
    API
    at https://www.cisco.com/go/WebexBroadworksAPI.
    Viewing Webex for BroadWorks subscriber information requires an administrator auth token with
    spark-admin:broadworks_subscribers_read scope. Provisioning, updating, and removing subscribers requires an
    administrator auth token with the spark-admin:broadworks_subscribers_write scope.
    Additional Infocodes are given for all success cases. To learn more about the Infocodes used in Broadworks
    Subscriber Provisioning Precheck APIs, see the Provisioning Precheck API Info Codes guides.
    """

    def list_works_subscribers(self, user_id: str = None, person_id: str = None, email: str = None, provisioning_id: str = None, sp_enterprise_id: str = None, last_status_change: str = None, status: str = None, after: str = None, self_activated: bool = None, **params) -> Generator[Subscriber, None, None]:
        """
        This API lets a Service Provider search for their associated subscribers. There are a number of filter options
        that can be combined in a single request.

        :param user_id: The user ID of the subscriber on BroadWorks.
        :type user_id: str
        :param person_id: The Person ID of the Webex subscriber.
        :type person_id: str
        :param email: The email address of the subscriber.
        :type email: str
        :param provisioning_id: The Provisioning ID associated with this subscriber.
        :type provisioning_id: str
        :param sp_enterprise_id: The Service Provider supplied unique identifier for the subscriber's enterprise.
        :type sp_enterprise_id: str
        :param last_status_change: Only include subscribers with a provisioning status change after this date and time.
            Epoch time (in milliseconds) preferred, but ISO 8601 date format also accepted.
        :type last_status_change: str
        :param status: The provisioning status of the subscriber. This Parameter supports multiple comma separated
            values. For example : status=error,provisioned,provisioning. Possible values: pending_email_input,
            pending_email_validation, pending_user_migration, provisioning, provisioned, updating, error
        :type status: str
        :param after: Only include subscribers created after this date and time. Epoch time (in milliseconds)
            preferred, but ISO 8601 date format also accepted.
        :type after: str
        :param self_activated: Indicates if the subscriber was self activated, rather than provisioned via these APIs.
        :type self_activated: bool

        documentation: https://developer.webex.com/docs/api/v1/broadworks-subscribers/list-broadworks-subscribers
        """
        if user_id is not None:
            params['userId'] = user_id
        if person_id is not None:
            params['personId'] = person_id
        if email is not None:
            params['email'] = email
        if provisioning_id is not None:
            params['provisioningId'] = provisioning_id
        if sp_enterprise_id is not None:
            params['spEnterpriseId'] = sp_enterprise_id
        if last_status_change is not None:
            params['lastStatusChange'] = last_status_change
        if status is not None:
            params['status'] = status
        if after is not None:
            params['after'] = after
        if self_activated is not None:
            params['selfActivated'] = str(self_activated).lower()
        url = self.ep()
        return self.session.follow_pagination(url=url, model=Subscriber, params=params)

    def provision_works_subscriber(self, provisioning_id: str, sp_enterprise_id: str, first_name: str, last_name: str, package: Package, user_id: str = None, primary_phone_number: str = None, extension: str = None, mobile_phone_number: str = None, email: str = None, language: str = None, timezone: str = None) -> Subscriber:
        """
        Provision a new BroadWorks subscriber for Webex services.
        This API lets a Service Provider map a BroadWorks subscriber to a new or existing Webex user and assign the
        required licenses and entitlements for Webex and Meetings.

        :param provisioning_id: This Provisioning ID defines how this subscriber is to be provisioned for Webex
            Services. Each Customer Template will have their own unique Provisioning ID. This ID will be displayed
            under the chosen Customer Template on Webex Control Hub.
        :type provisioning_id: str
        :param sp_enterprise_id: The Service Provider supplied unique identifier for the subscriber's enterprise.
        :type sp_enterprise_id: str
        :param first_name: The first name of the subscriber.
        :type first_name: str
        :param last_name: The last name of the subscriber.
        :type last_name: str
        :param package: The Webex for BroadWorks package to be assigned to the subscriber.
        :type package: Package
        :param user_id: The user ID of the workspace on BroadWorks.
        :type user_id: str
        :param primary_phone_number: The primary phone number configured against the workspace on BroadWorks.
        :type primary_phone_number: str
        :param extension: The extension number configured against the workspace on BroadWorks.
        :type extension: str
        :param mobile_phone_number: The mobile phone number configured against the subscriber on BroadWorks. Any empty
            value on update will remove the already configured mobile phone number.
        :type mobile_phone_number: str
        :param email: The email address of the subscriber (mandatory for the trusted email provisioning flow).
        :type email: str
        :param language: The {ISO-639-1}_{ISO-3166} or {ISO-639-1} locale or language code used as preferred language
            for organization and Webex Meeting Sites. Refer to the help page for more information.
        :type language: str
        :param timezone: The time zone associated with the subscriber. Refer to the Webex Meetings Site Timezone
            section of the Webex for BroadWorks guide for more information.
        :type timezone: str

        documentation: https://developer.webex.com/docs/api/v1/broadworks-subscribers/provision-a-broadworks-subscriber
        """
        body = ProvisionBroadWorksSubscriberBody()
        if provisioning_id is not None:
            body.provisioning_id = provisioning_id
        if sp_enterprise_id is not None:
            body.sp_enterprise_id = sp_enterprise_id
        if first_name is not None:
            body.first_name = first_name
        if last_name is not None:
            body.last_name = last_name
        if package is not None:
            body.package = package
        if user_id is not None:
            body.user_id = user_id
        if primary_phone_number is not None:
            body.primary_phone_number = primary_phone_number
        if extension is not None:
            body.extension = extension
        if mobile_phone_number is not None:
            body.mobile_phone_number = mobile_phone_number
        if email is not None:
            body.email = email
        if language is not None:
            body.language = language
        if timezone is not None:
            body.timezone = timezone
        url = self.ep()
        data = super().post(url=url, data=body.json())
        return Subscriber.parse_obj(data)

    def works_subscriber(self, subscriber_id: str) -> Subscriber:
        """
        This API lets a Service Provider retrieve details of a provisioned BroadWorks subscriber on Webex.

        :param subscriber_id: A unique identifier for the subscriber in question.
        :type subscriber_id: str

        documentation: https://developer.webex.com/docs/api/v1/broadworks-subscribers/get-a-broadworks-subscriber
        """
        url = self.ep(f'{subscriber_id}')
        data = super().get(url=url)
        return Subscriber.parse_obj(data)

    def update_works_subscriber(self, subscriber_id: str, user_id: str = None, primary_phone_number: str = None, extension: str = None, first_name: str = None, last_name: str = None, mobile_phone_number: str = None, timezone: str = None, package: str = None) -> Subscriber:
        """
        This API lets a Service Provider update certain details of a provisioned BroadWorks subscriber
        on Webex.

        :param subscriber_id: A unique identifier for the subscriber in question.
        :type subscriber_id: str
        :param user_id: The user ID of the workspace on BroadWorks.
        :type user_id: str
        :param primary_phone_number: The primary phone number configured against the workspace on BroadWorks.
        :type primary_phone_number: str
        :param extension: The extension number configured against the workspace on BroadWorks.
        :type extension: str
        :param first_name: The first name of the subscriber.
        :type first_name: str
        :param last_name: The last name of the subscriber.
        :type last_name: str
        :param mobile_phone_number: The mobile phone number configured against the subscriber on BroadWorks. Any empty
            value on update will remove the already configured mobile phone number.
        :type mobile_phone_number: str
        :param timezone: The time zone associated with the subscriber. Refer to the Webex Meetings Site Timezone
            section of the Webex for BroadWorks guide for more information.
        :type timezone: str
        :param package: The Webex for BroadWorks Package to be assigned to the subscriber.
        :type package: str

        documentation: https://developer.webex.com/docs/api/v1/broadworks-subscribers/update-a-broadworks-subscriber
        """
        body = UpdateBroadWorksSubscriberBody()
        if user_id is not None:
            body.user_id = user_id
        if primary_phone_number is not None:
            body.primary_phone_number = primary_phone_number
        if extension is not None:
            body.extension = extension
        if first_name is not None:
            body.first_name = first_name
        if last_name is not None:
            body.last_name = last_name
        if mobile_phone_number is not None:
            body.mobile_phone_number = mobile_phone_number
        if timezone is not None:
            body.timezone = timezone
        if package is not None:
            body.package = package
        url = self.ep(f'{subscriber_id}')
        data = super().put(url=url, data=body.json())
        return Subscriber.parse_obj(data)

    def remove_works_subscriber(self, subscriber_id: str):
        """
        This API will allow a Service Provider to remove the mapping between a BroadWorks Subscriber and Webex user.

        :param subscriber_id: A unique identifier for the subscriber in question.
        :type subscriber_id: str

        documentation: https://developer.webex.com/docs/api/v1/broadworks-subscribers/remove-a-broadworks-subscriber
        """
        url = self.ep(f'{subscriber_id}')
        super().delete(url=url)
        return

    def precheckworks_subscriber_provisioning(self, provisioning_id: str, sp_enterprise_id: str, first_name: str, last_name: str, package: Package, user_id: str = None, primary_phone_number: str = None, extension: str = None, mobile_phone_number: str = None, email: str = None, language: str = None, timezone: str = None, customer_info: object = None) -> PrecheckBroadworksSubscriberProvisioningResponse:
        """
        Verify the likely success of provisioning a broadworks subscriber.

        :param provisioning_id: This Provisioning ID defines how this subscriber is to be provisioned for Webex
            Services. Each Customer Template will have their own unique Provisioning ID. This ID will be displayed
            under the chosen Customer Template on Webex Control Hub.
        :type provisioning_id: str
        :param sp_enterprise_id: The Service Provider supplied unique identifier for the subscriber's enterprise.
        :type sp_enterprise_id: str
        :param first_name: The first name of the subscriber.
        :type first_name: str
        :param last_name: The last name of the subscriber.
        :type last_name: str
        :param package: The Webex for BroadWorks package to be assigned to the subscriber.
        :type package: Package
        :param user_id: The user ID of the workspace on BroadWorks.
        :type user_id: str
        :param primary_phone_number: The primary phone number configured against the workspace on BroadWorks.
        :type primary_phone_number: str
        :param extension: The extension number configured against the workspace on BroadWorks.
        :type extension: str
        :param mobile_phone_number: The mobile phone number configured against the subscriber on BroadWorks. Any empty
            value on update will remove the already configured mobile phone number.
        :type mobile_phone_number: str
        :param email: The email address of the subscriber (mandatory for the trusted email provisioning flow).
        :type email: str
        :param language: The {ISO-639-1}_{ISO-3166} or {ISO-639-1} locale or language code used as preferred language
            for organization and Webex Meeting Sites. Refer to the help page for more information.
        :type language: str
        :param timezone: The time zone associated with the subscriber. Refer to the Webex Meetings Site Timezone
            section of the Webex for BroadWorks guide for more information.
        :type timezone: str
        :param customer_info: Email address of the customer org user to be provisioned.
        :type customer_info: object

        documentation: https://developer.webex.com/docs/api/v1/broadworks-subscribers/precheck-a-broadworks-subscriber-provisioning
        """
        body = PrecheckBroadworksSubscriberProvisioningBody()
        if provisioning_id is not None:
            body.provisioning_id = provisioning_id
        if sp_enterprise_id is not None:
            body.sp_enterprise_id = sp_enterprise_id
        if first_name is not None:
            body.first_name = first_name
        if last_name is not None:
            body.last_name = last_name
        if package is not None:
            body.package = package
        if user_id is not None:
            body.user_id = user_id
        if primary_phone_number is not None:
            body.primary_phone_number = primary_phone_number
        if extension is not None:
            body.extension = extension
        if mobile_phone_number is not None:
            body.mobile_phone_number = mobile_phone_number
        if email is not None:
            body.email = email
        if language is not None:
            body.language = language
        if timezone is not None:
            body.timezone = timezone
        if customer_info is not None:
            body.customer_info = customer_info
        url = self.ep('validate')
        data = super().post(url=url, data=body.json())
        return PrecheckBroadworksSubscriberProvisioningResponse.parse_obj(data)

class RejectActionEnum(str, Enum):
    busy = 'busy'
    temporarily_unavailable = 'temporarilyUnavailable'
    ignore = 'ignore'


class CallTypeEnum(str, Enum):
    location = 'location'
    organization = 'organization'
    external = 'external'
    emergency = 'emergency'
    repair = 'repair'
    other = 'other'


class VoiceMailPartyInformation(ApiModel):
    #: The party's name. Only present when the name is available and privacy is not enabled.
    name: Optional[str]
    #: The party's number. Only present when the number is available and privacy is not enabled. The number can be
    #: digits or a URI. Some examples for number include: 1234, 2223334444, +12223334444, *73, and user@company.domain.
    number: Optional[str]
    #: The party's person ID. Only present when the person ID is available and privacy is not enabled.
    person_id: Optional[str]
    #: The party's place ID. Only present when the place ID is available and privacy is not enabled.
    place_id: Optional[str]
    #: Indicates whether privacy is enabled for the name, number and personId/placeId.
    privacy_enabled: Optional[bool]


class PartyInformation(VoiceMailPartyInformation):
    #: The call type for the party.
    call_type: Optional[CallTypeEnum]


class DialResponse(ApiModel):
    #: A unique identifier for the call which is used in all subsequent commands for the same call.
    call_id: Optional[str]
    #: A unique identifier for the call session the call belongs to. This can be used to correlate multiple calls that
    #: are part of the same call session.
    call_session_id: Optional[str]


class CallPersonalityEnum(str, Enum):
    originator = 'originator'
    terminator = 'terminator'
    click_to_dial = 'clickToDial'


class DeviceConnectionStatus(ApiModel):
    connected: Optional[str]
    disconnected: Optional[str]


class CallStateEnum(DeviceConnectionStatus):
    connecting = 'connecting'
    alerting = 'alerting'
    held = 'held'
    remote_held = 'remoteHeld'


class RedirectionReasonEnum(str, Enum):
    busy = 'busy'
    no_answer = 'noAnswer'
    unavailable = 'unavailable'
    unconditional = 'unconditional'
    time_of_day = 'timeOfDay'
    divert = 'divert'
    follow_me = 'followMe'
    hunt_group = 'huntGroup'
    call_queue = 'callQueue'
    unknown = 'unknown'


class RedirectionInformation(ApiModel):
    #: The reason the incoming call was redirected.
    reason: Optional[RedirectionReasonEnum]
    #: The details of a party who redirected the incoming call.
    redirecting_party: Optional[PartyInformation]


class RecallTypeEnum(str, Enum):
    park = 'park'


class RecallInformation(ApiModel):
    #: The type of recall the incoming call is for. Park is the only type of recall currently supported but additional
    #: values may be added in the future.
    type: Optional[RecallTypeEnum]
    #: If the type is park, contains the details of where the call was parked. For example, if user A parks a call
    #: against user B and A is recalled for the park, then this field contains B's information in A's incoming call
    #: details. Only present when the type is park.
    party: Optional[PartyInformation]


class RecordingStateEnum(str, Enum):
    pending = 'pending'
    started = 'started'
    paused = 'paused'
    stopped = 'stopped'
    failed = 'failed'


class Call(ApiModel):
    #: The call identifier of the call.
    id: Optional[str]
    #: The call session identifier of the call session the call belongs to. This can be used to correlate multiple
    #: calls that are part of the same call session.
    call_session_id: Optional[str]
    #: The personality of the call.
    personality: Optional[CallPersonalityEnum]
    #: The current state of the call.
    state: Optional[CallStateEnum]
    #: The remote party's details. For example, if user A calls user B then B is the remote party in A's outgoing call
    #: details and A is the remote party in B's incoming call details.
    remote_party: Optional[PartyInformation]
    #: The appearance value for the call. The appearance value can be used to display the user's calls in an order
    #: consistent with the user's devices. Only present when the call has an appearance value assigned.
    appearance: Optional[int]
    #: The date and time the call was created.
    created: Optional[str]
    #: The date and time the call was answered. Only present when the call has been answered.
    answered: Optional[str]
    #: The list of details for previous redirections of the incoming call ordered from most recent to least recent. For
    #: example, if user B forwards an incoming call to user C, then a redirection entry is present for B's forwarding
    #: in C's incoming call details. Only present when there were previous redirections and the incoming call's state
    #: is alerting.
    redirections: Optional[list[RedirectionInformation]]
    #: The recall details for the incoming call. Only present when the incoming call is for a recall.
    recall: Optional[RecallInformation]
    #: The call's current recording state. Only present when the user's call recording has been invoked during the life
    #: of the call.
    recording_state: Optional[RecordingStateEnum]


class CallHistoryRecordTypeEnum(str, Enum):
    placed = 'placed'
    missed = 'missed'
    received = 'received'


class CallHistoryRecord(ApiModel):
    #: The type of call history record.
    type: Optional[CallHistoryRecordTypeEnum]
    #: The name of the called/calling party. Only present when the name is available and privacy is not enabled.
    name: Optional[str]
    #: The number of the called/calling party. Only present when the number is available and privacy is not enabled.
    #: The number can be digits or a URI. Some examples for number include: 1234, 2223334444, +12223334444, *73,
    #: user@company.domain
    number: Optional[str]
    #: Indicates whether privacy is enabled for the name and number.
    privacy_enabled: Optional[bool]
    #: The date and time the call history record was created. For a placed call history record, this is when the call
    #: was placed. For a missed call history record, this is when the call was disconnected. For a received call
    #: history record, this is when the call was answered.
    time: Optional[str]


class DialBody(ApiModel):
    #: The destination to be dialed. The destination can be digits or a URI. Some examples for destination include:
    #: 1234, 2223334444, +12223334444, *73, tel:+12223334444, user@company.domain, and sip:user@company.domain.
    destination: Optional[str]


class AnswerBody(ApiModel):
    #: The call identifier of the call to be answered.
    call_id: Optional[str]


class RejectBody(ApiModel):
    #: The call identifier of the call to be rejected.
    call_id: Optional[str]
    #: The rejection action to apply to the call. The busy action is applied if no specific action is provided.
    action: Optional[RejectActionEnum]


class HangupBody(ApiModel):
    #: The call identifier of the call to hangup.
    call_id: Optional[str]


class HoldBody(ApiModel):
    #: The call identifier of the call to hold.
    call_id: Optional[str]


class ResumeBody(ApiModel):
    #: The call identifier of the call to resume.
    call_id: Optional[str]


class DivertBody(ApiModel):
    #: The call identifier of the call to divert.
    call_id: Optional[str]
    #: The destination to divert the call to. If toVoicemail is false, destination is required. The destination can be
    #: digits or a URI. Some examples for destination include: 1234, 2223334444, +12223334444, *73, tel:+12223334444,
    #: user@company.domain, sip:user@company.domain
    destination: Optional[str]
    #: If set to true, the call is diverted to voicemail. If no destination is specified, the call is diverted to the
    #: user's own voicemail. If a destination is specified, the call is diverted to the specified user's voicemail.
    to_voicemail: Optional[bool]


class TransferBody(ApiModel):
    #: The call identifier of the first call to transfer. This parameter is mandatory if either callId2 or destination
    #: is provided.
    call_id1: Optional[str]
    #: The call identifier of the second call to transfer. This parameter is mandatory if callId1 is provided and
    #: destination is not provided.
    call_id2: Optional[str]
    #: The destination to be transferred to. The destination can be digits or a URI. Some examples for destination
    #: include: 1234, 2223334444, +12223334444, tel:+12223334444, user@company.domain, sip:user@company.domain. This
    #: parameter is mandatory if callId1 is provided and callId2 is not provided.
    destination: Optional[str]


class ParkBody(ApiModel):
    #: The call identifier of the call to park.
    call_id: Optional[str]
    #: Identifes where the call is to be parked. If not provided, the call is parked against the parking user. The
    #: destination can be digits or a URI. Some examples for destination include: 1234, 2223334444, +12223334444, *73,
    #: tel:+12223334444, user@company.domain, sip:user@company.domain
    destination: Optional[str]
    #: If set totrue, the call is parked against an automatically selected member of the user's call park group and the
    #: destination parameter is ignored.
    is_group_park: Optional[bool]


class ParkResponse(ApiModel):
    #: The details of where the call has been parked.
    parked_against: Optional[PartyInformation]


class RetrieveBody(ApiModel):
    #: Identifies where the call is parked. The number field from the park command response can be used as the
    #: destination for the retrieve command. If not provided, the call parked against the retrieving user is retrieved.
    #: The destination can be digits or a URI. Some examples for destination include: 1234, 2223334444, +12223334444,
    #: *73, tel:+12223334444, user@company.domain, sip:user@company.domain
    destination: Optional[str]


class StartRecordingBody(ApiModel):
    #: The call identifier of the call to start recording.
    call_id: Optional[str]


class StopRecordingBody(ApiModel):
    #: The call identifier of the call to stop recording.
    call_id: Optional[str]


class PauseRecordingBody(ApiModel):
    #: The call identifier of the call to pause recording.
    call_id: Optional[str]


class ResumeRecordingBody(ApiModel):
    #: The call identifier of the call to resume recording.
    call_id: Optional[str]


class TransmitDTMFBody(ApiModel):
    #: The call identifier of the call to transmit DTMF digits for.
    call_id: Optional[str]
    #: The DTMF digits to transmit. Each digit must be part of the following set: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, *, #,
    #: A, B, C, D]. A comma "," may be included to indicate a pause between digits. For the value “1,234”, the DTMF 1
    #: digit is initially sent. After a pause, the DTMF 2, 3, and 4 digits are sent successively.
    dtmf: Optional[str]


class PushBody(ApiModel):
    #: The call identifier of the call to push.
    call_id: Optional[str]


class PickupBody(ApiModel):
    #: Identifies the user to pickup an incoming call from. If not provided, an incoming call to the user's call pickup
    #: group is picked up. The target can be digits or a URI. Some examples for target include: 1234, 2223334444,
    #: +12223334444, tel:+12223334444, user@company.domain, sip:user@company.domain
    target: Optional[str]


class BargeInBody(ApiModel):
    #: Identifies the user to barge-in on. The target can be digits or a URI. Some examples for target include: 1234,
    #: 2223334444, +12223334444, tel:+12223334444, user@company.domain, sip:user@company.domain
    target: Optional[str]


class ListCallsResponse(ApiModel):
    items: Optional[list[Call]]


class ListCallHistoryResponse(ApiModel):
    items: Optional[list[CallHistoryRecord]]


class CallControlsApi(ApiChild, base='telephony/calls'):
    """
    Not supported for Webex for Government (FedRAMP)
    Call Control APIs in support of Webex Calling.
    All GET commands require the spark:calls_read scope while all other commands require the spark:calls_write scope.
    NOTE: These APIs support 3rd Party Call Control only.
    """

    def dial(self, destination: str) -> DialResponse:
        """
        Initiate an outbound call to a specified destination. This is also commonly referred to as Click to Call or
        Click to Dial. Alerts occur on all the devices belonging to a user. When a user answers on one of these
        alerting devices, an outbound call is placed from that device to the destination.

        :param destination: The destination to be dialed. The destination can be digits or a URI. Some examples for
            destination include: 1234, 2223334444, +12223334444, *73, tel:+12223334444, user@company.domain, and
            sip:user@company.domain.
        :type destination: str

        documentation: https://developer.webex.com/docs/api/v1/call-controls/dial
        """
        body = DialBody()
        if destination is not None:
            body.destination = destination
        url = self.ep('dial')
        data = super().post(url=url, data=body.json())
        return DialResponse.parse_obj(data)

    def answer(self, call_id: str):
        """
        Answer an incoming call on a user's primary device.

        :param call_id: The call identifier of the call to be answered.
        :type call_id: str

        documentation: https://developer.webex.com/docs/api/v1/call-controls/answer
        """
        body = AnswerBody()
        if call_id is not None:
            body.call_id = call_id
        url = self.ep('answer')
        super().post(url=url, data=body.json())
        return

    def reject(self, call_id: str, action: RejectActionEnum = None):
        """
        Reject an unanswered incoming call.

        :param call_id: The call identifier of the call to be rejected.
        :type call_id: str
        :param action: The rejection action to apply to the call. The busy action is applied if no specific action is
            provided.
        :type action: RejectActionEnum

        documentation: https://developer.webex.com/docs/api/v1/call-controls/reject
        """
        body = RejectBody()
        if call_id is not None:
            body.call_id = call_id
        if action is not None:
            body.action = action
        url = self.ep('reject')
        super().post(url=url, data=body.json())
        return

    def hangup(self, call_id: str):
        """
        Hangup a call. If used on an unanswered incoming call, the call is rejected and sent to busy.

        :param call_id: The call identifier of the call to hangup.
        :type call_id: str

        documentation: https://developer.webex.com/docs/api/v1/call-controls/hangup
        """
        body = HangupBody()
        if call_id is not None:
            body.call_id = call_id
        url = self.ep('hangup')
        super().post(url=url, data=body.json())
        return

    def hold(self, call_id: str):
        """
        Hold a connected call.

        :param call_id: The call identifier of the call to hold.
        :type call_id: str

        documentation: https://developer.webex.com/docs/api/v1/call-controls/hold
        """
        body = HoldBody()
        if call_id is not None:
            body.call_id = call_id
        url = self.ep('hold')
        super().post(url=url, data=body.json())
        return

    def resume(self, call_id: str):
        """
        Resume a held call.

        :param call_id: The call identifier of the call to resume.
        :type call_id: str

        documentation: https://developer.webex.com/docs/api/v1/call-controls/resume
        """
        body = ResumeBody()
        if call_id is not None:
            body.call_id = call_id
        url = self.ep('resume')
        super().post(url=url, data=body.json())
        return

    def divert(self, call_id: str, destination: str = None, to_voicemail: bool = None):
        """
        Divert a call to a destination or a user's voicemail. This is also commonly referred to as a Blind Transfer.

        :param call_id: The call identifier of the call to divert.
        :type call_id: str
        :param destination: The destination to divert the call to. If toVoicemail is false, destination is required.
            The destination can be digits or a URI. Some examples for destination include: 1234, 2223334444,
            +12223334444, *73, tel:+12223334444, user@company.domain, sip:user@company.domain
        :type destination: str
        :param to_voicemail: If set to true, the call is diverted to voicemail. If no destination is specified, the
            call is diverted to the user's own voicemail. If a destination is specified, the call is diverted to the
            specified user's voicemail.
        :type to_voicemail: bool

        documentation: https://developer.webex.com/docs/api/v1/call-controls/divert
        """
        body = DivertBody()
        if call_id is not None:
            body.call_id = call_id
        if destination is not None:
            body.destination = destination
        if to_voicemail is not None:
            body.to_voicemail = to_voicemail
        url = self.ep('divert')
        super().post(url=url, data=body.json())
        return

    def transfer(self, call_id1: str = None, call_id2: str = None, destination: str = None):
        """
        Transfer two calls together.
        Unanswered incoming calls cannot be transferred but can be diverted using the divert API.
        If the user has only two calls and wants to transfer them together, the callId1 and callId2 parameters are
        optional and when not provided the calls are automatically selected and transferred.
        If the user has more than two calls and wants to transfer two of them together, the callId1 and callId2
        parameters are mandatory to specify which calls are being transferred. Those are also commonly referred to as
        Attended Transfer, Consultative Transfer, or Supervised Transfer and will return a 204 response.
        If the user wants to transfer one call to a new destination but only when the destination responds, the callId1
        and destination parameters are mandatory to specify the call being transferred and the destination.
        This is referred to as a Mute Transfer and is similar to the divert API with the difference of waiting for the
        destination to respond prior to transferring the call. If the destination does not respond, the call is not
        transferred. This will return a 201 response.

        :param call_id1: The call identifier of the first call to transfer. This parameter is mandatory if either
            callId2 or destination is provided.
        :type call_id1: str
        :param call_id2: The call identifier of the second call to transfer. This parameter is mandatory if callId1 is
            provided and destination is not provided.
        :type call_id2: str
        :param destination: The destination to be transferred to. The destination can be digits or a URI. Some examples
            for destination include: 1234, 2223334444, +12223334444, tel:+12223334444, user@company.domain,
            sip:user@company.domain. This parameter is mandatory if callId1 is provided and callId2 is not provided.
        :type destination: str

        documentation: https://developer.webex.com/docs/api/v1/call-controls/transfer
        """
        body = TransferBody()
        if call_id1 is not None:
            body.call_id1 = call_id1
        if call_id2 is not None:
            body.call_id2 = call_id2
        if destination is not None:
            body.destination = destination
        url = self.ep('transfer')
        super().post(url=url, data=body.json())
        return

    def park(self, call_id: str, destination: str = None, is_group_park: bool = None) -> PartyInformation:
        """
        Park a connected call. The number field in the response can be used as the destination for the retrieve command
        to retrieve the parked call.

        :param call_id: The call identifier of the call to park.
        :type call_id: str
        :param destination: Identifes where the call is to be parked. If not provided, the call is parked against the
            parking user. The destination can be digits or a URI. Some examples for destination include: 1234,
            2223334444, +12223334444, *73, tel:+12223334444, user@company.domain, sip:user@company.domain
        :type destination: str
        :param is_group_park: If set totrue, the call is parked against an automatically selected member of the user's
            call park group and the destination parameter is ignored.
        :type is_group_park: bool

        documentation: https://developer.webex.com/docs/api/v1/call-controls/park
        """
        body = ParkBody()
        if call_id is not None:
            body.call_id = call_id
        if destination is not None:
            body.destination = destination
        if is_group_park is not None:
            body.is_group_park = is_group_park
        url = self.ep('park')
        data = super().post(url=url, data=body.json())
        return PartyInformation.parse_obj(data["parkedAgainst"])

    def retrieve(self, destination: str = None) -> DialResponse:
        """
        Retrieve a parked call. A new call is initiated to perform the retrieval in a similar manner to the dial
        command. The number field from the park command response can be used as the destination for the retrieve
        command.

        :param destination: Identifies where the call is parked. The number field from the park command response can be
            used as the destination for the retrieve command. If not provided, the call parked against the retrieving
            user is retrieved. The destination can be digits or a URI. Some examples for destination include: 1234,
            2223334444, +12223334444, *73, tel:+12223334444, user@company.domain, sip:user@company.domain
        :type destination: str

        documentation: https://developer.webex.com/docs/api/v1/call-controls/retrieve
        """
        body = RetrieveBody()
        if destination is not None:
            body.destination = destination
        url = self.ep('retrieve')
        data = super().post(url=url, data=body.json())
        return DialResponse.parse_obj(data)

    def start(self, call_id: str = None):
        """
        Start recording a call. Use of this API is only valid when the user's call recording mode is set to "On
        Demand".

        :param call_id: The call identifier of the call to start recording.
        :type call_id: str

        documentation: https://developer.webex.com/docs/api/v1/call-controls/start-recording
        """
        body = StartRecordingBody()
        if call_id is not None:
            body.call_id = call_id
        url = self.ep('startRecording')
        super().post(url=url, data=body.json())
        return

    def stop(self, call_id: str = None):
        """
        Stop recording a call. Use of this API is only valid when a call is being recorded and the user's call
        recording mode is set to "On Demand".

        :param call_id: The call identifier of the call to stop recording.
        :type call_id: str

        documentation: https://developer.webex.com/docs/api/v1/call-controls/stop-recording
        """
        body = StopRecordingBody()
        if call_id is not None:
            body.call_id = call_id
        url = self.ep('stopRecording')
        super().post(url=url, data=body.json())
        return

    def pause(self, call_id: str = None):
        """
        Pause recording on a call. Use of this API is only valid when a call is being recorded and the user's call
        recording mode is set to "On Demand" or "Always with Pause/Resume".

        :param call_id: The call identifier of the call to pause recording.
        :type call_id: str

        documentation: https://developer.webex.com/docs/api/v1/call-controls/pause-recording
        """
        body = PauseRecordingBody()
        if call_id is not None:
            body.call_id = call_id
        url = self.ep('pauseRecording')
        super().post(url=url, data=body.json())
        return

    def resume(self, call_id: str = None):
        """
        Resume recording a call. Use of this API is only valid when a call's recording is paused and the user's call
        recording mode is set to "On Demand" or "Always with Pause/Resume".

        :param call_id: The call identifier of the call to resume recording.
        :type call_id: str

        documentation: https://developer.webex.com/docs/api/v1/call-controls/resume-recording
        """
        body = ResumeRecordingBody()
        if call_id is not None:
            body.call_id = call_id
        url = self.ep('resumeRecording')
        super().post(url=url, data=body.json())
        return

    def transmit_dtmf(self, call_id: str = None, dtmf: str = None):
        """
        Transmit DTMF digits to a call.

        :param call_id: The call identifier of the call to transmit DTMF digits for.
        :type call_id: str
        :param dtmf: The DTMF digits to transmit. Each digit must be part of the following set: [0, 1, 2, 3, 4, 5, 6,
            7, 8, 9, *, #, A, B, C, D]. A comma "," may be included to indicate a pause between digits. For the value
            “1,234”, the DTMF 1 digit is initially sent. After a pause, the DTMF 2, 3, and 4 digits are sent
            successively.
        :type dtmf: str

        documentation: https://developer.webex.com/docs/api/v1/call-controls/transmit-dtmf
        """
        body = TransmitDTMFBody()
        if call_id is not None:
            body.call_id = call_id
        if dtmf is not None:
            body.dtmf = dtmf
        url = self.ep('transmitDtmf')
        super().post(url=url, data=body.json())
        return

    def push(self, call_id: str = None):
        """
        Pushes a call from the assistant to the executive the call is associated with. Use of this API is only valid
        when the assistant's call is associated with an executive.

        :param call_id: The call identifier of the call to push.
        :type call_id: str

        documentation: https://developer.webex.com/docs/api/v1/call-controls/push
        """
        body = PushBody()
        if call_id is not None:
            body.call_id = call_id
        url = self.ep('push')
        super().post(url=url, data=body.json())
        return

    def pickup(self, target: str = None) -> DialResponse:
        """
        Picks up an incoming call to another user. A new call is initiated to perform the pickup in a similar manner to
        the dial command. When target is not present, the API pickups up a call from the user's call pickup group. When
        target is present, the API pickups an incoming call from the specified target user.

        :param target: Identifies the user to pickup an incoming call from. If not provided, an incoming call to the
            user's call pickup group is picked up. The target can be digits or a URI. Some examples for target include:
            1234, 2223334444, +12223334444, tel:+12223334444, user@company.domain, sip:user@company.domain
        :type target: str

        documentation: https://developer.webex.com/docs/api/v1/call-controls/pickup
        """
        body = PickupBody()
        if target is not None:
            body.target = target
        url = self.ep('pickup')
        data = super().post(url=url, data=body.json())
        return DialResponse.parse_obj(data)

    def barge_in(self, target: str) -> DialResponse:
        """
        Barge-in on another user's answered call. A new call is initiated to perform the barge-in in a similar manner
        to the dial command.

        :param target: Identifies the user to barge-in on. The target can be digits or a URI. Some examples for target
            include: 1234, 2223334444, +12223334444, tel:+12223334444, user@company.domain, sip:user@company.domain
        :type target: str

        documentation: https://developer.webex.com/docs/api/v1/call-controls/barge-in
        """
        body = BargeInBody()
        if target is not None:
            body.target = target
        url = self.ep('bargeIn')
        data = super().post(url=url, data=body.json())
        return DialResponse.parse_obj(data)

    def list_calls(self) -> list[Call]:
        """
        Get the list of details for all active calls associated with the user.

        documentation: https://developer.webex.com/docs/api/v1/call-controls/list-calls
        """
        url = self.ep()
        data = super().get(url=url)
        return parse_obj_as(list[Call], data["items"])

    def call_details(self, call_id: str) -> Call:
        """
        Get the details of the specified active call for the user.

        :param call_id: The call identifier of the call.
        :type call_id: str

        documentation: https://developer.webex.com/docs/api/v1/call-controls/get-call-details
        """
        url = self.ep(f'{call_id}')
        data = super().get(url=url)
        return Call.parse_obj(data)

    def list_call_history(self, type_: str = None) -> list[CallHistoryRecord]:
        """
        Get the list of call history records for the user. A maximum of 20 call history records per type (placed,
        missed, received) are returned.

        :param type_: The type of call history records to retrieve. If not specified, then all call history records are
            retrieved. Possible values: placed, missed, received
        :type type_: str

        documentation: https://developer.webex.com/docs/api/v1/call-controls/list-call-history
        """
        params = {}
        if type_ is not None:
            params['type'] = type_
        url = self.ep('history')
        data = super().get(url=url, params=params)
        return parse_obj_as(list[CallHistoryRecord], data["items"])

class Source(str, Enum):
    #: Current value comes from the schema default.
    default = 'default'
    #: Current value comes from configuredValue.
    configured = 'configured'


class Editability(ApiModel):
    #: Whether or not the value is editable on this source (always false for default).
    is_editable: Optional[bool]
    #: The reason value is not editable on this source (always FACTORY_DEFAULT for default).
    reason: Optional[str]


class Default(ApiModel):
    editability: Optional[Editability]


class Reason(str, Enum):
    #: User is not authorized to edit any values.
    not_authorized = 'NOT_AUTHORIZED'
    #: The configuration is managed by a different authority. For example CUCM.
    config_managed_by_different_authority = 'CONFIG_MANAGED_BY_DIFFERENT_AUTHORITY'


class Editability1(ApiModel):
    #: Whether or not the value is editable on this source.
    is_editable: Optional[bool]
    #: The reason the value is not editable on this source.
    reason: Optional[Reason]


class Configured(ApiModel):
    editability: Optional[Editability1]


class Sources(ApiModel):
    default: Optional[Default]
    configured: Optional[Configured]


class Configuration_key(ApiModel):
    #: The source of the current value that is applied to the device.
    source: Optional[Source]
    sources: Optional[Sources]
    #: JSON Schema describing the data format of the configuration as specified by the device.
    value_space: Optional[object]


class DeviceConfiguration(ApiModel):
    #: Key of the configuration.
    configuration_key: Optional[Configuration_key]


class Op(str, Enum):
    #: Remove the configured value and revert back to the default from schema, if present.
    remove = 'remove'
    #: Set the configured value.
    replace = 'replace'


class ListDeviceConfigurationsForDeviceResponse(ApiModel):
    #: ID of the device that the configurations are for.
    device_id: Optional[str]
    items: Optional[DeviceConfiguration]


class UpdateDeviceConfigurationsBody(ApiModel):
    op: Optional[Op]
    #: Only paths ending in /sources/configured/value are supported.
    path: Optional[str]
    value: Optional[One of stringOR numberOR boolean]


class DeviceConfigurationsApi(ApiChild, base='deviceConfigurations'):
    """
    The Device Configurations functionality and API endpoints described here are currently pre-release features which
    are not available to all Webex users. If you have any questions, or if you need help, please contact the Webex
    Developer Support team at devsupport@webex.com.
    The Device Configurations API allows developers to view and modify configurations on Webex Rooms devices, as well
    as other devices that use the configuration service.
    Viewing the list of all device configurations in an organization requires an administrator auth token with the
    spark-admin:devices_read scope. Adding, updating, or deleting configurations for devices in an organization
    requires an administrator auth token with both the spark-admin:devices_write and the spark-admin:devices_read
    scope.
    """

    def list_configurations_for(self, device_id: str, key: str = None) -> ListDeviceConfigurationsForDeviceResponse:
        """
        Lists all device configurations associated with the given device ID. Administrators can list configurations for
        all devices within an organization.

        :param device_id: List device configurations by device ID.
        :type device_id: str
        :param key: This can optionally be used to filter configurations. Keys are composed of segments. It's possible
            to use absolute paths, wildcards or ranges. * Absolute gives only one configuration as a result.
            Conference.MaxReceiveCallRate for example gives the Conference MaxReceiveCallRate configuration. *
            Wildcards (*) can specify multiple configurations with shared segments. Audio.Ultrasound.* for example will
            filter on all Audio Ultrasound configurations. * Range ([ number ]) can be used to filter numbered
            segments. FacilityService.Service[1].Name for instance only shows the first FacilityService Service Name
            configuration, FacilityService.Service[*].Name shows all, FacilityService.Service[1..3].Name shows the
            first three and FacilityService.Service[2..n].Name shows all starting at 2. Note that RFC 3986 3.2.2 does
            not allow square brackets in urls outside the host, so to specify range in a configuration key you will
            need to encode them to %5B for [ and %5D for ].
        :type key: str

        documentation: https://developer.webex.com/docs/api/v1/device-configurations/list-device-configurations-for-device
        """
        params = {}
        params['deviceId'] = device_id
        if key is not None:
            params['key'] = key
        url = self.ep()
        data = super().get(url=url, params=params)
        return ListDeviceConfigurationsForDeviceResponse.parse_obj(data)

    def update_configurations(self, device_id: str, op: Op = None, path: str = None, value: One of stringOR numberOR boolean = None) -> ListDeviceConfigurationsForDeviceResponse:
        """
        Update requests use JSON Patch syntax.
        When using JSON Patch you are required to specify a Content-Type header with value application/json-patch+json.

        :param device_id: Update device configurations by device ID.
        :type device_id: str
        :param op: 
        :type op: Op
        :param path: Only paths ending in /sources/configured/value are supported.
        :type path: str
        :param value: 
        :type value: One of stringOR numberOR boolean

        documentation: https://developer.webex.com/docs/api/v1/device-configurations/update-device-configurations
        """
        params = {}
        params['deviceId'] = device_id
        body = UpdateDeviceConfigurationsBody()
        if op is not None:
            body.op = op
        if path is not None:
            body.path = path
        if value is not None:
            body.value = value
        url = self.ep()
        data = super().patch(url=url, params=params, data=body.json())
        return ListDeviceConfigurationsForDeviceResponse.parse_obj(data)

class NetworkConnectivtyType(ApiModel):
    wired: Optional[str]


class Member(ApiModel):
    #: Person ID of the group member.
    id: Optional[str]
    #: Member type.
    type: Optional[str]
    display_name: Optional[str]


class Device(Member):
    #: The placeId field has been deprecated. Please use workspaceId instead.
    place_id: Optional[str]
    #: The workspace associated with the device.
    workspace_id: Optional[str]
    #: The person associated with the device.
    person_id: Optional[str]
    #: The organization associated with the device.
    org_id: Optional[str]
    #: The capabilities of the device.
    capabilities: Optional[list[xapi]]
    #: The permissions the user has for this device. For example, xapi means this user is entitled to using the xapi
    #: against this device.
    permissions: Optional[list[xapi]]
    #: The connection status of the device.
    connection_status: Optional[DeviceConnectionStatus]
    #: The product name.
    product: Optional[str]
    #: Tags assigned to the device.
    tags: Optional[list[str]]
    #: The current IP address of the device.
    ip: Optional[str]
    #: The current network connectivty for the device.
    active_interface: Optional[NetworkConnectivtyType]
    #: The unique address for the network adapter.
    mac: Optional[str]
    #: The primary SIP address to dial this device.
    primary_sip_url: Optional[str]
    #: All SIP addresses to dial this device.
    sip_urls: Optional[list[str]]
    #: Serial number for the device.
    serial: Optional[str]
    #: The operating system name data and version tag.
    software: Optional[str]
    #: The upgrade channel the device is assigned to.
    upgrade_channel: Optional[str]
    #: The date and time that the device was registered, in ISO8601 format.
    created: Optional[str]
    #: The workspace location associated with the device.
    workspace_location_id: Optional[str]


class Op1(Op):
    #: Add a new tags list to the device.
    add = 'add'


class ListDevicesResponse(ApiModel):
    items: Optional[list[Device]]


class ModifyDeviceTagsBody(ApiModel):
    op: Optional[Op1]
    #: Only the tags path is supported to patch.
    path: Optional[str]
    #: Possible values: First Tag, Second Tag
    value: Optional[list[str]]


class CreateDeviceActivationCodeBody(ApiModel):
    #: The ID of the workspace where the device will be activated.
    workspace_id: Optional[str]


class CreateDeviceActivationCodeResponse(ApiModel):
    #: The activation code.
    code: Optional[str]
    #: The date and time the activation code expires.
    expiry_time: Optional[str]


class DevicesApi(ApiChild, base='devices'):
    """
    Devices represent cloud-registered Webex RoomOS devices. Devices may be associated with Workspaces.
    The following scopes are required for performing the specified actions:
    Searching and viewing details for devices requires an auth token with the spark:devices_read scope.
    Updating or deleting your devices requires an auth token with the spark:devices_write scope.
    Viewing the list of all devices in an organization requires an administrator auth token with the
    spark-admin:devices_read scope.
    Adding, updating, or deleting all devices in an organization requires an administrator auth token with the
    spark-admin:devices_write scope.
    Generating an activation code requires an auth token with the identity:placeonetimepassword_create scope.
    """

    def list(self, person_id: str = None, workspace_id: str = None, org_id: str = None, workspace_location_id: str = None, display_name: str = None, product: str = None, type_: str = None, tag: str = None, connection_status: str = None, serial: str = None, software: str = None, upgrade_channel: str = None, error_code: str = None, capability: str = None, permission: str = None, **params) -> Generator[Device, None, None]:
        """
        Lists all active Webex devices associated with the authenticated user, such as devices activated in personal
        mode. Administrators can list all devices within an organization.

        :param person_id: List devices by person ID.
        :type person_id: str
        :param workspace_id: List devices by workspace ID.
        :type workspace_id: str
        :param org_id: List devices in this organization. Only admin users of another organization (such as partners)
            may use this parameter.
        :type org_id: str
        :param workspace_location_id: List devices by workspace location ID.
        :type workspace_location_id: str
        :param display_name: List devices with this display name.
        :type display_name: str
        :param product: List devices with this product name. Possible values: DX-80, RoomKit, SX-80
        :type product: str
        :param type_: List devices with this type. Possible values: roomdesk, accessory, webexgo, unknown
        :type type_: str
        :param tag: List devices which have a tag. Searching for multiple tags (logical AND) can be done by comma
            separating the tag values or adding several tag parameters.
        :type tag: str
        :param connection_status: List devices with this connection status.
        :type connection_status: str
        :param serial: List devices with this serial number.
        :type serial: str
        :param software: List devices with this software version.
        :type software: str
        :param upgrade_channel: List devices with this upgrade channel.
        :type upgrade_channel: str
        :param error_code: List devices with this error code.
        :type error_code: str
        :param capability: List devices with this capability. Possible values: xapi
        :type capability: str
        :param permission: List devices with this permission.
        :type permission: str

        documentation: https://developer.webex.com/docs/api/v1/devices/list-devices
        """
        if person_id is not None:
            params['personId'] = person_id
        if workspace_id is not None:
            params['workspaceId'] = workspace_id
        if org_id is not None:
            params['orgId'] = org_id
        if workspace_location_id is not None:
            params['workspaceLocationId'] = workspace_location_id
        if display_name is not None:
            params['displayName'] = display_name
        if product is not None:
            params['product'] = product
        if type_ is not None:
            params['type'] = type_
        if tag is not None:
            params['tag'] = tag
        if connection_status is not None:
            params['connectionStatus'] = connection_status
        if serial is not None:
            params['serial'] = serial
        if software is not None:
            params['software'] = software
        if upgrade_channel is not None:
            params['upgradeChannel'] = upgrade_channel
        if error_code is not None:
            params['errorCode'] = error_code
        if capability is not None:
            params['capability'] = capability
        if permission is not None:
            params['permission'] = permission
        url = self.ep()
        return self.session.follow_pagination(url=url, model=Device, params=params)

    def details(self, device_id: str) -> Device:
        """
        Shows details for a device, by ID.
        Specify the device ID in the deviceId parameter in the URI.

        :param device_id: A unique identifier for the device.
        :type device_id: str

        documentation: https://developer.webex.com/docs/api/v1/devices/get-device-details
        """
        url = self.ep(f'{device_id}')
        data = super().get(url=url)
        return Device.parse_obj(data)

    def delete(self, device_id: str):
        """
        Deletes a device, by ID.
        Specify the device ID in the deviceId parameter in the URI.

        :param device_id: A unique identifier for the device.
        :type device_id: str

        documentation: https://developer.webex.com/docs/api/v1/devices/delete-a-device
        """
        url = self.ep(f'{device_id}')
        super().delete(url=url)
        return

    def modify_tags(self, device_id: str, op: Op1 = None, path: str = None, value: List[str] = None) -> Device:
        """
        Update requests use the JSON Patch syntax.
        The request must include a Content-Type header with the value application/json-patch+json.

        :param device_id: Unique identifier for the device.
        :type device_id: str
        :param op: 
        :type op: Op1
        :param path: Only the tags path is supported to patch.
        :type path: str
        :param value: Possible values: First Tag, Second Tag
        :type value: List[str]

        documentation: https://developer.webex.com/docs/api/v1/devices/modify-device-tags
        """
        body = ModifyDeviceTagsBody()
        if op is not None:
            body.op = op
        if path is not None:
            body.path = path
        if value is not None:
            body.value = value
        url = self.ep(f'{device_id}')
        data = super().patch(url=url, data=body.json())
        return Device.parse_obj(data)

    def create_activation_code(self, workspace_id: str) -> CreateDeviceActivationCodeResponse:
        """
        Generate an activation code for a device in a specific workspace by workspaceId.

        :param workspace_id: The ID of the workspace where the device will be activated.
        :type workspace_id: str

        documentation: https://developer.webex.com/docs/api/v1/devices/create-a-device-activation-code
        """
        body = CreateDeviceActivationCodeBody()
        if workspace_id is not None:
            body.workspace_id = workspace_id
        url = self.ep('activationCode')
        data = super().post(url=url, data=body.json())
        return CreateDeviceActivationCodeResponse.parse_obj(data)

class EventResourceEnum(str, Enum):
    #: State changed on a messages resource
    messages = 'messages'
    #: State changed on a memberships resource
    memberships = 'memberships'
    #: State change on a meeting ( here combined with type = 'ended' )
    meetings = 'meetings'
    #: State change on a automatic transcript resource for Webex Assistant
    meeting_transcripts = 'meetingTranscripts'
    #: State changed on a meeting message, i.e. message exchanged as part of a meeting
    meeting_messages = 'meetingMessages'
    #: State changed on a room tabs in a space
    tabs = 'tabs'
    #: State changed on a space classification
    rooms = 'rooms'
    #: State changed on a card attachment
    attachment_actions = 'attachmentActions'
    #: State changed on a file download
    files = 'files'
    #: State change on a file preview
    file_transcodings = 'file_transcodings'


class EventTypeEnum(str, Enum):
    #: The resource has been created
    created = 'created'
    #: A property on the resource has been updated
    updated = 'updated'
    #: The resource has been deleted
    deleted = 'deleted'
    #: The meeting has ended
    ended = 'ended'


class Data1(ApiModel):
    id: Optional[str]
    room_id: Optional[str]
    room_type: Optional[str]
    org_id: Optional[str]
    text: Optional[str]
    person_id: Optional[str]
    person_email: Optional[str]
    meeting_id: Optional[str]
    creator_id: Optional[str]
    #: The meeting's host data
    host: Optional[object]
    #: Common Identity (CI) authenticated meeting attendees
    attendees: Optional[list[]]
    #: indicates whether or not the Voice Assistant was enabled during the meeting. If true a transcript should be
    #: available a couple minutes after the meeting ended at the meetingTranscripts resource
    transcription_enabled: Optional[str]
    #: indicates if recording was enabled for all or parts of the meeting. If true a recording should be available
    #: shortly after the meeting ended at the recordings resource
    recording_enabled: Optional[str]
    #: indicates i chat messages were exchanged during the meeting in the meetings client (not the unified client). If
    #: true these messages can be accessed by a compliance officer at the postMeetingsChat resource. Meetings chat
    #: collection must be custom enabled.
    has_post_meetings_chat: Optional[str]
    created: Optional[str]


class Event(ApiModel):
    #: The unique identifier for the event.
    id: Optional[str]
    #: The type of resource in the event.
    resource: Optional[EventResourceEnum]
    #: The action which took place in the event.
    type: Optional[EventTypeEnum]
    #: The ID of the application for the event.
    app_id: Optional[str]
    #: The ID of the person who performed the action.
    actor_id: Optional[str]
    #: The ID of the organization for the event.
    org_id: Optional[str]
    #: The date and time of the event.
    created: Optional[str]
    #: The event's data representation. This object will contain the event's resource, such as memberships, messages,
    #: meetings, tabs, rooms or attachmentActions at the time the event took place.
    data: Optional[Data1]


class ListEventsResponse(ApiModel):
    items: Optional[list[Event]]


class EventsApi(ApiChild, base='events'):
    """
    Events are generated when actions take place within Webex, such as when someone creates or deletes a message.
    The Events API can only be used by a Compliance Officer with an API access token that contains the
    spark-compliance:events_read scope. See the Compliance Guide for more information.
    """

    def list_events(self, resource: str = None, type_: str = None, actor_id: str = None, from_: str = None, to_: str = None, **params) -> Generator[Event, None, None]:
        """
        List events in your organization. Several query parameters are available to filter the events returned in the
        response.
        Long result sets will be split into pages.

        :param resource: List events with a specific resource type. Possible values: messages, memberships, meetings,
            meetingMessages, meetingTranscripts, tabs, rooms, attachmentActions, files, file_transcodings
        :type resource: str
        :param type_: List events with a specific event type. Possible values: created, updated, deleted, ended
        :type type_: str
        :param actor_id: List events performed by this person, by person ID.
        :type actor_id: str
        :param from_: List events which occurred after a specific date and time.
        :type from_: str
        :param to_: List events which occurred before a specific date and time. If unspecified, or set to a time in the
            future, lists events up to the present.
        :type to_: str

        documentation: https://developer.webex.com/docs/api/v1/events/list-events
        """
        if resource is not None:
            params['resource'] = resource
        if type_ is not None:
            params['type'] = type_
        if actor_id is not None:
            params['actorId'] = actor_id
        if from_ is not None:
            params['from'] = from_
        if to_ is not None:
            params['to'] = to_
        url = self.ep()
        return self.session.follow_pagination(url=url, model=Event, params=params)

    def event_details(self, event_id: str) -> Event:
        """
        Shows details for an event, by event ID.
        Specify the event ID in the eventId parameter in the URI.

        :param event_id: The unique identifier for the event.
        :type event_id: str

        documentation: https://developer.webex.com/docs/api/v1/events/get-event-details
        """
        url = self.ep(f'{event_id}')
        data = super().get(url=url)
        return Event.parse_obj(data)

class Organization(ApiModel):
    #: A unique identifier for the organization.
    id: Optional[str]
    #: Full name of the organization.
    display_name: Optional[str]
    #: The date and time the organization was created.
    created: Optional[str]


class Operation(str, Enum):
    #: Remove member from group
    delete = 'delete'
    #: Add member into group
    add = 'add'


class PatchMemberWithOperation(ApiModel):
    #: Person ID.
    id: Optional[str]
    #: Operation type. The default operation is add if no operation is specified.
    operation: Optional[Operation]


class CreateGroupResponse(Organization):
    #: The ID of the organization to which this group belongs.
    org_id: Optional[str]
    #: The timestamp indicating lastModification time of group
    last_modified: Optional[str]
    member_size: Optional[int]
    #: An array of members
    members: Optional[list[Member]]


class CreateGroupBody(ApiModel):
    #: The name of the group.
    display_name: Optional[str]
    #: The ID of the organization to which this group belongs. If not specified, the organization ID from the OAuth
    #: token is used.
    org_id: Optional[str]
    #: Description of the group.
    description: Optional[str]
    #: An array of members. Maximum of 500 members can be provided. To add more members, use the Update a Group API to
    #: add additional members.
    #: Person ID.
    members: Optional[list[PostMember]]


class UpdateGroupBody(ApiModel):
    #: The name of the group.
    display_name: Optional[str]
    #: Description of the group.
    description: Optional[str]
    #: An array of members operations.
    members: Optional[list[PatchMemberWithOperation]]


class ListAndSearchGroupsResponse(ApiModel):
    #: Total number of groups returned in the response.
    total_results: Optional[int]
    start_index: Optional[int]
    items_per_page: Optional[int]
    #: An array of group objects.
    groups: Optional[list[CreateGroupResponse]]


class GroupsApi(ApiChild, base='groups'):
    """
    Groups contain a collection of members in Webex. A member represents a Webex user. A group is used to assign
    templates and settings to the set of members contained in a group. To create and manage a group, including adding
    and removing members from a group, an auth token containing the identity:groups_rw is required. Searching and
    viewing members of a group requires an auth token with a scope of identity:groups_read.
    To learn more about managing people to use as members in the /groups API please refer to the People API.
    """

    def create(self, display_name: str, org_id: str = None, description: str = None, members: List[PostMember] = None) -> CreateGroupResponse:
        """
        Create a new group for a given organization. The group may optionally be created with group members.

        :param display_name: The name of the group.
        :type display_name: str
        :param org_id: The ID of the organization to which this group belongs. If not specified, the organization ID
            from the OAuth token is used.
        :type org_id: str
        :param description: Description of the group.
        :type description: str
        :param members: An array of members. Maximum of 500 members can be provided. To add more members, use the
            Update a Group API to add additional members. Person ID.
        :type members: List[PostMember]

        documentation: https://developer.webex.com/docs/api/v1/groups/create-a-group
        """
        body = CreateGroupBody()
        if display_name is not None:
            body.display_name = display_name
        if org_id is not None:
            body.org_id = org_id
        if description is not None:
            body.description = description
        if members is not None:
            body.members = members
        url = self.ep()
        data = super().post(url=url, data=body.json())
        return CreateGroupResponse.parse_obj(data)

    def update(self, group_id: str, display_name: str = None, description: str = None, members: PatchMemberWithOperation = None) -> CreateGroupResponse:
        """
        Update the group details, by ID.
        Specify the group ID in the groupId parameter in the URI.

        :param group_id: A unique identifier for the group.
        :type group_id: str
        :param display_name: The name of the group.
        :type display_name: str
        :param description: Description of the group.
        :type description: str
        :param members: An array of members operations.
        :type members: PatchMemberWithOperation

        documentation: https://developer.webex.com/docs/api/v1/groups/update-a-group
        """
        body = UpdateGroupBody()
        if display_name is not None:
            body.display_name = display_name
        if description is not None:
            body.description = description
        if members is not None:
            body.members = members
        url = self.ep(f'{group_id}')
        data = super().patch(url=url, data=body.json())
        return CreateGroupResponse.parse_obj(data)

    def details(self, group_id: str, include_members: bool = None) -> CreateGroupResponse:
        """
        Get details for a group, by ID.
        Optionally, the members may be retrieved with this request. The maximum number of members returned is 500.

        :param group_id: A unique identifier for the group.
        :type group_id: str
        :param include_members: Include the members as part of the response.
        :type include_members: bool

        documentation: https://developer.webex.com/docs/api/v1/groups/get-group-details
        """
        params = {}
        if include_members is not None:
            params['includeMembers'] = str(include_members).lower()
        url = self.ep(f'{group_id}')
        data = super().get(url=url, params=params)
        return CreateGroupResponse.parse_obj(data)

    def list_and_search(self, org_id: str = None, filter: str = None, attributes: str = None, sort_by: str = None, sort_order: str = None, include_members: bool = None, start_index: int = None, count: int = None) -> ListAndSearchGroupsResponse:
        """
        List groups in your organization.

        :param org_id: List groups in this organization. Only admin users of another organization (such as partners)
            may use this parameter.
        :type org_id: str
        :param filter: Searches the group by displayName with an operator and a value. The available operators are eq
            (equal) and sw (starts with). Only displayName can be used to filter results.
        :type filter: str
        :param attributes: The attributes to return.
        :type attributes: str
        :param sort_by: Sort the results based by group displayName.
        :type sort_by: str
        :param sort_order: Sort results alphabetically by group display name, in ascending or descending order.
        :type sort_order: str
        :param include_members: Optionally return group members in the response. The maximum number of members returned
            is 500.
        :type include_members: bool
        :param start_index: The index to start for group pagination.
        :type start_index: int
        :param count: Specifies the desired number of search results per page.
        :type count: int

        documentation: https://developer.webex.com/docs/api/v1/groups/list-and-search-groups
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        if filter is not None:
            params['filter'] = filter
        if attributes is not None:
            params['attributes'] = attributes
        if sort_by is not None:
            params['sortBy'] = sort_by
        if sort_order is not None:
            params['sortOrder'] = sort_order
        if include_members is not None:
            params['includeMembers'] = str(include_members).lower()
        if start_index is not None:
            params['startIndex'] = start_index
        if count is not None:
            params['count'] = count
        url = self.ep()
        data = super().get(url=url, params=params)
        return ListAndSearchGroupsResponse.parse_obj(data)

    def members(self, group_id: str, start_index: int = None, count: int = None) -> CreateGroupResponse:
        """
        Gets the members of a group.

        :param group_id: A unique identifier for the group.
        :type group_id: str
        :param start_index: The index to start for group pagination.
        :type start_index: int
        :param count: Non-negative integer that specifies the desired number of search results per page. Maximum value
            for the count is 500.
        :type count: int

        documentation: https://developer.webex.com/docs/api/v1/groups/get-group-members
        """
        params = {}
        if start_index is not None:
            params['startIndex'] = start_index
        if count is not None:
            params['count'] = count
        url = self.ep(f'{group_id}/members')
        data = super().get(url=url, params=params)
        return CreateGroupResponse.parse_obj(data)

    def delete(self, group_id: str):
        """
        Remove a group from the system.
        Specify the group ID in the groupId parameter in the URI.

        :param group_id: A unique identifier for the group.
        :type group_id: str

        documentation: https://developer.webex.com/docs/api/v1/groups/delete-a-group
        """
        url = self.ep(f'{group_id}')
        super().delete(url=url)
        return

class Sharing(ApiModel):
    total_files_shared: Optional[str]
    file_share_size: Optional[str]


class Metrics(ApiModel):
    #: An Array containing the UTC dates for which the data is returned
    dates: Optional[str]
    #: An array containing the aggregated values for each day for which the data is returned
    daily_active_users: Optional[str]
    total_messages_sent: Optional[str]
    desk_top_messages_sent: Optional[str]
    mobile_messages_sent: Optional[str]
    total_active_spaces: Optional[str]
    group_active_spaces: Optional[str]
    one2one_active_spaces: Optional[str]
    video: Optional[str]
    sharing: Optional[Sharing]
    recording: Optional[str]
    audio: Optional[str]


class HistoricalDataRelatedToMessagingResponse(ApiModel):
    #: Data is returned starting from this UTC date
    start_date: Optional[str]
    #: Data is returned till this UTC date
    end_date: Optional[str]
    metrics: Optional[Metrics]


class HistoricalDataRelatedToMeetingsResponse(HistoricalDataRelatedToMessagingResponse):
    #: Site related to which the data is returned
    site_url: Optional[str]


class HistoricalAnalyticsApi(ApiChild, base=''):
    """
    Please be aware that the endpoint for these functions is analytics.webexapis.com, which also means that the
    ‘try-it’ mode won’t work. If you have any questions, or if you need help, please contact the Webex Developer
    Support team at devsupport@webex.com.
    This interface allows an IT Admin to pull analytics data from the data backend without having to interact with the
    UI or perform any manual steps.
    To access the API, the access token must represent an admin with either read-only-admin or full-admin roles for the
    given org. In addition, the access token must have the analytics:read_all scope
    By default, the calls to analytics.webexapis.com for historical data are sent to closest region servers. If the
    region servers host the organization's data, then the data is returned. Otherwise, a http 451 error code response
    will be returned. The body of the response in this case contains the end point information from where user can get
    historical data for the user's organization.
    Following is an example of how the error message looks like:
    { "message": "This server cannot serve the data for this organization. Please use {another region's VIP}",
    "errorCode": 451, "trackingId": {trackingId} }
    To use this API the org needs to be licensed for pro pack.
    """

    def historical_data_related_to_messaging(self, from_: str = None, to_: str = None) -> HistoricalDataRelatedToMessagingResponse:
        """
        Returns daily aggregates of various metrics related to Messaging

        :param from_: UTC Date starting from which the data needs to be returned
        :type from_: str
        :param to_: UTC Date till which the data needs to be returned
        :type to_: str

        documentation: https://developer.webex.com/docs/api/v1/historical-analytics/historical-data-related-to-messaging
        """
        params = {}
        if from_ is not None:
            params['from'] = from_
        if to_ is not None:
            params['to'] = to_
        url = self.ep('https://analytics.webexapis.com/v1/analytics/messagingMetrics/dailyTotals')
        data = super().get(url=url, params=params)
        return HistoricalDataRelatedToMessagingResponse.parse_obj(data)

    def historical_data_related_to_room_devices(self, from_: str = None, to_: str = None) -> HistoricalDataRelatedToMessagingResponse:
        """
        Returns daily aggregates of various metrics related to Room Devices

        :param from_: UTC Date starting from which the data needs to be returned
        :type from_: str
        :param to_: UTC Date till which the data needs to be returned
        :type to_: str

        documentation: https://developer.webex.com/docs/api/v1/historical-analytics/historical-data-related-to-room-devices
        """
        params = {}
        if from_ is not None:
            params['from'] = from_
        if to_ is not None:
            params['to'] = to_
        url = self.ep('https://analytics.webexapis.com/v1/analytics/roomDeviceMetrics/dailyTotals')
        data = super().get(url=url, params=params)
        return HistoricalDataRelatedToMessagingResponse.parse_obj(data)

    def historical_data_related_to_meetings(self, site_url: str, from_: str = None, to_: str = None) -> HistoricalDataRelatedToMeetingsResponse:
        """
        Return aggregates of various metrics, related to meetings, for the siteUrl and over the time range specified by
        the user

        :param site_url: Site related to which the data is expected. This parameter is required
        :type site_url: str
        :param from_: UTC Date starting from which the data needs to be returned
        :type from_: str
        :param to_: UTC Date till which the data needs to be returned
        :type to_: str

        documentation: https://developer.webex.com/docs/api/v1/historical-analytics/historical-data-related-to-meetings
        """
        params = {}
        params['siteUrl'] = site_url
        if from_ is not None:
            params['from'] = from_
        if to_ is not None:
            params['to'] = to_
        url = self.ep('https://analytics.webexapis.com/v1/analytics/meetingsMetrics/aggregates')
        data = super().get(url=url, params=params)
        return HistoricalDataRelatedToMeetingsResponse.parse_obj(data)

class Role(ApiModel):
    #: A unique identifier for the role.
    id: Optional[str]
    #: The name of the role.
    name: Optional[str]


class Cluster(Role):
    #: The ID of the organization to which this hybrid cluster belongs.
    org_id: Optional[str]
    #: The ID of the resource group this cluster belongs to.
    resource_group_id: Optional[str]


class ListHybridClustersResponse(ApiModel):
    #: An array of hybrid cluster objects.
    items: Optional[list[Cluster]]


class HybridClustersApi(ApiChild, base='hybrid/clusters'):
    """
    Hybrid Clusters are groups of hosts, and the connectors these hosts contain, that are managed as a unit. All the
    connectors of a single type in a cluster share the same configuration.
    Listing and viewing Hybrid Clusters requires an administrator auth token with the spark-admin:hybrid_clusters_read
    scope.
    Hybrid Clusters are associated with Resource Groups. See the Resource Groups API for more information.
    """

    def list_clusters(self, org_id: str = None) -> list[Cluster]:
        """
        List hybrid clusters for an organization. If no orgId is specified, the default is the organization of the
        authenticated user.
        Only an admin auth token with the spark-admin:hybrid_clusters_read scope can list clusters.

        :param org_id: List hybrid clusters in this organization. If an organization is not specified, the organization
            of the caller will be used.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/hybrid-clusters/list-hybrid-clusters
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep()
        data = super().get(url=url, params=params)
        return parse_obj_as(list[Cluster], data["items"])

    def cluster_details(self, hybrid_cluster_id: str, org_id: str = None) -> Cluster:
        """
        Shows details for a hybrid cluster, by ID.
        Only an admin auth token with the spark-admin:hybrid_clusters_read scope can see cluster details.

        :param hybrid_cluster_id: The ID of the cluster.
        :type hybrid_cluster_id: str
        :param org_id: Find the cluster in this specific organization. If this is not specified, the organization of
            the caller will be used.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/hybrid-clusters/get-hybrid-cluster-details
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'{hybrid_cluster_id}')
        data = super().get(url=url, params=params)
        return Cluster.parse_obj(data)

class ConnectorStatus(ApiModel):
    operational: Optional[str]
    impaired: Optional[str]
    outage: Optional[str]
    maintenance_mode: Optional[str]


class ConnectorType(ApiModel):
    expressway_management: Optional[str]
    calendar: Optional[str]
    call: Optional[str]
    message: Optional[str]
    expressway_serviceability: Optional[str]
    ecp_serviceability: Optional[str]
    video_mesh: Optional[str]
    data_security: Optional[str]
    care: Optional[str]
    care_management: Optional[str]


class AlarmSeverity(ApiModel):
    critical: Optional[str]
    warning: Optional[str]
    alert: Optional[str]
    error: Optional[str]


class Alarm(ApiModel):
    #: A unique identifier for the alarm.
    id: Optional[str]
    #: The date and time the alarm was raised.
    created: Optional[str]
    #: The severity level of the alarm:
    #:   * critical
    #:   * error
    #:   * warning
    #:   * alert
    severity: Optional[AlarmSeverity]
    #: The title of the alarm.
    title: Optional[str]
    #: A description of the alarm.
    description: Optional[str]
    #: The ID of the connector the alarm is raised on.
    hybrid_connector_id: Optional[str]


class Connector(ApiModel):
    #: A unique identifier for the connector.
    id: Optional[str]
    #: The ID of the organization to which this hybrid connector belongs.
    org_id: Optional[str]
    #: The ID of the cluster this connector belongs to.
    hybrid_cluster_id: Optional[str]
    #: The hostname of the system the connector is running on.
    hostname: Optional[str]
    #: The status of the connector:
    #:   * operational indicates that the connector is working as it should.
    #:   * impaired indicates that the connector has problems with one or more dependent components.
    #:   * outage indicates that the connector is completely non-functional.
    #:   * maintenanceMode reports the current maintenance mode state of the connector.
    status: Optional[ConnectorStatus]
    #: The date and time the connector was created.
    created: Optional[str]
    #: The type of connector.
    type: Optional[ConnectorType]
    #: The version of the software installed.
    version: Optional[str]
    #: A list of alarms raised on the connector.
    alarms: Optional[list[Alarm]]


class ListHybridConnectorsResponse(ApiModel):
    #: An array of hybrid connector objects.
    items: Optional[list[Connector]]


class HybridConnectorsApi(ApiChild, base='hybrid/connectors'):
    """
    Hybrid Connectors are pieces of software that run on-premise and provide a link between the Webex Cloud and
    on-premise resources.
    For example, the Calendar Connector enables the linking of information from an on-premise Exchange server with the
    Webex Cloud. It allows, among other things, for the cloud to set up a Webex meeting when a user specifies @webex as
    the Location of a meeting in Outlook.
    Listing and viewing Hybrid Connectors requires an administrator auth token with the
    spark-admin:hybrid_connectors_read scope.
    Use this API to list the connectors configured in an organization and to determine if any connectors have any
    unresolved alarms associated with them.
    """

    def list_connectors(self, org_id: str = None) -> list[Connector]:
        """
        List hybrid connectors for an organization. If no orgId is specified, the default is the organization of the
        authenticated user.
        Only an admin auth token with the spark-admin:hybrid_connectors_read scope can list connectors.

        :param org_id: List hybrid connectors in this organization. If an organization is not specified, the
            organization of the caller will be used.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/hybrid-connectors/list-hybrid-connectors
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep()
        data = super().get(url=url, params=params)
        return parse_obj_as(list[Connector], data["items"])

    def connector_details(self, connector_id: str) -> Connector:
        """
        Shows details for a hybrid connector, by ID.
        Only an admin auth token with the spark-admin:hybrid_connectors_read scope can see connector details.

        :param connector_id: The ID of the connector.
        :type connector_id: str

        documentation: https://developer.webex.com/docs/api/v1/hybrid-connectors/get-hybrid-connector-details
        """
        url = self.ep(f'{connector_id}')
        data = super().get(url=url)
        return Connector.parse_obj(data)

class SiteType(str, Enum):
    #: The site is managed by Webex Control Hub.
    control_hub_managed_site = 'Control Hub managed site'
    #: The site is a linked site.
    linked_site = 'Linked site'
    #: The site is managed by Site Administration.
    site_admin_managed_site = 'Site Admin managed site'


class License(Role):
    #: Total number of license units allocated.
    total_units: Optional[int]
    #: Total number of license units consumed.
    consumed_units: Optional[int]
    #: The subscription ID associated with this license. This ID is used in other systems, such as Webex Control Hub.
    subscription_id: Optional[str]
    #: The Webex Meetings site associated with this license.
    site_url: Optional[str]
    #: The type of site associated with this license.
    site_type: Optional[SiteType]


class ListLicensesResponse(ApiModel):
    items: Optional[list[License]]


class LicensesApi(ApiChild, base='licenses'):
    """
    An allowance for features and services that are provided to users on a Webex services subscription. Cisco and its
    partners manage the amount of licenses provided to administrators and users. This license resource can be accessed
    only by an admin.
    To learn about how to allocate Hybrid Services licenses, see the Managing Hybrid Services guide.
    """

    def list_licenses(self, org_id: str = None) -> list[License]:
        """
        List all licenses for a given organization. If no orgId is specified, the default is the organization of the
        authenticated user.
        Response properties that are not applicable to the license will not be present in the response.

        :param org_id: List licenses for this organization.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/licenses/list-licenses
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep()
        data = super().get(url=url, params=params)
        return parse_obj_as(list[License], data["items"])

    def license_details(self, license_id: str) -> License:
        """
        Shows details for a license, by ID.
        Specify the license ID in the licenseId parameter in the URI.
        Response properties that are not applicable to the license will not be present in the response.

        :param license_id: The unique identifier for the license.
        :type license_id: str

        documentation: https://developer.webex.com/docs/api/v1/licenses/get-license-details
        """
        url = self.ep(f'{license_id}')
        data = super().get(url=url)
        return License.parse_obj(data)

class Address(ApiModel):
    #: Address 1
    address1: Optional[str]
    #: Address 2
    address2: Optional[str]
    #: City
    city: Optional[str]
    #: State code
    state: Optional[str]
    #: ZIP/Postal Code
    postal_code: Optional[str]
    #: ISO-3166 2-Letter Country Code.
    country: Optional[str]


class Location(Role):
    #: The ID of the organization to which this location belongs.
    org_id: Optional[str]
    #: Time zone associated with this location.
    time_zone: Optional[str]
    #: The address of the location.
    address: Optional[Address]


class UpdateLocationBody(ApiModel):
    #: The name of the location.
    name: Optional[str]
    #: Time zone associated with this location, refer to this link
    #: (https://developer.webex.com/docs/api/guides/webex-for-broadworks-developers-guide#webex-meetings-site-timezone)
    #: for format.
    time_zone: Optional[str]
    #: Default email language.
    preferred_language: Optional[str]
    #: The address of the location.
    address: Optional[Address]


class CreateLocationFloorBody(ApiModel):
    #: The floor number.
    floor_number: Optional[int]
    #: The floor display name.
    display_name: Optional[str]


class Floor(CreateLocationFloorBody):
    #: Unique identifier for the floor.
    id: Optional[str]
    #: Unique identifier for the location.
    location_id: Optional[str]


class ListLocationsResponse(ApiModel):
    items: Optional[list[Location]]


class CreateLocationBody(UpdateLocationBody):
    #: Location's phone announcement language.
    announcement_language: Optional[str]


class CreateLocationResponse(ApiModel):
    #: ID of the newly created location.
    id: Optional[str]


class ListLocationFloorsResponse(ApiModel):
    #: An array of floor objects.
    items: Optional[list[Floor]]


class LocationsApi(ApiChild, base='locations'):
    """
    Locations allow you to organize users and workspaces based on a physical location. You can configure both calling
    and workspace management functions into the same location. To enable a location for Webex Calling, use the Enable a
    Location for Webex Calling API.
    You can also create and inspect locations in Webex Control Hub. See Locations on Control Hub for more information.
    """

    def list(self, name: str = None, id: str = None, org_id: str = None, **params) -> Generator[Location, None, None]:
        """
        List locations for an organization.

        :param name: List locations whose name contains this string (case-insensitive).
        :type name: str
        :param id: List locations by ID.
        :type id: str
        :param org_id: List locations in this organization. Only admin users of another organization (such as partners)
            may use this parameter.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/locations/list-locations
        """
        if name is not None:
            params['name'] = name
        if id is not None:
            params['id'] = id
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep()
        return self.session.follow_pagination(url=url, model=Location, params=params)

    def details(self, location_id: str, org_id: str = None) -> Location:
        """
        Shows details for a location, by ID.

        :param location_id: A unique identifier for the location.
        :type location_id: str
        :param org_id: Get location common attributes for this organization.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/locations/get-location-details
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'{location_id}')
        data = super().get(url=url, params=params)
        return Location.parse_obj(data)

    def create(self, announcement_language: str, org_id: str = None, name: str = None, time_zone: str = None, preferred_language: str = None, address: Address = None) -> str:
        """
        Create a new Location for a given organization. Only an admin in the organization can create a new Location.

        :param announcement_language: Location's phone announcement language.
        :type announcement_language: str
        :param org_id: Create a location common attribute for this organization.
        :type org_id: str
        :param name: The name of the location.
        :type name: str
        :param time_zone: Time zone associated with this location, refer to this link
            (https://developer.webex.com/docs/api/guides/webex-for-broadworks-developers-guide#webex-meetings-site-timezone)
            for format.
        :type time_zone: str
        :param preferred_language: Default email language.
        :type preferred_language: str
        :param address: The address of the location.
        :type address: Address

        documentation: https://developer.webex.com/docs/api/v1/locations/create-a-location
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = CreateLocationBody()
        if announcement_language is not None:
            body.announcement_language = announcement_language
        if name is not None:
            body.name = name
        if time_zone is not None:
            body.time_zone = time_zone
        if preferred_language is not None:
            body.preferred_language = preferred_language
        if address is not None:
            body.address = address
        url = self.ep()
        data = super().post(url=url, params=params, data=body.json())
        return data["id"]

    def update(self, location_id: str, org_id: str = None, name: str = None, time_zone: str = None, preferred_language: str = None, address: Address = None):
        """
        Update details for a location, by ID.

        :param location_id: Update location common attributes for this location.
        :type location_id: str
        :param org_id: Update location common attributes for this organization.
        :type org_id: str
        :param name: The name of the location.
        :type name: str
        :param time_zone: Time zone associated with this location, refer to this link
            (https://developer.webex.com/docs/api/guides/webex-for-broadworks-developers-guide#webex-meetings-site-timezone)
            for format.
        :type time_zone: str
        :param preferred_language: Default email language.
        :type preferred_language: str
        :param address: The address of the location.
        :type address: Address

        documentation: https://developer.webex.com/docs/api/v1/locations/update-a-location
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = UpdateLocationBody()
        if name is not None:
            body.name = name
        if time_zone is not None:
            body.time_zone = time_zone
        if preferred_language is not None:
            body.preferred_language = preferred_language
        if address is not None:
            body.address = address
        url = self.ep(f'{location_id}')
        super().put(url=url, params=params, data=body.json())
        return

    def list_floors(self, location_id: str) -> list[Floor]:
        """
        List location floors.
        Requires an administrator auth token with the spark-admin:locations_read scope.

        :param location_id: A unique identifier for the location.
        :type location_id: str

        documentation: https://developer.webex.com/docs/api/v1/locations/list-location-floors
        """
        url = self.ep(f'{location_id}/floors')
        data = super().get(url=url)
        return parse_obj_as(list[Floor], data["items"])

    def create_floor(self, location_id: str, floor_number: int, display_name: str = None) -> Floor:
        """
        Create a new floor in the given location. The displayName parameter is optional, and omitting it will result in
        the creation of a floor without that value set.
        Requires an administrator auth token with the spark-admin:locations_write scope.

        :param location_id: A unique identifier for the location.
        :type location_id: str
        :param floor_number: The floor number.
        :type floor_number: int
        :param display_name: The floor display name.
        :type display_name: str

        documentation: https://developer.webex.com/docs/api/v1/locations/create-a-location-floor
        """
        body = CreateLocationFloorBody()
        if floor_number is not None:
            body.floor_number = floor_number
        if display_name is not None:
            body.display_name = display_name
        url = self.ep(f'{location_id}/floors')
        data = super().post(url=url, data=body.json())
        return Floor.parse_obj(data)

    def floor_details(self, location_id: str, floor_id: str) -> Floor:
        """
        Shows details for a floor, by ID. Specify the floor ID in the floorId parameter in the URI.
        Requires an administrator auth token with the spark-admin:locations_read scope.

        :param location_id: A unique identifier for the location.
        :type location_id: str
        :param floor_id: A unique identifier for the floor.
        :type floor_id: str

        documentation: https://developer.webex.com/docs/api/v1/locations/get-location-floor-details
        """
        url = self.ep(f'{location_id}/floors/{floor_id}')
        data = super().get(url=url)
        return Floor.parse_obj(data)

    def update_floor(self, location_id: str, floor_id: str, floor_number: int, display_name: str = None) -> Floor:
        """
        Updates details for a floor, by ID. Specify the floor ID in the floorId parameter in the URI. Include all
        details for the floor returned by a previous call to Get Location Floor Details. Omitting the optional
        displayName field will result in that field no longer being defined for the floor.
        Requires an administrator auth token with the spark-admin:locations_write scope.

        :param location_id: A unique identifier for the location.
        :type location_id: str
        :param floor_id: A unique identifier for the floor.
        :type floor_id: str
        :param floor_number: The floor number.
        :type floor_number: int
        :param display_name: The floor display name.
        :type display_name: str

        documentation: https://developer.webex.com/docs/api/v1/locations/update-a-location-floor
        """
        body = CreateLocationFloorBody()
        if floor_number is not None:
            body.floor_number = floor_number
        if display_name is not None:
            body.display_name = display_name
        url = self.ep(f'{location_id}/floors/{floor_id}')
        data = super().put(url=url, data=body.json())
        return Floor.parse_obj(data)

    def delete_floor(self, location_id: str, floor_id: str):
        """
        Deletes a floor, by ID.
        Requires an administrator auth token with the spark-admin:locations_write scope.

        :param location_id: A unique identifier for the location.
        :type location_id: str
        :param floor_id: A unique identifier for the floor.
        :type floor_id: str

        documentation: https://developer.webex.com/docs/api/v1/locations/delete-a-location-floor
        """
        url = self.ep(f'{location_id}/floors/{floor_id}')
        super().delete(url=url)
        return

class CoHosts(ApiModel):
    #: Email address for cohost. This attribute can be modified with the Update Personal Meeting Room Options API.
    #: Possible values: john.andersen@example.com
    email: Optional[str]
    #: Display name for cohost. This attribute can be modified with the Update Personal Meeting Room Options API.
    #: Possible values: John Andersen
    display_name: Optional[str]


class Sender(CoHosts):
    #: A unique identifier for the sender.
    person_id: Optional[str]
    #: The ID of the organization to which the sender belongs.
    org_id: Optional[str]


class ChatObject(ApiModel):
    #: A unique identifier for the chat snippet.
    id: Optional[str]
    #: Chat time for the chat snippet in ISO 8601 compliant format.
    chat_time: Optional[str]
    #: The text of the chat snippet.
    text: Optional[str]
    #: A unique identifier for the meeting instance to which the chat belongs.
    meeting_id: Optional[str]
    #: Whether the type of the chat is private, public or group. Private chat is for the 1:1 chat. Public chat is for
    #: the message which is sent to all the people in the meeting. Group chat is for the message which is sent to a
    #: small group of people, like a message to "host and presenter".
    type: Optional[str]
    #: Information of the sender of the chat snippet.
    sender: Optional[Sender]
    #: Information of the receivers of the chat snippet.
    receivers: Optional[list[Sender]]


class ListMeetingChatsResponse(ApiModel):
    #: Chat array
    items: Optional[list[ChatObject]]


class MeetingChatsApi(ApiChild, base='meetings/postMeetingChats'):
    """
    Chats are content captured in a meeting when chat messages are sent between the participants within a meeting. This
    feature allows a Compliance Officer to access the in-meeting chat content.
    The Compliance Officer can use the Meeting Chats API to retrieve the chats of a meeting and to delete all chats
    associated with a meeting. private chats are text messages between two people. group chats are for larger breakout
    spaces. Meeting chats are different from room messages in that there is no catch-up propagation. For example, if a
    user joins a meeting late only, chat messages that are created from then on, will be propagated to this user. To
    understand which user saw which message if they joined late, you have to query the meetingParticipants REST
    resource for the joined/left times and compare to the meetingsChat chatTime field.
    The Webex meetings chat functionality and API endpoint described here is "upon-request" and not enabled by default.
    If you need it enabled for your org, or if you need help, please contact the Webex Developer Support team at
    devsupport@webex.com.
    """

    def list_chats(self, meeting_id: str, offset: int = None, **params) -> Generator[ChatObject, None, None]:
        """
        Lists the meeting chats of a finished meeting instance specified by meetingId. You can set a maximum number of
        chats to return.
        Use this operation to list the chats of a finished meeting instance when they are ready. Please note that only
        meeting instances in state ended are supported for meetingId. Meeting series, scheduled meetings and
        in-progress meeting instances are not supported.

        :param meeting_id: A unique identifier for the meeting instance to which the chats belong. The meeting ID of a
            scheduled personal room meeting is not supported.
        :type meeting_id: str
        :param offset: Offset from the first result that you want to fetch.
        :type offset: int

        documentation: https://developer.webex.com/docs/api/v1/meeting-chats/list-meeting-chats
        """
        params['meetingId'] = meeting_id
        if offset is not None:
            params['offset'] = offset
        url = self.ep()
        return self.session.follow_pagination(url=url, model=ChatObject, params=params)

    def delete_chats(self, meeting_id: str):
        """
        Deletes the meeting chats of a finished meeting instance specified by meetingId.
        Use this operation to delete the chats of a finished meeting instance when they are ready. Please note that
        only meeting instances in state ended are supported for meetingId. Meeting series, scheduled meetings and
        in-progress meeting instances are not supported.

        :param meeting_id: A unique identifier for the meeting instance to which the chats belong. Meeting IDs of a
            scheduled personal room meeting are not supported.
        :type meeting_id: str

        documentation: https://developer.webex.com/docs/api/v1/meeting-chats/delete-meeting-chats
        """
        params = {}
        params['meetingId'] = meeting_id
        url = self.ep()
        super().delete(url=url, params=params)
        return

class ClosedCaptionObject(ApiModel):
    #: A unique identifier for the closed caption.
    id: Optional[str]
    #: Unique identifier for the meeting instance which the closed captions belong to.
    meeting_id: Optional[str]
    #: The download link for the closed caption vtt file.
    vtt_download_link: Optional[str]
    #: The download link for the closed caption txt file.
    txt_download_link: Optional[str]
    #: Start time for the meeting closed caption in ISO 8601 compliant format.
    start: Optional[str]


class SnippetObject1(ApiModel):
    #: A unique identifier for the snippet.
    id: Optional[str]
    #: Text for the snippet.
    text: Optional[str]
    #: Name of the person generating the speech for the snippet.
    person_name: Optional[str]
    #: Email address of the person generating the speech for the snippet.
    person_email: Optional[str]
    #: Offset from the beginning of the parent transcript in milliseconds indicating the start time of the snippet.
    offset_millisecond: Optional[int]
    #: Duration of the snippet in milliseconds.
    duration_millisecond: Optional[int]


class SnippetObject(SnippetObject1):
    #: Unique identifier for the meeting instance which the closed captions belong to.
    meeting_id: Optional[str]
    #: The unique identifier for the person speaking.
    people_id: Optional[str]
    #: Start time for the snippet.
    start: Optional[str]
    #: Original language of the snippet.
    language: Optional[str]


class ListMeetingClosedCaptionsResponse(ApiModel):
    #: Closed caption array
    items: Optional[list[ClosedCaptionObject]]


class ListMeetingClosedCaptionSnippetsResponse(ApiModel):
    #: Closed caption snippet array
    items: Optional[list[SnippetObject]]


class MeetingClosedCaptionsApi(ApiChild, base='meetingClosedCaptions'):
    """
    Meeting Closed Captions APIs are enabled upon request, and are not available by default. Please contact the Webex
    Developer Support team at devsupport@webex.com if you would like to enable this feature for your organization.
    Meeting closed captions are the automatic transcriptions of what is being said during a meeting in real-time.
    Closed captions appear after being enabled during a meeting and can be translated to a participant's language.
    A closed caption snippet is a short text snippet from a meeting closed caption which was spoken by a particular
    participant in the meeting. A meeting's closed captions consists of many snippets.
    The Closed Captions API manages meeting closed captions and snippets. You can list meeting closed captions, as well
    as list and download snippets. Closed captions can be retrieved in either Web Video Text Tracks (VTT) or plain text
    (TXT) format via the download links provided by the vttDownloadLink and txtDownloadlink response properties,
    respectively.
    Refer to the Meetings API Scopes section of Meetings Overview guide for the scopes required for each API.
    Notes:
    Currently, closed caption APIs are only supported for the Compliance Officer role.
    Closed captions will be available 15 minutes after the meeting is finished.
    """

    def list_closed_captions(self, meeting_id: str) -> list[ClosedCaptionObject]:
        """
        Lists closed captions of a finished meeting instance specified by meetingId.

        :param meeting_id: Unique identifier for the meeting instance which the closed captions belong to. This
            parameter only applies to ended meeting instnaces. It does not apply to meeting series, scheduled meetings
            or scheduled personal room meetings.
        :type meeting_id: str

        documentation: https://developer.webex.com/docs/api/v1/meeting-closed-captions/list-meeting-closed-captions
        """
        params = {}
        params['meetingId'] = meeting_id
        url = self.ep()
        data = super().get(url=url, params=params)
        return parse_obj_as(list[ClosedCaptionObject], data["items"])

    def list_closed_caption_snippets(self, closed_caption_id: str, meeting_id: str) -> list[SnippetObject]:
        """
        Lists snippets of a meeting closed caption specified by closedCaptionId.

        :param closed_caption_id: Unique identifier for the meeting closed caption which the snippets belong to.
        :type closed_caption_id: str
        :param meeting_id: Unique identifier for the meeting instance which the closed caption snippets belong to. This
            parameter only applies to ended meeting instances. It does not apply to meeting series, scheduled meetings
            or scheduled personal room meetings.
        :type meeting_id: str

        documentation: https://developer.webex.com/docs/api/v1/meeting-closed-captions/list-meeting-closed-caption-snippets
        """
        params = {}
        params['meetingId'] = meeting_id
        url = self.ep(f'{closed_caption_id}/snippets')
        data = super().get(url=url, params=params)
        return parse_obj_as(list[SnippetObject], data["items"])

    def download_closed_caption_snippets(self, closed_caption_id: str, meeting_id: str, format: str = None):
        """
        Download meeting closed caption snippets from the meeting closed caption specified by closedCaptionId formatted
        either as a Video Text Track (.vtt) file or plain text (.txt) file.

        :param closed_caption_id: Unique identifier for the meeting closed caption.
        :type closed_caption_id: str
        :param meeting_id: Unique identifier for the meeting instance which the closed caption snippets belong to. This
            parameter only applies to meeting instances in the ended state. It does not apply to meeting series,
            scheduled meetings or scheduled personal room meetings.
        :type meeting_id: str
        :param format: Format for the downloaded meeting closed caption snippets. Possible values: vtt, txt
        :type format: str

        documentation: https://developer.webex.com/docs/api/v1/meeting-closed-captions/download-meeting-closed-caption-snippets
        """
        params = {}
        params['meetingId'] = meeting_id
        if format is not None:
            params['format'] = format
        url = self.ep(f'{closed_caption_id}/download')
        super().get(url=url, params=params)
        return $!$!$!   # this is weird. Check the spec at https://developer.webex.com/docs/api/v1/meeting-closed-captions/download-meeting-closed-caption-snippets

class GetInviteeObject(CoHosts):
    #: Unique identifier for meeting invitee.
    id: Optional[str]
    #: Whether or not invitee is a designated alternate host for the meeting. See Add Alternate Hosts for Cisco Webex
    #: Meetings for more details.
    co_host: Optional[bool]
    #: Unique identifier for the meeting for which invitees are being requested. The meeting can be a meeting series, a
    #: scheduled meeting, or a meeting instance which has ended or is ongoing.
    meeting_id: Optional[str]
    #: If true, the invitee is a designated panelist for the event meeting.
    panelist: Optional[bool]


class CreateInviteesItemObject(CoHosts):
    #: Whether or not invitee is a designated alternate host for the meeting. See Add Alternate Hosts for Cisco Webex
    #: Meetings for more details.
    co_host: Optional[bool]
    #: If true, send an email to the invitee.
    send_email: Optional[bool]
    #: If true, the invitee is a designated panelist for the event meeting.
    panelist: Optional[bool]


class ListMeetingInviteesResponse(ApiModel):
    #: Array of meeting invitees.
    items: Optional[list[GetInviteeObject]]


class CreateMeetingInviteeBody(CoHosts):
    #: Unique identifier for the meeting to which a person is being invited. This attribute only applies to meeting
    #: series and scheduled meeting. If it's a meeting series, the meeting invitee is invited to the entire meeting
    #: series; if it's a scheduled meeting, the meeting invitee is invited to this individual scheduled meeting. It
    #: doesn't apply to an ended or ongoing meeting instance. The meeting ID of a scheduled personal room meeting is
    #: not supported for this API.
    meeting_id: Optional[str]
    #: Whether or not the invitee is a designated alternate host for the meeting. See Add Alternate Hosts for Cisco
    #: Webex Meetings for more details.
    co_host: Optional[bool]
    #: Email address for the meeting host. This attribute should only be set if the user or application calling the API
    #: has the admin on-behalf-of scopes. When used, the admin may specify the email of a user in a site they manage to
    #: be the meeting host.
    host_email: Optional[str]
    #: If true, send an email to the invitee.
    send_email: Optional[bool]
    #: If true, the invitee is a designated panelist for the event meeting.
    panelist: Optional[bool]


class CreateMeetingInviteesBody(ApiModel):
    #: Unique identifier for the meeting to which the people are being invited. This attribute only applies to meeting
    #: series and scheduled meetings. If it's a meeting series, the meeting invitees are invited to the entire meeting
    #: series; if it's a scheduled meeting, the meeting invitees are invited to this individual scheduled meeting. It
    #: doesn't apply to an ended or ongoing meeting instance. The meeting ID of a scheduled personal room meeting is
    #: not supported for this API.
    meeting_id: Optional[str]
    #: Email address for the meeting host. This attribute should only be set if the user or application calling the API
    #: has the admin on-behalf-of scopes. When used, the admin may specify the email of a user in a site they manage to
    #: be the meeting host.
    host_email: Optional[str]
    #: Meeting invitees to be inserted.
    items: Optional[list[CreateInviteesItemObject]]


class CreateMeetingInviteesResponse(ApiModel):
    #: Meeting invitees inserted.
    items: Optional[list[GetInviteeObject]]


class UpdateMeetingInviteeBody(CreateInviteesItemObject):
    #: Email address for the meeting host. This attribute should only be set if the user or application calling the API
    #: has the admin on-behalf-of scopes. When used, the admin may specify the email of a user in a site they manage to
    #: be the meeting host.
    host_email: Optional[str]


class MeetingInviteesApi(ApiChild, base='meetingInvitees'):
    """
    This API manages invitees' relationships to a meeting.
    You can use the Meeting Invitees API to list, create, update, and delete invitees.
    Refer to the Meetings API Scopes section of Meetings Overview for scopes required for each API.
    """

    def list_invitees(self, meeting_id: str, host_email: str = None, panelist: str = None, **params) -> Generator[GetInviteeObject, None, None]:
        """
        Lists meeting invitees for a meeting with a specified meetingId. You can set a maximum number of invitees to
        return.
        This operation can be used for meeting series, scheduled meetings, and ended or ongoing meeting instance
        objects. If the specified meetingId is for a meeting series, the invitees for the series will be listed; if the
        meetingId is for a scheduled meeting, the invitees for the particular scheduled meeting will be listed; if the
        meetingId is for an ended or ongoing meeting instance, the invitees for the particular meeting instance will be
        listed. See the Webex Meetings guide for more information about the types of meetings.
        The list returned is sorted in ascending order by email address.
        Long result sets are split into pages.

        :param meeting_id: Unique identifier for the meeting for which invitees are being requested. The meeting can be
            a meeting series, a scheduled meeting, or a meeting instance which has ended or is ongoing. The meeting ID
            of a scheduled personal room meeting is not supported for this API.
        :type meeting_id: str
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin on-behalf-of scopes. If set, the admin may specify the email of a user in a
            site they manage and the API will return meeting invitees that are hosted by that user.
        :type host_email: str
        :param panelist: Filter invitees or attendees for webinars only. If true, returns invitees. If false, returns
            attendees. If null, returns both invitees and attendees.
        :type panelist: str

        documentation: https://developer.webex.com/docs/api/v1/meeting-invitees/list-meeting-invitees
        """
        params['meetingId'] = meeting_id
        if host_email is not None:
            params['hostEmail'] = host_email
        if panelist is not None:
            params['panelist'] = panelist
        url = self.ep()
        return self.session.follow_pagination(url=url, model=GetInviteeObject, params=params)

    def create_invitee(self, meeting_id: str, email: str = None, display_name: str = None, co_host: bool = None, host_email: str = None, send_email: bool = None, panelist: bool = None) -> GetInviteeObject:
        """
        Invite a person to attend a meeting.
        Identify the invitee in the request body, by email address.

        :param meeting_id: Unique identifier for the meeting to which a person is being invited. This attribute only
            applies to meeting series and scheduled meeting. If it's a meeting series, the meeting invitee is invited
            to the entire meeting series; if it's a scheduled meeting, the meeting invitee is invited to this
            individual scheduled meeting. It doesn't apply to an ended or ongoing meeting instance. The meeting ID of a
            scheduled personal room meeting is not supported for this API.
        :type meeting_id: str
        :param email: Email address for cohost. This attribute can be modified with the Update Personal Meeting Room
            Options API. Possible values: john.andersen@example.com
        :type email: str
        :param display_name: Display name for cohost. This attribute can be modified with the Update Personal Meeting
            Room Options API. Possible values: John Andersen
        :type display_name: str
        :param co_host: Whether or not the invitee is a designated alternate host for the meeting. See Add Alternate
            Hosts for Cisco Webex Meetings for more details.
        :type co_host: bool
        :param host_email: Email address for the meeting host. This attribute should only be set if the user or
            application calling the API has the admin on-behalf-of scopes. When used, the admin may specify the email
            of a user in a site they manage to be the meeting host.
        :type host_email: str
        :param send_email: If true, send an email to the invitee.
        :type send_email: bool
        :param panelist: If true, the invitee is a designated panelist for the event meeting.
        :type panelist: bool

        documentation: https://developer.webex.com/docs/api/v1/meeting-invitees/create-a-meeting-invitee
        """
        body = CreateMeetingInviteeBody()
        if meeting_id is not None:
            body.meeting_id = meeting_id
        if email is not None:
            body.email = email
        if display_name is not None:
            body.display_name = display_name
        if co_host is not None:
            body.co_host = co_host
        if host_email is not None:
            body.host_email = host_email
        if send_email is not None:
            body.send_email = send_email
        if panelist is not None:
            body.panelist = panelist
        url = self.ep()
        data = super().post(url=url, data=body.json())
        return GetInviteeObject.parse_obj(data)

    def create_invitees(self, meeting_id: str, host_email: str = None, items: CreateInviteesItemObject = None) -> list[GetInviteeObject]:
        """
        Invite people to attend a meeting in bulk.
        Identify each invitee by the email address of each item in the items of the request body.
        Each invitee should have a unique email.
        This API limits the maximum size of items in the request body to 100.

        :param meeting_id: Unique identifier for the meeting to which the people are being invited. This attribute only
            applies to meeting series and scheduled meetings. If it's a meeting series, the meeting invitees are
            invited to the entire meeting series; if it's a scheduled meeting, the meeting invitees are invited to this
            individual scheduled meeting. It doesn't apply to an ended or ongoing meeting instance. The meeting ID of a
            scheduled personal room meeting is not supported for this API.
        :type meeting_id: str
        :param host_email: Email address for the meeting host. This attribute should only be set if the user or
            application calling the API has the admin on-behalf-of scopes. When used, the admin may specify the email
            of a user in a site they manage to be the meeting host.
        :type host_email: str
        :param items: Meeting invitees to be inserted.
        :type items: CreateInviteesItemObject

        documentation: https://developer.webex.com/docs/api/v1/meeting-invitees/create-meeting-invitees
        """
        body = CreateMeetingInviteesBody()
        if meeting_id is not None:
            body.meeting_id = meeting_id
        if host_email is not None:
            body.host_email = host_email
        if items is not None:
            body.items = items
        url = self.ep('bulkInsert')
        data = super().post(url=url, data=body.json())
        return parse_obj_as(list[GetInviteeObject], data["items"])

    def invitee(self, meeting_invitee_id: str, host_email: str = None) -> GetInviteeObject:
        """
        Retrieve details for a meeting invitee identified by a meetingInviteeId in the URI.

        :param meeting_invitee_id: Unique identifier for the invitee whose details are being requested.
        :type meeting_invitee_id: str
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin on-behalf-of scopes. If set, the admin may specify the email of a user in a
            site they manage and the API will return details for a meeting invitee that is hosted by that user.
        :type host_email: str

        documentation: https://developer.webex.com/docs/api/v1/meeting-invitees/get-a-meeting-invitee
        """
        params = {}
        if host_email is not None:
            params['hostEmail'] = host_email
        url = self.ep(f'{meeting_invitee_id}')
        data = super().get(url=url, params=params)
        return GetInviteeObject.parse_obj(data)

    def update_invitee(self, meeting_invitee_id: str, email: str = None, display_name: str = None, co_host: bool = None, send_email: bool = None, panelist: bool = None, host_email: str = None) -> GetInviteeObject:
        """
        Update details for a meeting invitee identified by a meetingInviteeId in the URI.

        :param meeting_invitee_id: Unique identifier for the invitee to be updated. This parameter only applies to an
            invitee to a meeting series or a scheduled meeting. It doesn't apply to an invitee to an ended or ongoing
            meeting instance.
        :type meeting_invitee_id: str
        :param email: Email address for cohost. This attribute can be modified with the Update Personal Meeting Room
            Options API. Possible values: john.andersen@example.com
        :type email: str
        :param display_name: Display name for cohost. This attribute can be modified with the Update Personal Meeting
            Room Options API. Possible values: John Andersen
        :type display_name: str
        :param co_host: Whether or not invitee is a designated alternate host for the meeting. See Add Alternate Hosts
            for Cisco Webex Meetings for more details.
        :type co_host: bool
        :param send_email: If true, send an email to the invitee.
        :type send_email: bool
        :param panelist: If true, the invitee is a designated panelist for the event meeting.
        :type panelist: bool
        :param host_email: Email address for the meeting host. This attribute should only be set if the user or
            application calling the API has the admin on-behalf-of scopes. When used, the admin may specify the email
            of a user in a site they manage to be the meeting host.
        :type host_email: str

        documentation: https://developer.webex.com/docs/api/v1/meeting-invitees/update-a-meeting-invitee
        """
        body = UpdateMeetingInviteeBody()
        if email is not None:
            body.email = email
        if display_name is not None:
            body.display_name = display_name
        if co_host is not None:
            body.co_host = co_host
        if send_email is not None:
            body.send_email = send_email
        if panelist is not None:
            body.panelist = panelist
        if host_email is not None:
            body.host_email = host_email
        url = self.ep(f'{meeting_invitee_id}')
        data = super().put(url=url, data=body.json())
        return GetInviteeObject.parse_obj(data)

    def delete_invitee(self, meeting_invitee_id: str, host_email: str = None, send_email: bool = None):
        """
        Removes a meeting invitee identified by a meetingInviteeId specified in the URI. The deleted meeting invitee
        cannot be recovered.
        If the meeting invitee is associated with a meeting series, the invitee will be removed from the entire meeting
        series. If the invitee is associated with a scheduled meeting, the invitee will be removed from only that
        scheduled meeting.

        :param meeting_invitee_id: Unique identifier for the invitee to be removed. This parameter only applies to an
            invitee to a meeting series or a scheduled meeting. It doesn't apply to an invitee to an ended or ongoing
            meeting instance.
        :type meeting_invitee_id: str
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin on-behalf-of scopes. If set, the admin may specify the email of a user in a
            site they manage and the API will delete a meeting invitee that is hosted by that user.
        :type host_email: str
        :param send_email: If true, send an email to the invitee.
        :type send_email: bool

        documentation: https://developer.webex.com/docs/api/v1/meeting-invitees/delete-a-meeting-invitee
        """
        params = {}
        if host_email is not None:
            params['hostEmail'] = host_email
        if send_email is not None:
            params['sendEmail'] = str(send_email).lower()
        url = self.ep(f'{meeting_invitee_id}')
        super().delete(url=url, params=params)
        return

class MeetingMessagesApi(ApiChild, base='meeting/messages/'):
    """
    Meeting Messages are how we communicate through text within an active unified meeting
    Meeting Messages are also how we communicate through text within a space bound meeting.
    In a Webex meeting, each meeting message is displayed on its own line along with a timestamp and sender
    information.
    Message can contain plain text and rich text
    """

    def delete_meeting_message(self, meeting_message_id: str):
        """
        Deletes a Meeting Message from the In Meeting Chat, using its ID.
        This ID can be retrieved by a Compliance Officer using the events API filtering on the meetingMessages resource
        type.
        Specify the meetingMessage ID in the meetingMessageId parameter in the URI.

        :param meeting_message_id: The unique identifier for the message.
        :type meeting_message_id: str

        documentation: https://developer.webex.com/docs/api/v1/meeting-messages/delete-a-meeting-message
        """
        url = self.ep(f'{meeting_message_id}')
        super().delete(url=url)
        return

class Video(str, Enum):
    #: The video is turned on.
    on = 'on'
    #: The video is turned off.
    off = 'off'


class State3(str, Enum):
    #: The participant is waiting in the meeting lobby.
    lobby = 'lobby'
    #: The participant has joined the meeting.
    joined = 'joined'


class State(State3):
    #: The participant has left the meeting.
    end = 'end'
    #: The participant has joined a breakout session.
    breakout_session = 'breakoutSession'


class CallType(str, Enum):
    #: Connect audio by dialing a toll or toll-free phone number provided by the meeting.
    call_in = 'callIn'
    #: Connect audio by dialing out a phone number from the meeting.
    call_back = 'callBack'


class AudioType(str, Enum):
    #: PSTN
    pstn = 'pstn'
    #: VoIP
    voip = 'voip'
    #: The participant is not connected to audio.
    inactive = 'inactive'


class InProgressDevice(ApiModel):
    #: An internal ID that is associated with each join.
    correlation_id: Optional[str]
    #: The type of device.
    device_type: Optional[str]
    #: The audio type that the participant is using.
    audio_type: Optional[AudioType]
    #: The time the device joined the meeting. If the field is non-existent or shows 1970-01-01T00:00:00.000Z the
    #: meeting may be still ongoing and the joinedTime will be filled in after the meeting ended. If you need real-time
    #: joined events, please refer to the webhooks guide.
    joined_time: Optional[str]
    #: The time the device left the meeting, leftTime is the exact moment when a specific device left the meeting. If
    #: the field is non-existent or shows 1970-01-01T00:00:00.000Z the meeting may be still ongoing and the leftTime
    #: will be filled in after the meeting ended. If you need real-time left events, please refer to the webhooks
    #: guide.
    left_time: Optional[str]


class Device1(InProgressDevice):
    #: The duration in seconds the device stayed in the meeting.
    duration_second: Optional[int]
    #: The PSTN call type in which the device joined the meeting.
    call_type: Optional[CallType]
    #: The PSTN phone number from which the device joined the meeting. Only compliance officer can retrieve the
    #: phoneNumber. The meeting host and admin users cannot retrieve it. NOTE: The phoneNumber will be returned after
    #: the meeting ends; it is not returned while the meeting is in progress.
    phone_number: Optional[str]


class Participant(CoHosts):
    #: The ID that identifies the meeting and the participant.
    id: Optional[str]
    #: The ID that identifies the organization. It only applies to participants of ongoing meetings.
    org_id: Optional[str]
    #: Whether or not the participant is the host of the meeting.
    host: Optional[bool]
    #: Whether or not the participant has host privilege in the meeting.
    co_host: Optional[bool]
    #: Whether or not the participant is the team space moderator. This field returns only if the meeting is associated
    #: with a Webex space.
    space_moderator: Optional[bool]
    #: Whether or not the participant is invited to the meeting.
    invitee: Optional[bool]
    #: Whether or not the participant's audio is muted.
    muted: Optional[bool]
    #: The time the meeting started.
    meeting_start_time: Optional[str]
    #: The status of the participant's video.
    video: Optional[Video]
    #: The status of the participant in the meeting. The value of state is breakoutSession which is only returned when
    #: the meeting is in progress and the breakout session is enabled.
    state: Optional[State]
    #: The time the participant joined the meeting. If the field is non-existent or shows 1970-01-01T00:00:00.000Z the
    #: meeting may be still ongoing and the joinedTime will be filled in after the meeting ended. If you need real-time
    #: join events, please refer to the webhooks guide.
    joined_time: Optional[str]
    #: The time the participant left the meeting. If the field is non-existent or shows 1970-01-01T00:00:00.000Z the
    #: meeting may be still ongoing and the leftTime will be filled in after the meeting ended. If you need real-time
    #: left events, please refer to the webhooks guide.
    left_time: Optional[str]
    #: The site URL.
    site_url: Optional[str]
    #: A unique identifier for the meeting which the participant belongs to.
    meeting_id: Optional[str]
    #: The email address of the host.
    host_email: Optional[str]
    devices: Optional[list[Device1]]
    #: The source ID of the participant. The sourceId is from the Create Invitation Sources API.
    source_id: Optional[str]


class ListMeetingParticipantsResponse(ApiModel):
    items: Optional[list[Participant]]


class QueryMeetingParticipantsWithEmailBody(ApiModel):
    #: Participants email list
    #: Possible values: john.andersen@example.com
    emails: Optional[list[str]]
    #: The time participants join a meeting starts from the specified date and time (inclusive) in any ISO 8601
    #: compliant format. If joinTimeFrom is not specified, it equals joinTimeTo minus 7 days.
    join_time_from: Optional[str]
    #: The time participants join a meeting before the specified date and time (exclusive) in any ISO 8601 compliant
    #: format. If joinTimeTo is not specified, it equals joinTimeFrom plus 7 days. The interval between joinTimeFrom
    #: and joinTimeTo must be within 90 days.
    join_time_to: Optional[str]


class QueryMeetingParticipantsWithEmailResponse(ApiModel):
    items: Optional[list[Participant]]


class UpdateParticipantBody(ApiModel):
    #: The value is true or false, and means to mute or unmute the audio of a participant.
    muted: Optional[bool]
    #: The value can be true or false. The value of true is to admit a participant to the meeting if the participant is
    #: in the lobby, No-Op if the participant is not in the lobby or when the value is set to false.
    admit: Optional[bool]
    #: The attribute is exclusive and its value can be true or false. The value of true means that the participant will
    #: be expelled from the meeting, the value of false means No-Op.
    expel: Optional[bool]


class UpdateParticipantResponse(CoHosts):
    #: The participant ID that identifies the meeting and the participant.
    id: Optional[str]
    #: The ID that identifies the organization.
    org_id: Optional[str]
    #: Whether or not the participant is the host of the meeting.
    host: Optional[bool]
    #: Whether or not the participant has host privilege in the meeting.
    co_host: Optional[bool]
    #: Whether or not the participant is the team space moderator. This field returns only if the meeting is associated
    #: with a Webex space.
    space_moderator: Optional[bool]
    #: Whether or not the participant is invited to the meeting.
    invitee: Optional[bool]
    #: The status of the participant's video.
    video: Optional[Video]
    #: Whether or not the participant's audio is muted.
    muted: Optional[bool]
    #: The status of the participant in the meeting.
    state: Optional[State3]
    #: The site URL.
    site_url: Optional[str]
    #: A unique identifier for the meeting which the participant belongs to.
    meeting_id: Optional[str]
    #: The email address of the host.
    host_email: Optional[str]
    devices: Optional[list[InProgressDevice]]


class AdmitParticipantsBody(ApiModel):
    #: The ID that identifies the meeting participant.
    items: Optional[list[ParticipantID]]


class MeetingParticipantsApi(ApiChild, base='meetingParticipants'):
    """
    This API manages meeting participants.
    Refer to the Meetings API Scopes section of Meetings Overview for scopes required for each API.
    """

    def list_participants(self, meeting_id: str, meeting_start_time_from: str = None, meeting_start_time_to: str = None, host_email: str = None, join_time_from: str = None, join_time_to: str = None, **params) -> Generator[Participant, None, None]:
        """
        List all participants in an in-progress meeting or an ended meeting. The meetingId parameter is required, which
        is the unique identifier for the meeting.
        The authenticated user calling this API must either have an Administrator role with the
        meeting:admin_participants_read scope, or be the meeting host.

        :param meeting_id: The unique identifier for the meeting. Please note that currently meeting ID of a scheduled
            personal room meeting is not supported for this API.
        :type meeting_id: str
        :param meeting_start_time_from: Meetings start from the specified date and time(exclusive) in any ISO 8601
            compliant format. If meetingStartTimeFrom is not specified, it equals meetingStartTimeTo minus 1 month; if
            meetingStartTimeTo is also not specified, the default value for meetingStartTimeFrom is 1 month before
            current date and time.
        :type meeting_start_time_from: str
        :param meeting_start_time_to: Meetings start before the specified date and time(exclusive) in any ISO 8601
            compliant format. If meetingStartTimeTo is not specified, it equals the result of a comparison,
            meetingStartTimeFrom plus one month and the current time, and the result is the earlier of the two; if
            meetingStartTimeFrom is also not specified, the default value for meetingStartTimeTo is current date and
            time minus 1 month.
        :type meeting_start_time_to: str
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin-level scopes, the admin may specify the email of a user in a site they manage
            and the API will return meeting participants of the meetings that are hosted by that user.
        :type host_email: str
        :param join_time_from: The time participants join a meeting starts from the specified date and time (inclusive)
            in any ISO 8601 compliant format. If joinTimeFrom is not specified, it equals joinTimeTo minus 7 days.
        :type join_time_from: str
        :param join_time_to: The time participants join a meeting before the specified date and time (exclusive) in any
            ISO 8601 compliant format. If joinTimeTo is not specified, it equals joinTimeFrom plus 7 days. The interval
            between joinTimeFrom and joinTimeTo must be within 90 days.
        :type join_time_to: str

        documentation: https://developer.webex.com/docs/api/v1/meeting-participants/list-meeting-participants
        """
        params['meetingId'] = meeting_id
        if meeting_start_time_from is not None:
            params['meetingStartTimeFrom'] = meeting_start_time_from
        if meeting_start_time_to is not None:
            params['meetingStartTimeTo'] = meeting_start_time_to
        if host_email is not None:
            params['hostEmail'] = host_email
        if join_time_from is not None:
            params['joinTimeFrom'] = join_time_from
        if join_time_to is not None:
            params['joinTimeTo'] = join_time_to
        url = self.ep()
        return self.session.follow_pagination(url=url, model=Participant, params=params)

    def query_participants_with_email(self, meeting_id: str, meeting_start_time_from: str = None, meeting_start_time_to: str = None, host_email: str = None, emails: List[str] = None, join_time_from: str = None, join_time_to: str = None) -> list[Participant]:
        """
        Query participants in a live meeting, or after the meeting, using participant's email. The meetingId parameter
        is the unique identifier for the meeting and is required.
        The authenticated user calling this API must either have an Administrator role with the
        meeting:admin_participants_read scope, or be the meeting host.

        :param meeting_id: The unique identifier for the meeting.
        :type meeting_id: str
        :param meeting_start_time_from: Meetings start from the specified date and time(exclusive) in any ISO 8601
            compliant format. If meetingStartTimeFrom is not specified, it equals meetingStartTimeTo minus 1 month; if
            meetingStartTimeTo is also not specified, the default value for meetingStartTimeFrom is 1 month before
            current date and time.
        :type meeting_start_time_from: str
        :param meeting_start_time_to: Meetings start before the specified date and time(exclusive) in any ISO 8601
            compliant format. If meetingStartTimeTo is not specified, it equals the result of a comparison,
            meetingStartTimeFrom plus one month and the current time, and the result is the earlier of the two; if
            meetingStartTimeFrom is also not specified, the default value for meetingStartTimeTo is current date and
            time minus 1 month.
        :type meeting_start_time_to: str
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin-level scopes, the admin may specify the email of a user in a site they manage
            and the API will return meeting participants of the meetings that are hosted by that user.
        :type host_email: str
        :param emails: Participants email list Possible values: john.andersen@example.com
        :type emails: List[str]
        :param join_time_from: The time participants join a meeting starts from the specified date and time (inclusive)
            in any ISO 8601 compliant format. If joinTimeFrom is not specified, it equals joinTimeTo minus 7 days.
        :type join_time_from: str
        :param join_time_to: The time participants join a meeting before the specified date and time (exclusive) in any
            ISO 8601 compliant format. If joinTimeTo is not specified, it equals joinTimeFrom plus 7 days. The interval
            between joinTimeFrom and joinTimeTo must be within 90 days.
        :type join_time_to: str

        documentation: https://developer.webex.com/docs/api/v1/meeting-participants/query-meeting-participants-with-email
        """
        params = {}
        params['meetingId'] = meeting_id
        if meeting_start_time_from is not None:
            params['meetingStartTimeFrom'] = meeting_start_time_from
        if meeting_start_time_to is not None:
            params['meetingStartTimeTo'] = meeting_start_time_to
        if host_email is not None:
            params['hostEmail'] = host_email
        body = QueryMeetingParticipantsWithEmailBody()
        if emails is not None:
            body.emails = emails
        if join_time_from is not None:
            body.join_time_from = join_time_from
        if join_time_to is not None:
            body.join_time_to = join_time_to
        url = self.ep('query')
        data = super().post(url=url, params=params, data=body.json())
        return parse_obj_as(list[Participant], data["items"])

    def participant_details(self, participant_id: str, host_email: str = None) -> Participant:
        """
        Get a meeting participant details of a live or post meeting. The participantId is required to identify the
        meeting and the participant.
        The authenticated user calling this API must either have an Administrator role with the
        meeting:admin_participants_read scope, or be the meeting host.

        :param participant_id: The unique identifier for the meeting and the participant.
        :type participant_id: str
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin-level scopes, the admin may specify the email of a user in a site they manage
            and the API will return meeting participants of the meetings that are hosted by that user.
        :type host_email: str

        documentation: https://developer.webex.com/docs/api/v1/meeting-participants/get-meeting-participant-details
        """
        params = {}
        if host_email is not None:
            params['hostEmail'] = host_email
        url = self.ep(f'{participant_id}')
        data = super().get(url=url, params=params)
        return Participant.parse_obj(data)

    def update_participant(self, participant_id: str, muted: bool = None, admit: bool = None, expel: bool = None) -> UpdateParticipantResponse:
        """
        To mute, un-mute, expel, or admit a participant in a live meeting. The participantId is required to identify
        the meeting and the participant.
        Notes:

        :param participant_id: The unique identifier for the meeting and the participant.
        :type participant_id: str
        :param muted: The value is true or false, and means to mute or unmute the audio of a participant.
        :type muted: bool
        :param admit: The value can be true or false. The value of true is to admit a participant to the meeting if the
            participant is in the lobby, No-Op if the participant is not in the lobby or when the value is set to
            false.
        :type admit: bool
        :param expel: The attribute is exclusive and its value can be true or false. The value of true means that the
            participant will be expelled from the meeting, the value of false means No-Op.
        :type expel: bool

        documentation: https://developer.webex.com/docs/api/v1/meeting-participants/update-a-participant
        """
        body = UpdateParticipantBody()
        if muted is not None:
            body.muted = muted
        if admit is not None:
            body.admit = admit
        if expel is not None:
            body.expel = expel
        url = self.ep(f'{participant_id}')
        data = super().put(url=url, data=body.json())
        return UpdateParticipantResponse.parse_obj(data)

    def admit_participants(self, items: List[ParticipantID] = None):
        """
        To admit participants into a live meeting in bulk.
        This API limits the maximum size of items in the request body to 100.
        Each participantId of items in the request body should have the same prefix of meetingId.

        :param items: The ID that identifies the meeting participant.
        :type items: List[ParticipantID]

        documentation: https://developer.webex.com/docs/api/v1/meeting-participants/admit-participants
        """
        body = AdmitParticipantsBody()
        if items is not None:
            body.items = items
        url = self.ep('admit')
        super().post(url=url, data=body.json())
        return

class Type1(str, Enum):
    #: A single-answer question.
    single = 'single'
    #: A multiple-answer question.
    multiple = 'multiple'
    #: A text answer.
    short = 'short'


class Option(ApiModel):
    #: The order of the option.
    order: Optional[str]
    #: The value of the option.
    value: Optional[str]
    #: Whether or not the option is correct.
    is_correct: Optional[bool]


class Question(ApiModel):
    #: A unique identifier for the question.
    id: Optional[str]
    #: The order of the question.
    order: Optional[str]
    #: The question.
    title: Optional[str]
    #: The type of the question.
    type: Optional[Type1]
    #: Question's options.
    options: Optional[list[Option]]


class Poll(CoHosts):
    #: A unique identifier for the poll.
    id: Optional[str]
    #: A unique identifier for the meeting instance to which the poll belongs.
    meeting_id: Optional[str]
    #: The date and time the poll started in ISO 8601 compliant format.
    start_time: Optional[str]
    #: The date and time the poll ended in ISO 8601 compliant format.
    end_time: Optional[str]
    #: The length of time in the alarm box, in seconds.
    timer_duration: Optional[int]
    #: The ID of the polling coordinator.
    person_id: Optional[str]
    #: Poll's questions.
    questions: Optional[list[Question]]


class AnswerSummaryItem(Option):
    #: The total number of people who selected this answer.
    total_respondents: Optional[int]


class Link(ApiModel):
    #: Link to the previous question's respondents.
    prev: Optional[str]
    #: Link to the current question's respondents.
    self: Optional[str]
    #: Link to the next page question's respondents.
    next: Optional[str]


class Respondent(CoHosts):
    #: An array of answers. If it is a single-answer question or text answer, there is at most one; if it is a
    #: multiple-answer question, there may be more than one.
    answers: Optional[list[str]]


class RespondentsReferenceLinks(ApiModel):
    #: The pagination links of this question's respondent.
    links: Optional[Link]
    #: An array of answers.
    items: Optional[list[Respondent]]


class QuestionResult(ApiModel):
    #: A unique identifier of the question.
    id: Optional[str]
    #: The order of the question in the poll.
    order: Optional[str]
    #: The question.
    title: Optional[str]
    #: The type of the question.
    type: Optional[Type1]
    #: Summary of all answers.
    answer_summary: Optional[list[AnswerSummaryItem]]
    #: Question's respondents.
    respondents: Optional[RespondentsReferenceLinks]


class PollResult(CoHosts):
    #: A unique identifier for the poll.
    id: Optional[str]
    #: A unique identifier for the meeting instance to which the poll belongs.
    meeting_id: Optional[str]
    #: The total number of attendees in the meeting.
    total_attendees: Optional[int]
    #: The total number of respondents in the poll.
    total_respondents: Optional[int]
    #: The date and time the poll started in ISO 8601 compliant format.
    start_time: Optional[str]
    #: The date and time the poll ended in ISO 8601 compliant format.
    end_time: Optional[str]
    #: The duration of the poll, in seconds.
    timer_duration: Optional[int]
    #: The ID of the the poll coordinator.
    person_id: Optional[str]
    #: An array of questions in this poll.
    questions: Optional[list[QuestionResult]]


class ListMeetingPollsResponse(ApiModel):
    items: Optional[list[Poll]]


class GetMeetingPollResultsResponse(ApiModel):
    items: Optional[list[PollResult]]


class ListRespondentsOfQuestionResponse(ApiModel):
    items: Optional[list[Respondent]]


class MeetingPollsApi(ApiChild, base='meetings/poll'):
    """
    As a presenter, you can use a poll to create and share questionnaires. Polls can be useful for gathering feedback,
    taking votes, or testing knowledge.
    You can use the Meeting Poll API to list meeting polls, the poll's questions, and answers.
    Currently, these APIs are available to users with one of the meeting host, admin or Compliance Officer roles.
    The Webex meetings poll functionality and API endpoint described here is "upon-request" and not enabled by default.
    If you need it enabled for your org, or if you need help, please contact the Webex Developer Support team at
    devsupport@webex.com.
    """

    def list_meeting_polls(self, meeting_id: str) -> list[Poll]:
        """
        Lists all the polls and the poll questions in a meeting when ready.

        :param meeting_id: A unique identifier for the meeting instance to which the polls belong.
        :type meeting_id: str

        documentation: https://developer.webex.com/docs/api/v1/meeting-polls/list-meeting-polls
        """
        params = {}
        params['meetingId'] = meeting_id
        url = self.ep('s')
        data = super().get(url=url, params=params)
        return parse_obj_as(list[Poll], data["items"])

    def meeting_poll_results(self, meeting_id: str, **params) -> Generator[PollResult, None, None]:
        """
        List the meeting polls, the poll's questions, and answers from the meeting when ready.

        :param meeting_id: A unique identifier for the meeting instance to which the polls belong.
        :type meeting_id: str

        documentation: https://developer.webex.com/docs/api/v1/meeting-polls/get-meeting-pollresults
        """
        params['meetingId'] = meeting_id
        url = self.ep('Results')
        return self.session.follow_pagination(url=url, model=PollResult, params=params)

    def list_respondents_of_question(self, poll_id: str, question_id: str, meeting_id: str, **params) -> Generator[Respondent, None, None]:
        """
        Lists the respondents to a specific questions in a poll.

        :param poll_id: A unique identifier for the poll to which the respondents belong.
        :type poll_id: str
        :param question_id: A unique identifier for the question to which the respondents belong.
        :type question_id: str
        :param meeting_id: A unique identifier for the meeting instance to which the respondents belong.
        :type meeting_id: str

        documentation: https://developer.webex.com/docs/api/v1/meeting-polls/list-respondents-of-a-question
        """
        params['meetingId'] = meeting_id
        url = self.ep(f's/{poll_id}/questions/{question_id}/respondents')
        return self.session.follow_pagination(url=url, model=Respondent, params=params)

class CallInNumbers(ApiModel):
    #: Label for call-in number.
    #: Possible values: Call-in toll-free number (US/Canada)
    label: Optional[str]
    #: Call-in number to join teleconference from a phone.
    #: Possible values: 123456789
    call_in_number: Optional[str]
    #: Type of toll for the call-in number.
    #: Possible values: toll, tollFree
    toll_type: Optional[str]


class Links(ApiModel):
    #: Link relation describing how the target resource is related to the current context (conforming with RFC5998).
    rel: Optional[str]
    #: Target resource URI (conforming with RFC5998).
    href: Optional[str]
    #: Target resource method (conforming with RFC5998).
    method: Optional[str]


class Telephony(ApiModel):
    #: Code for authenticating a user to join teleconference. Users join the teleconference using the call-in number or
    #: the global call-in number, followed by the value of the accessCode.
    access_code: Optional[str]
    #: Array of call-in numbers for joining teleconference from a phone.
    call_in_numbers: Optional[list[CallInNumbers]]
    #: HATEOAS information of global call-in numbers for joining teleconference from a phone.
    links: Optional[Links]


class PersonalMeetingRoom(ApiModel):
    #: Personal Meeting Room topic. The length of topic must be between 1 and 128 characters. This attribute can be
    #: modified with the Update Personal Meeting Room Options API.
    topic: Optional[str]
    #: PIN for joining the room as host. The host PIN must be digits of a predefined length, e.g. 4 digits. It cannot
    #: contain sequential digits, such as 1234 or 4321, or repeated digits of the predefined length, such as 1111. The
    #: predefined length for host PIN can be viewed in user's My Personal Room page. This attribute can be modified
    #: with the Update Personal Meeting Room Options API.
    host_pin: Optional[str]
    #: PIN for joining the room as host. The host PIN must be digits of a predefined length, e.g. 4 digits. It cannot
    #: contain sequential digits, such as 1234 or 4321, or repeated digits of the predefined length, such as 1111. The
    #: predefined length for host PIN can be viewed in user's My Personal Room page. This attribute can be modified
    #: with the Update Personal Meeting Room Options API.
    host_pin: Optional[str]
    #: Personal Meeting Room link. It cannot be empty. Note: This is a read-only attribute.
    personal_meeting_room_link: Optional[str]
    #: Option to automatically lock the Personal Room a number of minutes after a meeting starts. When a room is
    #: locked, invitees cannot enter until the owner admits them. The period after which the meeting is locked is
    #: defined by autoLockMinutes. This attribute can be modified with the Update Personal Meeting Room Options API.
    enabled_auto_lock: Optional[bool]
    #: Number of minutes after which the Personal Room is locked if enabledAutoLock is enabled. Valid options are 0, 5,
    #: 10, 15 and 20. This attribute can be modified with the Update Personal Meeting Room Options API.
    auto_lock_minutes: Optional[int]
    #: Flag to enable notifying the owner of a Personal Room when someone enters the Personal Room lobby while the
    #: owner is not in the room. This attribute can be modified with the Update Personal Meeting Room Options API.
    enabled_notify_host: Optional[bool]
    #: Flag allowing other invitees to host a meeting in the Personal Room without the owner. This attribute can be
    #: modified with the Update Personal Meeting Room Options API.
    support_co_host: Optional[bool]
    #: Whether or not to allow any attendee with a host account on the target site to become a cohost when joining the
    #: Personal Room. The target site is user's preferred site. This attribute can be modified with the Update Personal
    #: Meeting Room Options API.
    support_anyone_as_co_host: Optional[bool]
    #: Whether or not to allow the first attendee with a host account on the target site to become a cohost when
    #: joining the Personal Room. The target site is user's preferred site. This attribute can be modified with the
    #: Update Personal Meeting Room Options API.
    allow_first_user_to_be_co_host: Optional[bool]
    #: Whether or not to allow authenticated video devices in the user's organization to start or join the meeting
    #: without a prompt. This attribute can be modified with the Update Personal Meeting Room Options API.
    allow_authenticated_devices: Optional[bool]
    #: Array defining cohosts for the room if both supportAnyoneAsCoHost and allowFirstUserToBeCoHost are false This
    #: attribute can be modified with the Update Personal Meeting Room Options API.
    co_hosts: Optional[list[CoHosts]]
    #: SIP address for callback from a video system.
    sip_address: Optional[str]
    #: IP address for callback from a video system.
    dial_in_ip_address: Optional[str]
    #: Information for callbacks from meeting to phone or for joining a teleconference using a phone.
    telephony: Optional[Telephony]


class DefaultAudioType(str, Enum):
    #: Webex audio. This supports telephony and VoIP.
    webex_audio = 'webexAudio'
    #: Support only VoIP.
    voip_only = 'voipOnly'
    #: Other teleconference service. Details are defined in the otherTeleconferenceDescription parameter.
    other_teleconference_service = 'otherTeleconferenceService'
    #: No audio.
    none = 'none'


class OfficeNumber(ApiModel):
    #: Country code for the phone number. This attribute can be modified with the with the Update Audio Options API.
    country_code: Optional[str]
    #: Phone number. It cannot be longer than 30 characters. This attribute can be modified with the with the Update
    #: Audio Options API.
    number: Optional[str]
    #: Flag identifying the phone number as the one that will be used to dial into a teleconference. This attribute can
    #: be modified with the with the Update Audio Options API.
    enabled_call_in_authentication: Optional[bool]
    #: Flag to enable/disable Call Me number display on the meeting client. This attribute can be modified with the
    #: with the Update Audio Options API. Note: This feature is only effective if the site supports the Call Me
    #: feature.
    enabled_call_me: Optional[bool]


class Audio(ApiModel):
    #: Default audio type. This attribute can be modified with the with the Update Audio Options API.
    default_audio_type: Optional[DefaultAudioType]
    #: Phone number and other information for the teleconference provider to be used, along with instructions for
    #: invitees. This attribute can be modified with the with the Update Audio Options API.
    other_teleconference_description: Optional[str]
    #: Flag to enable/disable global call ins. Note: If the site does not support global call-ins, you cannot set this
    #: option. This attribute can be modified with the with the Update Audio Options API.
    enabled_global_call_in: Optional[bool]
    #: Flag to enable/disable call-ins from toll-free numbers. Note: If the site does not support calls from toll-free
    #: numbers, you cannot set this option. This attribute can be modified with the with the Update Audio Options API.
    enabled_toll_free: Optional[bool]
    #: Flag to enable/disable automatically connecting to audio using a computer. The meeting host can enable/disable
    #: this option. When this option is set to true, the user is automatically connected to audio via a computer when
    #: they start or join a Webex Meetings meeting on a desktop. `This attribute can be modified with the with the
    #: Update Audio Options API.
    enabled_auto_connection: Optional[bool]
    #: PIN to provide a secondary level of authentication for calls where the host is using the phone and may need to
    #: invite additional invitees. It must be exactly 4 digits. It cannot contain sequential digits, such as 1234 or
    #: 4321, or repeat a digit 4 times, such as 1111. This attribute can be modified with the with the Update Audio
    #: Options API.
    audio_pin: Optional[str]
    #: Office phone number. We recommend that phone numbers be specified to facilitate connecting via audio. This
    #: attribute can be modified with the with the Update Audio Options API.
    office_number: Optional[OfficeNumber]
    #: Mobile phone number. We recommend that phone numbers be specified to facilitate connecting via audio. This
    #: attribute can be modified with the with the Update Audio Options API.
    mobile_number: Optional[OfficeNumber]


class VideoDevices(ApiModel):
    #: Video system name. It cannot be empty. This attribute can be modified with the Update Video Options API.
    #: Possible values: device1
    device_name: Optional[str]
    #: Video address. It cannot be empty and must be in valid email format. This attribute can be modified with the
    #: Update Video Options API.
    #: Possible values: device1@example.com
    device_address: Optional[str]
    #: Flag identifying the device as the default video device. If user's video device list is not empty, one and only
    #: one device must be set as default. This attribute can be modified with the Update Video Options API.
    #: Possible values:
    is_default: Optional[bool]


class Video4(ApiModel):
    #: Array of video devices. This attribute can be modified with the Update Video Options API.
    video_devices: Optional[list[VideoDevices]]


class SchedulingOptionsObject(ApiModel):
    #: Flag to enable/disable Join Before Host. The period during which invitees can join before the start time is
    #: defined by autoLockMinutes. This attribute can be modified with the Update Scheduling Options API. Note: This
    #: feature is only effective if the site supports the Join Before Host feature. This attribute can be modified with
    #: the Update Scheduling Options API.
    enabled_join_before_host: Optional[bool]
    #: Number of minutes before the start time that an invitee can join a meeting if enabledJoinBeforeHost is true.
    #: Valid options are 0, 5, 10 and 15. This attribute can be modified with the Update Scheduling Options API.
    join_before_host_minutes: Optional[int]
    #: Flag to enable/disable the automatic sharing of the meeting recording with invitees when it is available. This
    #: attribute can be modified with the Update Scheduling Options API.
    enabled_auto_share_recording: Optional[bool]
    #: Flag to automatically enable Webex Assistant whenever you start a meeting. This attribute can be modified with
    #: the Update Scheduling Options API.
    enabled_webex_assistant_by_default: Optional[bool]


class Sites(ApiModel):
    #: Access URL for the site. Note: This is a read-only attribute. The value can be assigned as user's default site
    #: with the Update Default Site API.
    #: Possible values: site1-example.webex.com
    site_url: Optional[str]
    #: Flag identifying the site as the default site. Users can list meetings and recordings, and create meetings on
    #: the default site.
    #: Possible values:
    default: Optional[bool]


class UpdatePersonalMeetingRoomOptionsBody(ApiModel):
    #: Personal Meeting Room topic to be updated.
    topic: Optional[str]
    #: Updated PIN for joining the room as host. The host PIN must be digits of a predefined length, e.g. 4 digits. It
    #: cannot contain sequential digits, such as 1234 or 4321, or repeated digits of the predefined length, such as
    #: 1111. The predefined length for host PIN can be viewed in user's My Personal Room page and it can only be
    #: changed by site administrator.
    host_pin: Optional[str]
    #: Update for option to automatically lock the Personal Room a number of minutes after a meeting starts. When a
    #: room is locked, invitees cannot enter until the owner admits them. The period after which the meeting is locked
    #: is defined by autoLockMinutes.
    enabled_auto_lock: Optional[bool]
    #: Updated number of minutes after which the Personal Room is locked if enabledAutoLock is enabled. Valid options
    #: are 0, 5, 10, 15 and 20.
    auto_lock_minutes: Optional[int]
    #: Update for flag to enable notifying the owner of a Personal Room when someone enters the Personal Room lobby
    #: while the owner is not in the room.
    enabled_notify_host: Optional[bool]
    #: Update for flag allowing other invitees to host a meetingCoHost in the Personal Room without the owner.
    support_co_host: Optional[bool]
    #: Whether or not to allow any attendee with a host account on the target site to become a cohost when joining the
    #: Personal Room. The target site is user's preferred site.
    support_anyone_as_co_host: Optional[bool]
    #: Whether or not to allow the first attendee with a host account on the target site to become a cohost when
    #: joining the Personal Room. The target site is user's preferred site.
    allow_first_user_to_be_co_host: Optional[bool]
    #: Whether or not to allow authenticated video devices in the user's organization to start or join the meeting
    #: without a prompt.
    allow_authenticated_devices: Optional[bool]
    #: Updated array defining cohosts for the room if both supportAnyoneAsCoHost and allowFirstUserToBeCoHost are false
    co_hosts: Optional[list[CoHosts]]


class GetPersonalMeetingRoomOptionsResponse(UpdatePersonalMeetingRoomOptionsBody):
    #: Personal Meeting Room link. It cannot be empty. Note: This is a read-only attribute.
    personal_meeting_room_link: Optional[str]
    #: SIP address for callback from a video system.
    sip_address: Optional[str]
    #: IP address for callback from a video system.
    dial_in_ip_address: Optional[str]
    #: Information for callbacks from meeting to phone or for joining a teleconference using a phone.
    telephony: Optional[Telephony]


class GetMeetingPreferenceDetailsResponse(ApiModel):
    #: Personal Meeting Room options.
    personal_meeting_room: Optional[PersonalMeetingRoom]
    #: Audio Preferences. Note: These audio settings do not apply to Personal Room meetings
    audio: Optional[Audio]
    #: Information for video conferencing systems used to connect to Webex meetings. Note: The Call My Video System
    #: feature is available only if it has been purchased for your site and your administrator has enabled it.
    video: Optional[Video4]
    #: Meeting scheduling options.
    scheduling_options: Optional[SchedulingOptionsObject]
    #: List of user's Webex meeting sites including default site.
    sites: Optional[list[Sites]]


class GetVideoOptionsResponse(ApiModel):
    #: Array of video devices. This attribute can be modified with the Update Video Options API.
    video_devices: Optional[list[VideoDevices]]


class UpdateVideoOptionsBody(ApiModel):
    #: Array of video devices. If the array is not empty, one device and no more than one devices must be set as
    #: default device.
    video_devices: Optional[list[VideoDevices]]


class UpdateVideoOptionsResponse(ApiModel):
    #: Array of video devices. This attribute can be modified with the Update Video Options API.
    video_devices: Optional[list[VideoDevices]]


class GetSiteListResponse(ApiModel):
    #: Array of sites for the user. Users can have one site or multiple sites. This concept is specific to Webex
    #: Meetings. Any siteUrl in the site list can be assigned as user's default site with the Update Default Site API.
    sites: Optional[list[Sites]]


class UpdateDefaultSiteBody(ApiModel):
    #: Access URL for the site.
    site_url: Optional[str]


class MeetingPreferencesApi(ApiChild, base='meetingPreferences'):
    """
    This API manages a user's meeting preferences, including Personal Meeting Room settings, video and audio settings,
    meeting scheduling options, and site settings.
    Refer to the Meetings API Scopes section of Meetings Overview for scopes required for each API.
    """

    def meeting_preference_details(self, user_email: str = None, site_url: str = None) -> GetMeetingPreferenceDetailsResponse:
        """
        Retrieves meeting preferences for the authenticated user.

        :param user_email: Email address for the user. This parameter is only used if the user or application calling
            the API has the required admin-level scopes. If set, the admin may specify the email of a user in a site
            they manage and the API will return details of the meeting preferences for that user.
        :type user_email: str
        :param site_url: URL of the Webex site to query. For individual use, if siteUrl is not specified, the query
            will use the default site of the user. For admin use, if siteUrl is not specified, the query will use the
            default site for the admin's authorization token used to make the call. In the case where the user belongs
            to a site different than the admin’s default site, the admin can set the site to query using the siteUrl
            parameter. All available Webex sites and default site of a user can be retrieved from
            /meetingPreferences/sites.
        :type site_url: str

        documentation: https://developer.webex.com/docs/api/v1/meeting-preferences/get-meeting-preference-details
        """
        params = {}
        if user_email is not None:
            params['userEmail'] = user_email
        if site_url is not None:
            params['siteUrl'] = site_url
        url = self.ep()
        data = super().get(url=url, params=params)
        return GetMeetingPreferenceDetailsResponse.parse_obj(data)

    def personal_meeting_room_options(self, user_email: str = None, site_url: str = None) -> GetPersonalMeetingRoomOptionsResponse:
        """
        Retrieves the Personal Meeting Room options for the authenticated user.

        :param user_email: Email address for the user. This parameter is only used if the user or application calling
            the API has the admin-level scopes. If set, the admin may specify the email of a user in a site they manage
            and the API will return details of the Personal Meeting Room options for that user.
        :type user_email: str
        :param site_url: URL of the Webex site to query. For individual use, if siteUrl is not specified, the query
            will use the default site of the user. For admin use, if siteUrl is not specified, the query will use the
            default site for the admin's authorization token used to make the call. In the case where the user belongs
            to a site different than the admin’s default site, the admin can set the site to query using the siteUrl
            parameter. All available Webex sites and default site of a user can be retrieved from
            /meetingPreferences/sites.
        :type site_url: str

        documentation: https://developer.webex.com/docs/api/v1/meeting-preferences/get-personal-meeting-room-options
        """
        params = {}
        if user_email is not None:
            params['userEmail'] = user_email
        if site_url is not None:
            params['siteUrl'] = site_url
        url = self.ep('personalMeetingRoom')
        data = super().get(url=url, params=params)
        return GetPersonalMeetingRoomOptionsResponse.parse_obj(data)

    def update_personal_meeting_room_options(self, topic: str, host_pin: str, enabled_auto_lock: bool, auto_lock_minutes: int, enabled_notify_host: bool, support_co_host: bool, co_hosts: CoHosts, user_email: str = None, site_url: str = None, support_anyone_as_co_host: bool = None, allow_first_user_to_be_co_host: bool = None, allow_authenticated_devices: bool = None) -> GetPersonalMeetingRoomOptionsResponse:
        """
        Update a single meeting

        :param topic: Personal Meeting Room topic to be updated.
        :type topic: str
        :param host_pin: Updated PIN for joining the room as host. The host PIN must be digits of a predefined length,
            e.g. 4 digits. It cannot contain sequential digits, such as 1234 or 4321, or repeated digits of the
            predefined length, such as 1111. The predefined length for host PIN can be viewed in user's My Personal
            Room page and it can only be changed by site administrator.
        :type host_pin: str
        :param enabled_auto_lock: Update for option to automatically lock the Personal Room a number of minutes after a
            meeting starts. When a room is locked, invitees cannot enter until the owner admits them. The period after
            which the meeting is locked is defined by autoLockMinutes.
        :type enabled_auto_lock: bool
        :param auto_lock_minutes: Updated number of minutes after which the Personal Room is locked if enabledAutoLock
            is enabled. Valid options are 0, 5, 10, 15 and 20.
        :type auto_lock_minutes: int
        :param enabled_notify_host: Update for flag to enable notifying the owner of a Personal Room when someone
            enters the Personal Room lobby while the owner is not in the room.
        :type enabled_notify_host: bool
        :param support_co_host: Update for flag allowing other invitees to host a meetingCoHost in the Personal Room
            without the owner.
        :type support_co_host: bool
        :param co_hosts: Updated array defining cohosts for the room if both supportAnyoneAsCoHost and
            allowFirstUserToBeCoHost are false
        :type co_hosts: CoHosts
        :param user_email: Email address for the user. This parameter is only used if the user or application calling
            the API has the admin-level scopes. If set, the admin may specify the email of a user in a site they manage
            and the API will update Personal Meeting Room options for that user.
        :type user_email: str
        :param site_url: URL of the Webex site to query. For individual use, if siteUrl is not specified, the query
            will use the default site of the user. For admin use, if siteUrl is not specified, the query will use the
            default site for the admin's authorization token used to make the call. In the case where the user belongs
            to a site different than the admin’s default site, the admin can set the site to query using the siteUrl
            parameter. All available Webex sites and default site of a user can be retrieved from
            /meetingPreferences/sites.
        :type site_url: str
        :param support_anyone_as_co_host: Whether or not to allow any attendee with a host account on the target site
            to become a cohost when joining the Personal Room. The target site is user's preferred site.
        :type support_anyone_as_co_host: bool
        :param allow_first_user_to_be_co_host: Whether or not to allow the first attendee with a host account on the
            target site to become a cohost when joining the Personal Room. The target site is user's preferred site.
        :type allow_first_user_to_be_co_host: bool
        :param allow_authenticated_devices: Whether or not to allow authenticated video devices in the user's
            organization to start or join the meeting without a prompt.
        :type allow_authenticated_devices: bool

        documentation: https://developer.webex.com/docs/api/v1/meeting-preferences/update-personal-meeting-room-options
        """
        params = {}
        if user_email is not None:
            params['userEmail'] = user_email
        if site_url is not None:
            params['siteUrl'] = site_url
        body = UpdatePersonalMeetingRoomOptionsBody()
        if topic is not None:
            body.topic = topic
        if host_pin is not None:
            body.host_pin = host_pin
        if enabled_auto_lock is not None:
            body.enabled_auto_lock = enabled_auto_lock
        if auto_lock_minutes is not None:
            body.auto_lock_minutes = auto_lock_minutes
        if enabled_notify_host is not None:
            body.enabled_notify_host = enabled_notify_host
        if support_co_host is not None:
            body.support_co_host = support_co_host
        if co_hosts is not None:
            body.co_hosts = co_hosts
        if support_anyone_as_co_host is not None:
            body.support_anyone_as_co_host = support_anyone_as_co_host
        if allow_first_user_to_be_co_host is not None:
            body.allow_first_user_to_be_co_host = allow_first_user_to_be_co_host
        if allow_authenticated_devices is not None:
            body.allow_authenticated_devices = allow_authenticated_devices
        url = self.ep('personalMeetingRoom')
        data = super().put(url=url, params=params, data=body.json())
        return GetPersonalMeetingRoomOptionsResponse.parse_obj(data)

    def audio_options(self, user_email: str = None, site_url: str = None) -> Audio:
        """
        Retrieves audio options for the authenticated user.

        :param user_email: Email address for the user. This parameter is only used if the user or application calling
            the API has the admin-level scopes. If set, the admin may specify the email of a user in a site they manage
            and the API will return details of the audio options for that user.
        :type user_email: str
        :param site_url: URL of the Webex site to query. For individual use, if siteUrl is not specified, the query
            will use the default site of the user. For admin use, if siteUrl is not specified, the query will use the
            default site for the admin's authorization token used to make the call. In the case where the user belongs
            to a site different than the admin’s default site, the admin can set the site to query using the siteUrl
            parameter. All available Webex sites and default site of a user can be retrieved from
            /meetingPreferences/sites.
        :type site_url: str

        documentation: https://developer.webex.com/docs/api/v1/meeting-preferences/get-audio-options
        """
        params = {}
        if user_email is not None:
            params['userEmail'] = user_email
        if site_url is not None:
            params['siteUrl'] = site_url
        url = self.ep('audio')
        data = super().get(url=url, params=params)
        return Audio.parse_obj(data)

    def update_audio_options(self, user_email: str = None, site_url: str = None, default_audio_type: DefaultAudioType = None, other_teleconference_description: str = None, enabled_global_call_in: bool = None, enabled_toll_free: bool = None, enabled_auto_connection: bool = None, audio_pin: str = None, office_number: OfficeNumber = None, mobile_number: OfficeNumber = None) -> Audio:
        """
        Updates audio options for the authenticated user.

        :param user_email: Email address for the user. This parameter is only used if the user or application calling
            the API has the admin-level scopes. If set, the admin may specify the email of a user in a site they manage
            and the API will update audio options for that user.
        :type user_email: str
        :param site_url: URL of the Webex site to query. For individual use, if siteUrl is not specified, the query
            will use the default site of the user. For admin use, if siteUrl is not specified, the query will use the
            default site for the admin's authorization token used to make the call. In the case where the user belongs
            to a site different than the admin’s default site, the admin can set the site to query using the siteUrl
            parameter. All available Webex sites and default site of a user can be retrieved from
            /meetingPreferences/sites.
        :type site_url: str
        :param default_audio_type: Default audio type. This attribute can be modified with the with the Update Audio
            Options API.
        :type default_audio_type: DefaultAudioType
        :param other_teleconference_description: Phone number and other information for the teleconference provider to
            be used, along with instructions for invitees. This attribute can be modified with the with the Update
            Audio Options API.
        :type other_teleconference_description: str
        :param enabled_global_call_in: Flag to enable/disable global call ins. Note: If the site does not support
            global call-ins, you cannot set this option. This attribute can be modified with the with the Update Audio
            Options API.
        :type enabled_global_call_in: bool
        :param enabled_toll_free: Flag to enable/disable call-ins from toll-free numbers. Note: If the site does not
            support calls from toll-free numbers, you cannot set this option. This attribute can be modified with the
            with the Update Audio Options API.
        :type enabled_toll_free: bool
        :param enabled_auto_connection: Flag to enable/disable automatically connecting to audio using a computer. The
            meeting host can enable/disable this option. When this option is set to true, the user is automatically
            connected to audio via a computer when they start or join a Webex Meetings meeting on a desktop. `This
            attribute can be modified with the with the Update Audio Options API.
        :type enabled_auto_connection: bool
        :param audio_pin: PIN to provide a secondary level of authentication for calls where the host is using the
            phone and may need to invite additional invitees. It must be exactly 4 digits. It cannot contain sequential
            digits, such as 1234 or 4321, or repeat a digit 4 times, such as 1111. This attribute can be modified with
            the with the Update Audio Options API.
        :type audio_pin: str
        :param office_number: Office phone number. We recommend that phone numbers be specified to facilitate
            connecting via audio. This attribute can be modified with the with the Update Audio Options API.
        :type office_number: OfficeNumber
        :param mobile_number: Mobile phone number. We recommend that phone numbers be specified to facilitate
            connecting via audio. This attribute can be modified with the with the Update Audio Options API.
        :type mobile_number: OfficeNumber

        documentation: https://developer.webex.com/docs/api/v1/meeting-preferences/update-audio-options
        """
        params = {}
        if user_email is not None:
            params['userEmail'] = user_email
        if site_url is not None:
            params['siteUrl'] = site_url
        body = Audio()
        if default_audio_type is not None:
            body.default_audio_type = default_audio_type
        if other_teleconference_description is not None:
            body.other_teleconference_description = other_teleconference_description
        if enabled_global_call_in is not None:
            body.enabled_global_call_in = enabled_global_call_in
        if enabled_toll_free is not None:
            body.enabled_toll_free = enabled_toll_free
        if enabled_auto_connection is not None:
            body.enabled_auto_connection = enabled_auto_connection
        if audio_pin is not None:
            body.audio_pin = audio_pin
        if office_number is not None:
            body.office_number = office_number
        if mobile_number is not None:
            body.mobile_number = mobile_number
        url = self.ep('audio')
        data = super().put(url=url, params=params, data=body.json())
        return Audio.parse_obj(data)

    def video_options(self, user_email: str = None, site_url: str = None) -> list[VideoDevices]:
        """
        Retrieves video options for the authenticated user.

        :param user_email: Email address for the user. This parameter is only used if the user or application calling
            the API has the admin-level scopes. If set, the admin may specify the email of a user in a site they manage
            and the API will return details of the video options for that user.
        :type user_email: str
        :param site_url: URL of the Webex site to query. For individual use, if siteUrl is not specified, the query
            will use the default site of the user. For admin use, if siteUrl is not specified, the query will use the
            default site for the admin's authorization token used to make the call. In the case where the user belongs
            to a site different than the admin’s default site, the admin can set the site to query using the siteUrl
            parameter. All available Webex sites and default site of a user can be retrieved using Get Site List.
        :type site_url: str

        documentation: https://developer.webex.com/docs/api/v1/meeting-preferences/get-video-options
        """
        params = {}
        if user_email is not None:
            params['userEmail'] = user_email
        if site_url is not None:
            params['siteUrl'] = site_url
        url = self.ep('video')
        data = super().get(url=url, params=params)
        return parse_obj_as(list[VideoDevices], data["videoDevices"])

    def update_video_options(self, video_devices: VideoDevices, user_email: str = None, site_url: str = None) -> list[VideoDevices]:
        """
        Updates video options for the authenticated user.

        :param video_devices: Array of video devices. If the array is not empty, one device and no more than one
            devices must be set as default device.
        :type video_devices: VideoDevices
        :param user_email: Email address for the user. This parameter is only used if the user or application calling
            the API has the admin-level scopes. If set, the admin may specify the email of a user in a site they manage
            and the API will update video options for that user.
        :type user_email: str
        :param site_url: URL of the Webex site to query. For individual use, if siteUrl is not specified, the query
            will use the default site of the user. For admin use, if siteUrl is not specified, the query will use the
            default site for the admin's authorization token used to make the call. In the case where the user belongs
            to a site different than the admin’s default site, the admin can set the site to query using the siteUrl
            parameter. All available Webex sites and default site of a user can be retrieved from
            /meetingPreferences/sites.
        :type site_url: str

        documentation: https://developer.webex.com/docs/api/v1/meeting-preferences/update-video-options
        """
        params = {}
        if user_email is not None:
            params['userEmail'] = user_email
        if site_url is not None:
            params['siteUrl'] = site_url
        body = UpdateVideoOptionsBody()
        if video_devices is not None:
            body.video_devices = video_devices
        url = self.ep('video')
        data = super().put(url=url, params=params, data=body.json())
        return parse_obj_as(list[VideoDevices], data["videoDevices"])

    def scheduling_options(self, user_email: str = None, site_url: str = None) -> SchedulingOptionsObject:
        """
        Retrieves scheduling options for the authenticated user.

        :param user_email: Email address for the user. This parameter is only used if the user or application calling
            the API has the admin-level scopes. If set, the admin may specify the email of a user in a site they manage
            and the API will return details of the scheduling options for that user.
        :type user_email: str
        :param site_url: URL of the Webex site to query. For individual use, if siteUrl is not specified, the query
            will use the default site of the user. For admin use, if siteUrl is not specified, the query will use the
            default site for the admin's authorization token used to make the call. In the case where the user belongs
            to a site different than the admin’s default site, the admin can set the site to query using the siteUrl
            parameter. All available Webex sites and default site of a user can be retrieved from
            /meetingPreferences/sites.
        :type site_url: str

        documentation: https://developer.webex.com/docs/api/v1/meeting-preferences/get-scheduling-options
        """
        params = {}
        if user_email is not None:
            params['userEmail'] = user_email
        if site_url is not None:
            params['siteUrl'] = site_url
        url = self.ep('schedulingOptions')
        data = super().get(url=url, params=params)
        return SchedulingOptionsObject.parse_obj(data)

    def update_scheduling_options(self, user_email: str = None, site_url: str = None, enabled_join_before_host: bool = None, join_before_host_minutes: int = None, enabled_auto_share_recording: bool = None, enabled_webex_assistant_by_default: bool = None) -> SchedulingOptionsObject:
        """
        Updates scheduling options for the authenticated user.

        :param user_email: Email address for the user. This parameter is only used if the user or application calling
            the API has the admin-level scopes. If set, the admin may specify the email of a user in a site they manage
            and the API will update scheduling options for that user.
        :type user_email: str
        :param site_url: URL of the Webex site to query. For individual use, if siteUrl is not specified, the query
            will use the default site of the user. For admin use, if siteUrl is not specified, the query will use the
            default site for the admin's authorization token used to make the call. In the case where the user belongs
            to a site different than the admin’s default site, the admin can set the site to query using the siteUrl
            parameter. All available Webex sites and default site of a user can be retrieved from
            /meetingPreferences/sites.
        :type site_url: str
        :param enabled_join_before_host: Flag to enable/disable Join Before Host. The period during which invitees can
            join before the start time is defined by autoLockMinutes. This attribute can be modified with the Update
            Scheduling Options API. Note: This feature is only effective if the site supports the Join Before Host
            feature. This attribute can be modified with the Update Scheduling Options API.
        :type enabled_join_before_host: bool
        :param join_before_host_minutes: Number of minutes before the start time that an invitee can join a meeting if
            enabledJoinBeforeHost is true. Valid options are 0, 5, 10 and 15. This attribute can be modified with the
            Update Scheduling Options API.
        :type join_before_host_minutes: int
        :param enabled_auto_share_recording: Flag to enable/disable the automatic sharing of the meeting recording with
            invitees when it is available. This attribute can be modified with the Update Scheduling Options API.
        :type enabled_auto_share_recording: bool
        :param enabled_webex_assistant_by_default: Flag to automatically enable Webex Assistant whenever you start a
            meeting. This attribute can be modified with the Update Scheduling Options API.
        :type enabled_webex_assistant_by_default: bool

        documentation: https://developer.webex.com/docs/api/v1/meeting-preferences/update-scheduling-options
        """
        params = {}
        if user_email is not None:
            params['userEmail'] = user_email
        if site_url is not None:
            params['siteUrl'] = site_url
        body = SchedulingOptionsObject()
        if enabled_join_before_host is not None:
            body.enabled_join_before_host = enabled_join_before_host
        if join_before_host_minutes is not None:
            body.join_before_host_minutes = join_before_host_minutes
        if enabled_auto_share_recording is not None:
            body.enabled_auto_share_recording = enabled_auto_share_recording
        if enabled_webex_assistant_by_default is not None:
            body.enabled_webex_assistant_by_default = enabled_webex_assistant_by_default
        url = self.ep('schedulingOptions')
        data = super().put(url=url, params=params, data=body.json())
        return SchedulingOptionsObject.parse_obj(data)

    def site_list(self, user_email: str = None) -> list[Sites]:
        """
        Retrieves the list of Webex sites that the authenticated user is set up to use.

        :param user_email: Email address for the user. This parameter is only used if the user or application calling
            the API has the admin-level scopes. If set, the admin may specify the email of a user and the API will
            return the list of Webex sites for that user.
        :type user_email: str

        documentation: https://developer.webex.com/docs/api/v1/meeting-preferences/get-site-list
        """
        params = {}
        if user_email is not None:
            params['userEmail'] = user_email
        url = self.ep('sites')
        data = super().get(url=url, params=params)
        return parse_obj_as(list[Sites], data["sites"])

    def update_default_site(self, default_site: bool, site_url: str, user_email: str = None) -> Sites:
        """
        Updates the default site for the authenticated user.

        :param default_site: Whether or not to change user's default site. Note: defaultSite should be set to true for
            the user's single default site
        :type default_site: bool
        :param site_url: Access URL for the site.
        :type site_url: str
        :param user_email: Email address for the user. This parameter is only used if the user or application calling
            the API has the admin-level scopes. If set, the admin may specify the email of a user in a site they manage
            and the API will update default site for that user.
        :type user_email: str

        documentation: https://developer.webex.com/docs/api/v1/meeting-preferences/update-default-site
        """
        params = {}
        params['defaultSite'] = str(default_site).lower()
        if user_email is not None:
            params['userEmail'] = user_email
        body = UpdateDefaultSiteBody()
        if site_url is not None:
            body.site_url = site_url
        url = self.ep('sites')
        data = super().put(url=url, params=params, data=body.json())
        return Sites.parse_obj(data)

class AnswerObject(CoHosts):
    #: The ID of the person who answered the question. Only present for authenticated users.
    person_id: Optional[str]
    #: The content of the answer.
    answer: Optional[list[str]]
    #: Whether or not the question was answered.
    answered: Optional[bool]


class Answers(ApiModel):
    #: The pagination links of the question's answers.
    links: Optional[Link]
    #: An array of answer objects for this question.
    items: Optional[list[AnswerObject]]


class QAObject(CoHosts):
    #: A unique identifier for the question.
    id: Optional[str]
    #: A unique identifier for the meeting instance to which the Q&A belongs.
    meeting_id: Optional[str]
    #: The total number of attendees in the meeting.
    total_attendees: Optional[int]
    #: The total number of respondents in the meeting.
    total_respondents: Optional[int]
    #: The question that was asked.
    question: Optional[str]
    #: Question's answers.
    answers: Optional[Answers]


class ListMeetingQAndAResponse(ApiModel):
    #: An array of Q&A objects.
    items: Optional[list[QAObject]]


class ListAnswersOfQuestionResponse(ApiModel):
    #: An array of answers to a specific question.
    items: Optional[list[AnswerObject]]


class MeetingQandAApi(ApiChild, base='meetings/q_and_a'):
    """
    During a Question and Answer (Q&A) session, attendees can pose questions to hosts, co-hosts, and presenters, who
    can answer and moderate those questions. You use the Meeting Q&A API to retrieve the questions and the answers in a
    meeting.
    Currently, these APIs are available to users with one of the meeting host, admin or Compliance Officer roles.
    The features and APIs described here are available upon-request and is not enabled by default. If would like this
    feature enabled for your organization please contact the Webex Developer Support team at devsupport@webex.com.
    """

    def list_meeting_q_and_a(self, meeting_id: str, **params) -> Generator[QAObject, None, None]:
        """
        Lists questions and answers from a meeting, when ready.
        Notes:

        :param meeting_id: A unique identifier for the meeting instance which the Q&A belongs to.
        :type meeting_id: str

        documentation: https://developer.webex.com/docs/api/v1/meeting-q-and-a/list-meeting-q-and-a
        """
        params['meetingId'] = meeting_id
        url = self.ep()
        return self.session.follow_pagination(url=url, model=QAObject, params=params)

    def list_answers_of_question(self, question_id: str, meeting_id: str, **params) -> Generator[AnswerObject, None, None]:
        """
        Lists the answers to a specific question asked in a meeting.

        :param question_id: The ID of a question.
        :type question_id: str
        :param meeting_id: A unique identifier for the meeting instance which the Q&A belongs to.
        :type meeting_id: str

        documentation: https://developer.webex.com/docs/api/v1/meeting-q-and-a/list-answers-of-a-question
        """
        params['meetingId'] = meeting_id
        url = self.ep(f'{question_id}/answers')
        return self.session.follow_pagination(url=url, model=AnswerObject, params=params)

class NetworkType(str, Enum):
    wifi = 'wifi'
    cellular = 'cellular'
    ethernet = 'ethernet'
    unknown = 'unknown'


class TransportType(str, Enum):
    udp = 'UDP'
    tcp = 'TCP'


class VideoIn(ApiModel):
    #: The sampling interval, in seconds, of the downstream video quality data.
    sampling_interval: Optional[int]
    #: The date and time when this video session started.
    start_time: Optional[str]
    #: The date and time when this video session ended.
    end_time: Optional[str]
    #: The percentage of video packet loss, as a float between 0.0 and 100.0, during each sampling interval.
    packet_loss: Optional[list[int]]
    #: The average latency, in milliseconds, during each sampling interval.
    latency: Optional[list[int]]
    #: The pixel height of the incoming video.
    resolution_height: Optional[list[int]]
    #: The frames per second of the incoming video.
    frame_rate: Optional[list[int]]
    #: The bit rate of the incoming video.
    media_bit_rate: Optional[list[int]]
    #: The incoming video codec.
    codec: Optional[str]
    #: The incoming video jitter.
    jitter: Optional[list[int]]
    #: The network protocol used for video transmission.
    transport_type: Optional[TransportType]


class Resources(ApiModel):
    #: The average percent CPU for the process.
    process_average_cpu: Optional[list[int]]
    #: The max percent CPU for the process.
    process_max_cpu: Optional[list[int]]
    #: The average percent CPU for the system.
    system_average_cpu: Optional[list[int]]
    #: The max percent CPU for the system.
    system_max_cpu: Optional[list[int]]


class MediaSessionQuality(ApiModel):
    #: The meeting identifier for the specific meeting instance.
    meeting_instance_id: Optional[str]
    #: The display name of the participant of this media session.
    webex_user_name: Optional[str]
    #: The email address of the participant of this media session.
    webex_user_email: Optional[str]
    #: The date and time when this participant joined the meeting.
    join_time: Optional[str]
    #: The date and time when this participant left the meeting.
    leave_time: Optional[str]
    #: The join meeting time of the participant.
    join_meeting_time: Optional[str]
    #: The type of the client (and OS) used by this media session.
    client_type: Optional[str]
    #: The version of the client used by this media session.
    client_version: Optional[str]
    #: The operating system used for the client.
    os_type: Optional[str]
    #: The version of the operating system used for the client.
    os_version: Optional[str]
    #: The type of hardware used to attend the meeting
    hardware_type: Optional[str]
    #: A description of the speaker used in the meeting.
    speaker_name: Optional[str]
    #: The type of network.
    network_type: Optional[NetworkType]
    #: The local IP address of the client.
    local_ip: Optional[str]
    #: The public IP address of the client.
    public_ip: Optional[str]
    #: The masked local IP address of the client.
    masked_local_ip: Optional[str]
    #: The masked public IP address of the client.
    masked_public_ip: Optional[str]
    #: A description of the camera used in the meeting.
    camera: Optional[str]
    #: A description of the microphone used in the meeting.
    microphone: Optional[str]
    #: The server region.
    server_region: Optional[str]
    #: The video mesh cluster name.
    video_mesh_cluster: Optional[str]
    #: The video mesh server name.
    video_mesh_server: Optional[str]
    #: Identifies the participant.
    participant_id: Optional[str]
    #: Identifies a specific session the participant has in a given meeting.
    participant_session_id: Optional[str]
    #: The collection of downstream (sent to the client) video quality data.
    video_in: Optional[list[VideoIn]]
    #: The collection of upstream (sent from the client) video quality data.
    video_out: Optional[list[VideoIn]]
    #: The collection of downstream (sent to the client) audio quality data.
    audio_in: Optional[list[VideoIn]]
    #: The collection of upstream (sent from the client) audio quality data.
    audio_out: Optional[list[VideoIn]]
    #: The collection of downstream (sent to the client) share quality data.
    share_in: Optional[list[VideoIn]]
    #: The collection of upstream (sent from the client) share quality data.
    share_out: Optional[list[VideoIn]]
    #: Device resources such as CPU and memory.
    resources: Optional[list[Resources]]


class GetMeetingQualitiesResponse(ApiModel):
    items: Optional[list[MediaSessionQuality]]


class MeetingQualitiesApi(ApiChild, base=''):
    """
    To retrieve quality information, you must use an administrator token with the analytics:read_all scope. The
    authenticated user must be a read-only or full administrator of the organization to which the meeting belongs and
    must not be an external administrator.
    To use this endpoint, the org needs to be licensed for the Webex Pro Pack.
    For CI-Native site, no additional settings are required.
    For CI-linked site, the admin must also be set as the Full/ReadOnly Site Admin of the site.
    A minimum Webex and Teams client version is required. For details, see Troubleshooting Help Doc.
    Quality information is available 10 minutes after a meeting has started and may be retrieved for up to 7 days.
    A rate limit of 1 API call every 5 minutes for the same meeting instance ID applies.
    """

    def meeting_qualities(self, meeting_id: str, offset: int = None, **params) -> Generator[MediaSessionQuality, None, None]:
        """
        Get quality data for a meeting, by meetingId. Only organization administrators can retrieve meeting quality
        data.

        :param meeting_id: Unique identifier for the specific meeting instance. Note: The meetingId can be obtained via
            the Meeting List API when meetingType=meeting. The id attribute in the Meeting List Response is what is
            needed, for example, e5dba9613a9d455aa49f6ffdafb6e7db_I_191395283063545470.
        :type meeting_id: str
        :param offset: Offset from the first result that you want to fetch.
        :type offset: int

        documentation: https://developer.webex.com/docs/api/v1/meeting-qualities/get-meeting-qualities
        """
        params['meetingId'] = meeting_id
        if offset is not None:
            params['offset'] = offset
        url = self.ep('https://analytics.webexapis.com/v1/meeting/qualities')
        return self.session.follow_pagination(url=url, model=MediaSessionQuality, params=params)

class Status7(str, Enum):
    #: Transcript is available.
    available = 'available'
    #: Transcript has been deleted.
    deleted = 'deleted'


class TranscriptObject(ApiModel):
    #: A unique identifier for the transcript.
    id: Optional[str]
    #: URL of the Webex site from which the API lists meeting transcripts.
    site_url: Optional[str]
    #: Start time for the meeting transcript in ISO 8601 compliant format.
    start_time: Optional[str]
    #: The meeting's topic.
    meeting_topic: Optional[str]
    #: Unique identifier for the meeting instance to which the transcripts belong.
    meeting_id: Optional[str]
    #: Unique identifier for scheduled meeting with which the current meeting is associated. Only apples to a meeting
    #: instance which is happening or has happened. This is the id of the scheduled meeting with which the instance is
    #: associated.
    scheduled_meeting_id: Optional[str]
    #: Unique identifier for the parent meeting series to which the recording belongs.
    meeting_series_id: Optional[str]
    #: Unique identifier for the meeting host.
    host_user_id: Optional[str]
    #: The download link for the transcript vtt file.
    vtt_download_link: Optional[str]
    #: The download link for the transcript txt file.
    txt_download_link: Optional[str]
    status: Optional[Status7]


class ListMeetingTranscriptsResponse(ApiModel):
    #: Transcript array.
    items: Optional[list[TranscriptObject]]


class ListMeetingTranscriptsForComplianceOfficerResponse(ApiModel):
    #: Transcript array
    items: Optional[list[TranscriptObject]]


class ListSnippetsOfMeetingTranscriptResponse(ApiModel):
    #: Transcript snippet array
    items: Optional[list[SnippetObject1]]


class UpdateTranscriptSnippetBody(ApiModel):
    #: Reason for snippet update; only required for Compliance Officers.
    reason: Optional[str]
    #: Text for the snippet.
    text: Optional[str]


class DeleteTranscriptBody(ApiModel):
    #: Reason for deleting a transcript. Only required when a Compliance Officer is operating on another user's
    #: transcript.
    reason: Optional[str]
    #: Explanation for deleting a transcript. The comment can be a maximum of 255 characters long.
    comment: Optional[str]


class MeetingTranscriptsApi(ApiChild, base=''):
    """
    Not supported for Webex for Government (FedRAMP)
    A meeting transcript is the automatic transcription of a meeting's recordings by our industry-leading
    speech-to-text engine to capture of what was discussed and decided during the meeting, in text form.
    A transcript snippet is a short text snippet from a meeting transcript which was spoken by a particular participant
    in the meeting. A meeting transcript consists of many snippets.
    This API manages meeting transcripts and snippets. You can use the Transcript API to list meeting transcripts,
    list, get and update transcript snippets. Transcripts may be retrieved via download link defined by vttDownloadLink
    or txtDownloadlink in the response body.
    Refer to the Meetings API Scopes section of Meetings Overview for scopes required for each API.
    NOTE:
    """

    def list_meeting(self, meeting_id: str = None, host_email: str = None, site_url: str = None, from_: str = None, to_: str = None, **params) -> Generator[TranscriptObject, None, None]:
        """
        Lists available transcripts of an ended meeting instance.
        Use this operation to list transcripts of an ended meeting instance when they are ready. Please note that only
        meeting instances in state ended are supported for meetingId. Meeting series, scheduled meetings and
        in-progress meeting instances are not supported.

        :param meeting_id: Unique identifier for the meeting instance to which the transcript belongs. Please note that
            currently the meeting ID of a scheduled personal room meeting is not supported for this API. If meetingId
            is not specified, the operation returns an array of transcripts for all meetings of the current user.
        :type meeting_id: str
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin-level scopes. If set, the admin may specify the email of a user in a site
            they manage and the API will return details for a meeting that is hosted by that user. If meetingId is not
            specified, it can not support hostEmail.
        :type host_email: str
        :param site_url: URL of the Webex site from which the API lists transcripts. If not specified, the API lists
            transcripts from user's preferred site. All available Webex sites and the preferred site of the user can be
            retrieved by the Get Site List API.
        :type site_url: str
        :param from_: Starting date and time (inclusive) for transcripts to return, in any ISO 8601 compliant format.
            from cannot be after to.
        :type from_: str
        :param to_: Ending date and time (exclusive) for List transcripts to return, in any ISO 8601 compliant format.
            to cannot be before from.
        :type to_: str

        documentation: https://developer.webex.com/docs/api/v1/meeting-transcripts/list-meeting-transcripts
        """
        if meeting_id is not None:
            params['meetingId'] = meeting_id
        if host_email is not None:
            params['hostEmail'] = host_email
        if site_url is not None:
            params['siteUrl'] = site_url
        if from_ is not None:
            params['from'] = from_
        if to_ is not None:
            params['to'] = to_
        url = self.ep('meetingTranscripts')
        return self.session.follow_pagination(url=url, model=TranscriptObject, params=params)

    def list_meeting_for_compliance_officer(self, site_url: str, from_: str = None, to_: str = None, **params) -> Generator[TranscriptObject, None, None]:
        """
        Lists available or deleted transcripts of an ended meeting instance for a specific site.
        The returned list is sorted in descending order by the date and time that the transcript was created.

        :param site_url: URL of the Webex site from which the API lists transcripts.
        :type site_url: str
        :param from_: Starting date and time (inclusive) for transcripts to return, in any ISO 8601 compliant format.
            from cannot be after to.
        :type from_: str
        :param to_: Ending date and time (exclusive) for List transcripts to return, in any ISO 8601 compliant format.
            to cannot be before from.
        :type to_: str

        documentation: https://developer.webex.com/docs/api/v1/meeting-transcripts/list-meeting-transcripts-for-compliance-officer
        """
        params['siteUrl'] = site_url
        if from_ is not None:
            params['from'] = from_
        if to_ is not None:
            params['to'] = to_
        url = self.ep('admin/meetingTranscripts')
        return self.session.follow_pagination(url=url, model=TranscriptObject, params=params)

    def download_meeting(self, transcript_id: str, format: str = None, host_email: str = None):
        """
        Download a meeting transcript from the meeting transcript specified by transcriptId.

        :param transcript_id: Unique identifier for the meeting transcript.
        :type transcript_id: str
        :param format: Format for the downloaded meeting transcript. Possible values: vtt, txt
        :type format: str
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin-level scopes. If set, the admin may specify the email of a user in a site
            they manage and the API will return details for a meeting that is hosted by that user.
        :type host_email: str

        documentation: https://developer.webex.com/docs/api/v1/meeting-transcripts/download-a-meeting-transcript
        """
        params = {}
        if format is not None:
            params['format'] = format
        if host_email is not None:
            params['hostEmail'] = host_email
        url = self.ep(f'meetingTranscripts/{transcript_id}/download')
        super().get(url=url, params=params)
        return $!$!$!   # this is weird. Check the spec at https://developer.webex.com/docs/api/v1/meeting-transcripts/download-a-meeting-transcript

    def list_snippets_of_meeting(self, transcript_id: str, **params) -> Generator[SnippetObject1, None, None]:
        """
        Lists snippets of a meeting transcript specified by transcriptId.
        Use this operation to list snippets of a meeting transcript when they are ready.

        :param transcript_id: Unique identifier for the meeting transcript to which the snippets belong.
        :type transcript_id: str

        documentation: https://developer.webex.com/docs/api/v1/meeting-transcripts/list-snippets-of-a-meeting-transcript
        """
        url = self.ep(f'meetingTranscripts/{transcript_id}/snippets')
        return self.session.follow_pagination(url=url, model=SnippetObject1, params=params)

    def snippet(self, transcript_id: str, snippet_id: str) -> SnippetObject1:
        """
        Retrieves details for a transcript snippet specified by snippetId from the meeting transcript specified by
        transcriptId.

        :param transcript_id: Unique identifier for the meeting transcript to which the requested snippet belongs.
        :type transcript_id: str
        :param snippet_id: Unique identifier for the snippet being requested.
        :type snippet_id: str

        documentation: https://developer.webex.com/docs/api/v1/meeting-transcripts/get-a-transcript-snippet
        """
        url = self.ep(f'meetingTranscripts/{transcript_id}/snippets/{snippet_id}')
        data = super().get(url=url)
        return SnippetObject1.parse_obj(data)

    def update_snippet(self, transcript_id: str, snippet_id: str, text: str, reason: str = None) -> SnippetObject1:
        """
        Updates details for a transcript snippet specified by snippetId from the meeting transcript specified by
        transcriptId.

        :param transcript_id: Unique identifier for the meeting transcript to which the snippet to be updated belongs.
        :type transcript_id: str
        :param snippet_id: Unique identifier for the snippet being updated.
        :type snippet_id: str
        :param text: Text for the snippet.
        :type text: str
        :param reason: Reason for snippet update; only required for Compliance Officers.
        :type reason: str

        documentation: https://developer.webex.com/docs/api/v1/meeting-transcripts/update-a-transcript-snippet
        """
        body = UpdateTranscriptSnippetBody()
        if text is not None:
            body.text = text
        if reason is not None:
            body.reason = reason
        url = self.ep(f'meetingTranscripts/{transcript_id}/snippets/{snippet_id}')
        data = super().put(url=url, data=body.json())
        return SnippetObject1.parse_obj(data)

    def delete(self, transcript_id: str, reason: str = None, comment: str = None):
        """
        Removes a transcript with a specified transcript ID. The deleted transcript cannot be recovered. If a
        Compliance Officer deletes another user's transcript, the transcript will be inaccessible to regular users
        (host, attendees), but will be still available to the Compliance Officer.

        :param transcript_id: Unique identifier for the meeting transcript.
        :type transcript_id: str
        :param reason: Reason for deleting a transcript. Only required when a Compliance Officer is operating on
            another user's transcript.
        :type reason: str
        :param comment: Explanation for deleting a transcript. The comment can be a maximum of 255 characters long.
        :type comment: str

        documentation: https://developer.webex.com/docs/api/v1/meeting-transcripts/delete-a-transcript
        """
        body = DeleteTranscriptBody()
        if reason is not None:
            body.reason = reason
        if comment is not None:
            body.comment = comment
        url = self.ep(f'meetingTranscripts/{transcript_id}')
        super().delete(url=url, data=body.json())
        return

class TemplateType(str, Enum):
    #: Webex meeting.
    meeting = 'meeting'
    #: Webex webinar.
    webinar = 'webinar'


class ScheduledType(TemplateType):
    #: Set the value of scheduledType attribute to personalRoomMeeting for creating a meeting in the user's personal
    #: room. Please note that templateId, roomId, integrationTags, enabledWebcastView, enabledAutoRecordMeeting and
    #: registration are not supported when creating a personal room meeting.
    personal_room_meeting = 'personalRoomMeeting'


class InviteeObjectForCreateMeeting(CoHosts):
    #: Whether or not invitee is allowed to be a cohost for the meeting. coHost for each invitee is true by default if
    #: roomId is specified when creating a meeting, and anyone in the invitee list that is not qualified to be a cohost
    #: will be invited as a non-cohost invitee.
    co_host: Optional[bool]
    #: Whether or not an invitee is allowed to be a panelist. Only applies to webinars.
    panelist: Optional[bool]


class Type3(str, Enum):
    #: Single line text box.
    single_line_text_box = 'singleLineTextBox'
    #: Multiple line text box.
    multi_line_text_box = 'multiLineTextBox'
    #: Check box which requires options.
    checkbox = 'checkbox'
    #: Drop down list box which requires options.
    dropdown_list = 'dropdownList'
    #: Single radio button which requires options.
    radio_buttons = 'radioButtons'


class Condition(str, Enum):
    #: The content of the answer contains the value.
    contains = 'contains'
    #: The content of the answer does not contain the value
    not_contains = 'notContains'
    #: The content of the answer begins with the value.
    begins_with = 'beginsWith'
    #: The content of the answer ends with the value.
    ends_with = 'endsWith'
    #: The content of the answer is the same as the value.
    equals = 'equals'
    #: The content of the answer is not the same as the value.
    not_equals = 'notEquals'


class Result(str, Enum):
    #: If the user's registration value meets the criteria, the registration form will be automatically approved.
    approve = 'approve'
    #: If the user's registration value meets the criteria, the registration form will be automatically rejected.
    reject = 'reject'


class Rules(ApiModel):
    #: Judgment expression for approval rules.
    condition: Optional[Condition]
    #: The keyword for the approval rule. If the rule matches the keyword, the corresponding action will be executed.
    value: Optional[str]
    #: The automatic approval result for the approval rule.
    result: Optional[Result]
    #: Whether to check the case of values.
    match_case: Optional[bool]


class CustomizedQuestionForCreateMeeting(ApiModel):
    #: Title of the customized question.
    question: Optional[str]
    #: Whether or not the customized question is required to be answered by participants.
    required: Optional[bool]
    #: Type of the question being asked.
    type: Optional[Type3]
    #: The maximum length of a string that can be entered by the user, ranging from 0 to 999. Only required by
    #: singleLineTextBox and multiLineTextBox.
    max_length: Optional[int]
    #: The content of options. Required if the question type is one of checkbox, dropdownList, or radioButtons.
    #: The content of the option.
    options: Optional[list[object]]
    #: The automatic approval rules for customized questions.
    rules: Optional[list[Rules]]


class Question1(str, Enum):
    #: If the value is lastName, this approval rule applies to the standard question of "Last Name".
    last_name = 'lastName'
    #: If the value is email, this approval rule applies to the standard question of "Email".
    email = 'email'
    #: If the value is jobTitle, this approval rule applies to the standard question of "Job Title".
    job_title = 'jobTitle'
    #: If the value is companyName, this approval rule applies to the standard question of "Company Name".
    company_name = 'companyName'
    #: If the value is address1, this approval rule applies to the standard question of "Address 1".
    address1 = 'address1'
    #: If the value is address2, this approval rule applies to the standard question of "Address 2".
    address2 = 'address2'
    #: If the value is city, this approval rule applies to the standard question of "City".
    city = 'city'
    #: If the value is state, this approval rule applies to the standard question of "State".
    state = 'state'
    #: If the value is zipCode, this approval rule applies to the standard question of "Zip/Post Code".
    zip_code = 'zipCode'
    #: If the value is countryRegion, this approval rule applies to the standard question of "Country Region".
    country_region = 'countryRegion'
    #: If the value is workPhone, this approval rule applies to the standard question of "Work Phone".
    work_phone = 'workPhone'
    #: If the value is fax, this approval rule applies to the standard question of "Fax".
    fax = 'fax'


class StandardRegistrationApproveRule(Rules):
    #: Name for standard question.
    question: Optional[Question1]
    #: The priority number of the approval rule. Approval rules for standard questions and custom questions need to be
    #: ordered together.
    order: Optional[int]


class Registration1(ApiModel):
    #: Whether or not meeting registration requests are accepted automatically.
    auto_accept_request: Optional[bool]
    #: Whether or not a registrant's first name is required for meeting registration.
    require_first_name: Optional[bool]
    #: Whether or not a registrant's last name is required for meeting registration.
    require_last_name: Optional[bool]
    #: Whether or not a registrant's email is required for meeting registration.
    require_email: Optional[bool]
    #: Whether or not a registrant's job title is required for meeting registration.
    require_job_title: Optional[bool]
    #: Whether or not a registrant's company name is required for meeting registration.
    require_company_name: Optional[bool]
    #: Whether or not a registrant's first address field is required for meeting registration.
    require_address1: Optional[bool]
    #: Whether or not a registrant's second address field is required for meeting registration.
    require_address2: Optional[bool]
    #: Whether or not a registrant's city is required for meeting registration.
    require_city: Optional[bool]
    #: Whether or not a registrant's state is required for meeting registration.
    require_state: Optional[bool]
    #: Whether or not a registrant's postal code is required for meeting registration.
    require_zip_code: Optional[bool]
    #: Whether or not a registrant's country or region is required for meeting registration.
    require_country_region: Optional[bool]
    #: Whether or not a registrant's work phone number is required for meeting registration.
    require_work_phone: Optional[bool]
    #: Whether or not a registrant's fax number is required for meeting registration.
    require_fax: Optional[bool]
    #: Maximum number of meeting registrations. This only applies to meetings. The maximum number of participants for
    #: meetings and webinars, with the limit based on the user capacity and controlled by a toggle at the site level.
    #: The default maximum number of participants for webinars is 10000, but the actual maximum number of participants
    #: is limited by the user capacity.
    max_register_num: Optional[int]


class Registration(Registration1):
    #: Customized questions for meeting registration.
    customized_questions: Optional[list[CustomizedQuestionForCreateMeeting]]
    #: The approval rules for standard questions.
    rules: Optional[list[StandardRegistrationApproveRule]]


class InterpreterObjectForSimultaneousInterpretationOfCreateOrUpdateMeeting(CoHosts):
    #: Forms a set of simultaneous interpretation channels together with languageCode2. Standard language format from
    #: ISO 639-1 code. Read ISO 639-1 for details.
    language_code1: Optional[str]
    #: Forms a set of simultaneous interpretation channels together with languageCode1. Standard language format from
    #: ISO 639-1 code. Read ISO 639-1 for details.
    language_code2: Optional[str]


class SimultaneousInterpretation(ApiModel):
    #: Whether or not simultaneous interpretation is enabled.
    enabled: Optional[bool]
    #: Interpreters for meeting.
    interpreters: Optional[list[InterpreterObjectForSimultaneousInterpretationOfCreateOrUpdateMeeting]]


class BreakoutSessionObject(ApiModel):
    #: Name for breakout session.
    name: Optional[str]
    #: Invitees for breakout session. Please note that one invitee cannot be assigned to more than one breakout
    #: session.
    invitees: Optional[list[str]]


class UnlockedMeetingJoinSecurity(str, Enum):
    #: If the value of unlockedMeetingJoinSecurity attribute is allowJoin, people can join the unlocked meeting
    #: directly.
    allow_join = 'allowJoin'
    #: If the value of unlockedMeetingJoinSecurity attribute is allowJoinWithLobby, people will wait in the lobby until
    #: the host admits them.
    allow_join_with_lobby = 'allowJoinWithLobby'
    #: If the value of unlockedMeetingJoinSecurity attribute is blockFromJoin, people can't join the unlocked meeting.
    block_from_join = 'blockFromJoin'


class NoteType(str, Enum):
    #: If the value of noteType attribute is allowAll, all participants can take notes.
    allow_all = 'allowAll'
    #: If the value of noteType attribute is allowOne, only a single note taker is allowed.
    allow_one = 'allowOne'


class MeetingOptions(ApiModel):
    #: Whether or not to allow any attendee to chat in the meeting. Also depends on the session type.
    enabled_chat: Optional[bool]
    #: Whether or not to allow any attendee to have video in the meeting. Also depends on the session type.
    enabled_video: Optional[bool]
    #: Whether or not to allow any attendee to poll in the meeting. Can only be set true for a webinar. The value of
    #: this attribute depends on the session type for a meeting. Please contact your site admin if this attribute is
    #: not available.
    enabled_polling: Optional[bool]
    #: Whether or not to allow any attendee to take notes in the meeting. The value of this attribute also depends on
    #: the session type.
    enabled_note: Optional[bool]
    #: Whether note taking is enabled. If the value of enabledNote is false, users can not set this attribute and get
    #: default value allowAll.
    note_type: Optional[NoteType]
    #: Whether or not to allow any attendee to have closed captions in the meeting. The value of this attribute also
    #: depends on the session type.
    enabled_closed_captions: Optional[bool]
    #: Whether or not to allow any attendee to transfer files in the meeting. The value of this attribute also depends
    #: on the session type.
    enabled_file_transfer: Optional[bool]
    #: Whether or not to allow any attendee to share Universal Communications Format media files in the meeting. The
    #: value of this attribute also depends on the sessionType.
    enabled_ucf_rich_media: Optional[bool]


class AttendeePrivileges(ApiModel):
    #: Whether or not to allow any attendee to share content in the meeting.
    enabled_share_content: Optional[bool]
    #: Whether or not to allow any attendee to save shared documents, slides, or whiteboards when they are shared as
    #: files in the content viewer instead of in a window or application.
    enabled_save_document: Optional[bool]
    #: Whether or not to allow any attendee to print shared documents, slides, or whiteboards when they are shared as
    #: files in the content viewer instead of in a window or application.
    enabled_print_document: Optional[bool]
    #: Whether or not to allow any attendee to annotate shared documents, slides, or whiteboards when they are shared
    #: as files in the content viewer instead of in a window or application.
    enabled_annotate: Optional[bool]
    #: Whether or not to allow any attendee to view participants.
    enabled_view_participant_list: Optional[bool]
    #: Whether or not to allow any attendee to see a small preview image of any page of shared documents or slides when
    #: they are shared as files in the content viewer instead of in a window or application.
    enabled_view_thumbnails: Optional[bool]
    #: Whether or not to allow any attendee to control applications, web browsers, or desktops remotely.
    enabled_remote_control: Optional[bool]
    #: Whether or not to allow any attendee to view any shared documents or slides when they are shared as files in the
    #: content viewer instead of in a window or application.
    enabled_view_any_document: Optional[bool]
    #: Whether or not to allow any attendee to scroll through any page of shared documents or slides when they are
    #: shared as files in the content viewer instead of in a window or application.
    enabled_view_any_page: Optional[bool]
    #: Whether or not to allow any attendee to contact the operator privately.
    enabled_contact_operator_privately: Optional[bool]
    #: Whether or not to allow any attendee to chat with the host in private.
    enabled_chat_host: Optional[bool]
    #: Whether or not to allow any attendee to chat with the presenter in private.
    enabled_chat_presenter: Optional[bool]
    #: Whether or not to allow any attendee to chat with other participants in private.
    enabled_chat_other_participants: Optional[bool]


class TrackingCodeItemForCreateMeetingObject(ApiModel):
    #: Name of the tracking code. The name cannot be empty and the maximum size is 120 characters.
    name: Optional[str]
    #: Value for the tracking code. value cannot be empty and the maximum size is 120 characters.
    value: Optional[str]


class AudioConnectionType(str, Enum):
    #: Provide a hybrid audio option, allowing attendees to join using their computer audio or a phone.
    webex_audio = 'webexAudio'
    #: Only restricts attendees to join the audio portion of the meeting using their computer instead of a telephone
    #: option.
    vo_ip = 'VoIP'
    #: Other teleconference services.
    other = 'other'
    #: The way of attendees join the audio portion of the meeting is the default value.
    none = 'none'


class EntryAndExitTone(str, Enum):
    #: All call-in users joining the meeting will hear the beep.
    beep = 'beep'
    #: All call-in users joining the meeting will hear their names.
    announce_name = 'announceName'
    #: Turn off beeps and name announcements.
    no_tone = 'noTone'


class AudioConnectionOptions(ApiModel):
    #: Choose how meeting attendees join the audio portion of the meeting.
    audio_connection_type: Optional[AudioConnectionType]
    #: Whether or not to show toll-free call-in numbers.
    enabled_toll_free_call_in: Optional[bool]
    #: Whether or not to show global call-in numbers to attendees.
    enabled_global_call_in: Optional[bool]
    #: Whether or not to allow attendees to receive a call-back and call-in is available. Can only be set true for a
    #: webinar.
    enabled_audience_call_back: Optional[bool]
    #: Select the sound you want users who have a phone audio connection to hear when someone enters or exits the
    #: meeting.
    entry_and_exit_tone: Optional[EntryAndExitTone]
    #: Whether or not to allow the host to unmute participants.
    allow_host_to_unmute_participants: Optional[bool]
    #: Whether or not to allow attendees to unmute themselves.
    allow_attendee_to_unmute_self: Optional[bool]
    #: Whether or not to auto-mute attendees when attendees enter meetings.
    mute_attendee_upon_entry: Optional[bool]


class PatchMeetingBody(ApiModel):
    #: Meeting title. The title can be a maximum of 128 characters long.
    title: Optional[str]
    #: Meeting agenda. The agenda can be a maximum of 1300 characters long.
    agenda: Optional[str]
    #: Meeting password. Must conform to the site's password complexity settings. Read password management for details.
    password: Optional[str]
    #: Date and time for the start of meeting in any ISO 8601 compliant format. start cannot be before current date and
    #: time or after end. Duration between start and end cannot be shorter than 10 minutes or longer than 24 hours.
    #: Refer to the Webex Meetings guide for more information about restrictions on updating date and time for a
    #: meeting. Please note that when a meeting is being updated, start of the meeting will be accurate to minutes, not
    #: seconds or milliseconds. Therefore, if start is within the same minute as the current time, start will be
    #: adjusted to the upcoming minute; otherwise, start will be adjusted with seconds and milliseconds stripped off.
    #: For instance, if the current time is 2022-03-01T10:32:16.657+08:00, start of 2022-03-01T10:32:28.076+08:00 or
    #: 2022-03-01T10:32:41+08:00 will be adjusted to 2022-03-01T10:33:00+08:00, and start of
    #: 2022-03-01T11:32:28.076+08:00 or 2022-03-01T11:32:41+08:00 will be adjusted to 2022-03-01T11:32:00+08:00.
    start: Optional[str]
    #: Date and time for the end of meeting in any ISO 8601 compliant format. end cannot be before current date and
    #: time or before start. Duration between start and end cannot be shorter than 10 minutes or longer than 24 hours.
    #: Refer to the Webex Meetings guide for more information about restrictions on updating date and time for a
    #: meeting. Please note that when a meeting is being updated, end of the meeting will be accurate to minutes, not
    #: seconds or milliseconds. Therefore, end will be adjusted with seconds and milliseconds stripped off. For
    #: instance, end of 2022-03-01T11:52:28.076+08:00 or 2022-03-01T11:52:41+08:00 will be adjusted to
    #: 2022-03-01T11:52:00+08:00.
    end: Optional[str]
    #: Time zone in which the meeting was originally scheduled (conforming with the IANA time zone database).
    timezone: Optional[str]
    #: Meeting series recurrence rule (conforming with RFC 2445). Applies only to a recurring meeting series, not to a
    #: meeting series with only one scheduled meeting. Multiple days or dates for monthly or yearly recurrence rule are
    #: not supported, only the first day or date specified is taken. For example,
    #: "FREQ=MONTHLY;INTERVAL=1;COUNT=10;BYMONTHDAY=10,11,12" is not supported and it will be partially supported as
    #: "FREQ=MONTHLY;INTERVAL=1;COUNT=10;BYMONTHDAY=10".
    recurrence: Optional[str]
    #: Whether or not meeting is recorded automatically.
    enabled_auto_record_meeting: Optional[bool]
    #: Whether or not to allow any attendee with a host account on the target site to become a cohost when joining the
    #: meeting. The target site is specified by siteUrl parameter when creating the meeting; if not specified, it's
    #: user's preferred site.
    allow_any_user_to_be_co_host: Optional[bool]
    #: Whether or not to allow any attendee to join the meeting before the host joins the meeting.
    enabled_join_before_host: Optional[bool]
    #: Whether or not to allow any attendee to connect audio in the meeting before the host joins the meeting. This
    #: attribute is only applicable if the enabledJoinBeforeHost attribute is set to true.
    enable_connect_audio_before_host: Optional[bool]
    #: The number of minutes an attendee can join the meeting before the meeting start time and the host joins. This
    #: attribute is only applicable if the enabledJoinBeforeHost attribute is set to true. Valid options are 0, 5, 10
    #: and 15. Default is 0 if not specified.
    join_before_host_minutes: Optional[int]
    #: Whether or not to exclude the meeting password from the email invitation.
    exclude_password: Optional[bool]
    #: Whether or not to allow the meeting to be listed on the public calendar.
    public_meeting: Optional[bool]
    #: The number of minutes before the meeting begins, that an email reminder is sent to the host.
    reminder_time: Optional[int]
    #: Specifies how the people who aren't on the invite can join the unlocked meeting.
    unlocked_meeting_join_security: Optional[UnlockedMeetingJoinSecurity]
    #: Unique identifier for a meeting session type for the user. This attribute is required while scheduling webinar
    #: meeting. All available meeting session types enabled for the user can be retrieved by List Meeting Session Types
    #: API.
    session_type_id: Optional[int]
    #: Whether or not webcast view is enabled.
    enabled_webcast_view: Optional[bool]
    #: Password for panelists of a webinar meeting. Must conform to the site's password complexity settings. Read
    #: password management for details. If not specified, a random password conforming to the site's password rules
    #: will be generated automatically.
    panelist_password: Optional[str]
    #: Whether or not to automatically lock the meeting after it starts.
    enable_automatic_lock: Optional[bool]
    #: The number of minutes after the meeting begins, for automatically locking it.
    automatic_lock_minutes: Optional[int]
    #: Whether or not to allow the first attendee of the meeting with a host account on the target site to become a
    #: cohost. The target site is specified by siteUrl parameter when creating the meeting; if not specified, it's
    #: user's preferred site.
    allow_first_user_to_be_co_host: Optional[bool]
    #: Whether or not to allow authenticated video devices in the meeting's organization to start or join the meeting
    #: without a prompt.
    allow_authenticated_devices: Optional[bool]
    #: Whether or not to send emails to host and invitees. It is an optional field and default value is true.
    send_email: Optional[bool]
    #: Email address for the meeting host. This attribute should only be set if the user or application calling the API
    #: has the admin-level scopes. When used, the admin may specify the email of a user in a site they manage to be the
    #: meeting host.
    host_email: Optional[str]
    #: URL of the Webex site which the meeting is updated on. If not specified, the meeting is created on user's
    #: preferred site. All available Webex sites and preferred site of the user can be retrieved by Get Site List API.
    site_url: Optional[str]
    #: Meeting Options.
    meeting_options: Optional[MeetingOptions]
    #: Attendee Privileges.
    attendee_privileges: Optional[AttendeePrivileges]
    #: External keys created by an integration application in its own domain, for example Zendesk ticket IDs, Jira IDs,
    #: Salesforce Opportunity IDs, etc. The integration application queries meetings by a key in its own domain. The
    #: maximum size of integrationTags is 3 and each item of integrationTags can be a maximum of 64 characters long.
    #: Please note that an empty or null integrationTags will delete all existing integration tags for the meeting
    #: implicitly. Developer can update integration tags for a meetingSeries but he cannot update it for a
    #: scheduledMeeting or a meeting instance.
    integration_tags: Optional[list[str]]
    #: Whether or not breakout sessions are enabled. If the value of enabledBreakoutSessions is false, users can not
    #: set breakout sessions. If the value of enabledBreakoutSessions is true, users can update breakout sessions using
    #: the Update Breakout Sessions API. Updating breakout sessions are not supported by this API.
    enabled_breakout_sessions: Optional[bool]
    #: Tracking codes information. All available tracking codes and their options for the specified site can be
    #: retrieved by List Meeting Tracking Codes API. If an optional tracking code is missing from the trackingCodes
    #: array and there's a default option for this tracking code, the default option is assigned automatically. If the
    #: inputMode of a tracking code is select, its value must be one of the site-level options or the user-level value.
    #: Tracking code is not supported for a personal room meeting or an ad-hoc space meeting.
    tracking_codes: Optional[list[TrackingCodeItemForCreateMeetingObject]]
    #: Audio connection options.
    audio_connection_options: Optional[AudioConnectionOptions]


class MeetingType(str, Enum):
    #: Primary instance of a scheduled series of meetings which consists of one or more scheduled meetings based on a
    #: recurrence rule. When a non-recurring meeting is scheduled with no recurrence, its meetingType is also
    #: meetingSeries which is a meeting series with only one occurrence in Webex meeting modeling.
    meeting_series = 'meetingSeries'
    #: Instance from a primary meeting series.
    scheduled_meeting = 'scheduledMeeting'
    #: Meeting instance that is in progress or has completed.
    meeting = 'meeting'


class State4(str, Enum):
    #: Only applies to a meeting series. Indicates that one or more future scheduled meetings exist for this meeting
    #: series.
    active = 'active'
    #: Only applies to scheduled meeting. Indicates that the meeting is scheduled in the future.
    scheduled = 'scheduled'
    #: Only applies to scheduled meeting. Indicates that this scheduled meeting is ready to start or join immediately.
    ready = 'ready'
    #: Only applies to meeting instances. Indicates that a locked meeting has been joined by participants, but no hosts
    #: have joined.
    lobby = 'lobby'
    #: Applies to meeting series and meeting instances. For a meeting series, indicates that an instance of this series
    #: is happening now. For a meeting instance, indicates that the meeting has been joined and unlocked.
    in_progress = 'inProgress'
    #: Applies to scheduled meetings and meeting instances. For scheduled meetings, indicates that the meeting was
    #: started and is now over. For meeting instances, indicates that the meeting instance has concluded.
    ended = 'ended'
    #: This state only applies to scheduled meetings. Indicates that the meeting was scheduled in the past but never
    #: happened.
    missed = 'missed'
    #: This state only applies to a meeting series. Indicates that all scheduled meetings of this series have passed.
    expired = 'expired'


class InterpreterObjectForSimultaneousInterpretationOfGetOrListMeeting(InterpreterObjectForSimultaneousInterpretationOfCreateOrUpdateMeeting):
    #: Unique identifier for meeting interpreter.
    id: Optional[str]


class SimultaneousInterpretation1(ApiModel):
    #: Whether or not simultaneous interpretation is enabled.
    enabled: Optional[bool]
    #: Interpreters for meeting.
    interpreters: Optional[list[InterpreterObjectForSimultaneousInterpretationOfGetOrListMeeting]]


class MeetingSeriesObjectForListMeeting(ApiModel):
    #: Unique identifier for meeting. For a meeting series, the id is used to identify the entire series. For scheduled
    #: meetings from a series, the id is used to identify that scheduled meeting. For a meeting instance that is in
    #: progress or has concluded, the id is used to identify that instance.
    id: Optional[str]
    #: Meeting number. Applies to meeting series, scheduled meeting, and meeting instances, but not to meeting
    #: instances which have ended.
    meeting_number: Optional[str]
    #: Meeting title. Can be modified for a meeting series or a scheduled meeting using the Update a Meeting API.
    title: Optional[str]
    #: Meeting agenda. The agenda can be a maximum of 1300 characters long. This attribute can be modified for a
    #: meeting series or a scheduled meeting using the Update a Meeting API.
    agenda: Optional[str]
    #: Meeting password. Applies to meeting series, scheduled meetings, and in-progress meeting instances, but not to
    #: meeting instances which have ended. Can be modified for a meeting series or a scheduled meeting using the Update
    #: a Meeting API.
    password: Optional[str]
    #: 8-digit numeric password used to join a meeting from audio and video devices. This attribute applies to meeting
    #: series, scheduled meetings, and in-progress meeting instances, but not to meeting instances which have ended.
    phone_and_video_system_password: Optional[str]
    #: Meeting type.
    meeting_type: Optional[MeetingType]
    #: Meeting state.
    state: Optional[State4]
    #: Time zone of start and end, conforming with the IANA time zone database.
    timezone: Optional[str]
    #: Start time for meeting in ISO 8601 compliant format. If the meetingType of a meeting is meetingSeries, start is
    #: the scheduled start time of the first occurrence of this series. If the meeting is a meeting series and the
    #: current filter is true, start is the date and time the upcoming or ongoing meeting of the series starts. If the
    #: meetingType of a meeting is scheduledMeeting, start is the scheduled start time of this occurrence. If the
    #: meetingType of a meeting is meeting, start is the actual start time of the meeting instance. Can be modified for
    #: a meeting series or a scheduled meeting using the Update a Meeting API.
    start: Optional[str]
    #: End time for a meeting in ISO 8601 compliant format. If the meetingType of a meeting is meetingSeries, end is
    #: the scheduled end time of the first occurrence of this series. If the meeting is a meeting series and the
    #: current filter is true, end is the date and time the upcoming or ongoing meeting of the series ends. If the
    #: meetingType of a meeting is scheduledMeeting, end is the scheduled end time of this occurrence. If the
    #: meetingType of a meeting is meeting, end is the actual end time of the meeting instance. If a meeting instance
    #: is in progress, end is not available. Can be modified for a meeting series or a scheduled meeting using the
    #: Update a Meeting API.
    end: Optional[str]
    #: Meeting series recurrence rule (conforming with RFC 2445). Applies only to a recurring meeting series, not to a
    #: meeting series with only one scheduled meeting. Can be modified for a meeting series using the Update a Meeting
    #: API. Multiple days or dates for monthly or yearly recurrence rule are not supported, only the first day or date
    #: specified is taken. For example, "FREQ=MONTHLY;INTERVAL=1;COUNT=10;BYMONTHDAY=10,11,12" is not supported and it
    #: will be partially supported as "FREQ=MONTHLY;INTERVAL=1;COUNT=10;BYMONTHDAY=10".
    recurrence: Optional[str]
    #: Unique identifier for the meeting host.
    host_user_id: Optional[str]
    #: Display name for the meeting host.
    host_display_name: Optional[str]
    #: Email address for the meeting host.
    host_email: Optional[str]
    #: Key for joining the meeting as host.
    host_key: Optional[str]
    #: Site URL for the meeting.
    site_url: Optional[str]
    #: Link to a meeting information page where the meeting client is launched if the meeting is ready to start or
    #: join.
    web_link: Optional[str]
    #: SIP address for callback from a video system.
    sip_address: Optional[str]
    #: IP address for callback from a video system.
    dial_in_ip_address: Optional[str]
    #: Room ID of the associated Webex space. Only applies to ad-hoc meetings and space meetings.
    room_id: Optional[str]
    #: Whether or not meeting is recorded automatically. Can be modified for a meeting series or a scheduled meeting
    #: using the Update a Meeting API.
    enabled_auto_record_meeting: Optional[bool]
    #: Whether or not to allow any attendee with a host account on the target site to become a cohost when joining the
    #: meeting. The target site is specified by a siteUrl parameter when creating the meeting. If not specified, it's a
    #: user's preferred site. The allowAnyUserToBeCoHost attribute can be modified for a meeting series or a scheduled
    #: meeting using the Update a Meeting API.
    allow_any_user_to_be_co_host: Optional[bool]
    #: Whether or not to allow any attendee to join the meeting before the host joins the meeting. The
    #: enabledJoinBeforeHost attribute can be modified for a meeting series or a scheduled meeting using the Update a
    #: Meeting API.
    enabled_join_before_host: Optional[bool]
    #: Whether or not to allow any attendee to connect to audio before the host joins the meeting. Only applicable if
    #: the enabledJoinBeforeHost attribute is set to true. The enableConnectAudioBeforeHost attribute can be modified
    #: for a meeting series or a scheduled meeting using the Update a Meeting API.
    enable_connect_audio_before_host: Optional[bool]
    #: Number of minutes an attendee can join the meeting before the meeting start time and the host joins. Only
    #: applicable if the enabledJoinBeforeHost attribute is set to true. The joinBeforeHostMinutes attribute can be
    #: modified for a meeting series or a scheduled meeting using the Update a Meeting API. Valid options are 0, 5, 10
    #: and 15. Default is 0 if not specified.
    join_before_host_minutes: Optional[int]
    #: Whether or not to exclude the meeting password from the email invitation.
    exclude_password: Optional[bool]
    #: Whether or not to allow the meeting to be listed on the public calendar.
    public_meeting: Optional[bool]
    #: The number of minutes before the meeting begins, that an email reminder is sent to the host.
    reminder_time: Optional[int]
    #: Specifies how the people who aren't on the invite can join the unlocked meeting.
    unlocked_meeting_join_security: Optional[UnlockedMeetingJoinSecurity]
    #: Unique identifier for a meeting session type for the user. This attribute is required when scheduling a webinar
    #: meeting. All available meeting session types enabled for the user can be retrieved using the List Meeting
    #: Session Types API.
    session_type_id: Optional[int]
    #: Specifies whether the meeting is a regular meeting, a webinar, or a meeting scheduled in the user's personal
    #: room.
    scheduled_type: Optional[ScheduledType]
    #: Whether or not webcast view is enabled.
    enabled_webcast_view: Optional[bool]
    #: Password for panelists of a webinar meeting. Must conform to the site's password complexity settings. Read
    #: password management for details. If not specified, a random password conforming to the site's password rules
    #: will be generated automatically.
    panelist_password: Optional[str]
    #: 8-digit numeric panelist password to join a webinar meeting from audio and video devices.
    phone_and_video_system_panelist_password: Optional[str]
    #: Whether or not to automatically lock the meeting after it starts.
    enable_automatic_lock: Optional[bool]
    #: The number of minutes after the meeting begins, for automatically locking it.
    automatic_lock_minutes: Optional[int]
    #: Whether or not to allow the first attendee of the meeting with a host account on the target site to become a
    #: cohost. The target site is specified by the siteUrl parameter when creating the meeting. If not specified, it's
    #: a user's preferred site. The allowFirstUserToBeCoHost attribute can be modified for a meeting series or a
    #: scheduled meeting uisng the Update a Meeting API.
    allow_first_user_to_be_co_host: Optional[bool]
    #: Whether or not to allow authenticated video devices in the meeting's organization to start or join the meeting
    #: without a prompt. This attribute can be modified for a meeting series or a scheduled meeting using the Update a
    #: Meeting API.
    allow_authenticated_devices: Optional[bool]
    #: Information for callbacks from a meeting to phone or for joining a teleconference using a phone.
    telephony: Optional[Telephony]
    #: Meeting options.
    meeting_options: Optional[MeetingOptions]
    #: Attendee Privileges.
    attendee_privileges: Optional[AttendeePrivileges]
    #: Meeting registration. When this option is enabled, meeting invitees must register personal information in order
    #: to join the meeting. Meeting invitees will receive an email with a registration link for the registration. When
    #: the registration form has been submitted and approved, an email with a real meeting link will be received. By
    #: clicking that link the meeting invitee can join the meeting. Please note that meeting registration does not
    #: apply to a meeting when it's a recurring meeting with a recurrence field or no password, or the Join Before Host
    #: option is enabled for the meeting. See Register for a Meeting in Cisco Webex Meetings for details.
    registration: Optional[Registration1]
    #: External keys created by an integration application in its own domain, for example Zendesk ticket IDs, Jira IDs,
    #: Salesforce Opportunity IDs, etc.
    integration_tags: Optional[list[str]]
    #: Simultaneous interpretation information for the meeting.
    simultaneous_interpretation: Optional[SimultaneousInterpretation1]
    #: Tracking codes information.
    tracking_codes: Optional[list[TrackingCodeItemForCreateMeetingObject]]
    #: Audio connection options.
    audio_connection_options: Optional[AudioConnectionOptions]


class CreateMeetingResponse(MeetingSeriesObjectForListMeeting):
    #: If true, the meeting is ad-hoc.
    adhoc: Optional[bool]


class Telephony6(ApiModel):
    #: Code for authenticating a user to join teleconference. Users join the teleconference using the call-in number or
    #: the global call-in number, followed by the value of the accessCode.
    access_code: Optional[str]
    #: Array of call-in numbers for joining a teleconference from a phone.
    call_in_numbers: Optional[list[CallInNumbers]]
    #: HATEOAS information of global call-in numbers for joining a teleconference from a phone.
    links: Optional[list[Links]]


class ScheduledMeetingObject(ApiModel):
    #: Unique identifier for meeting. For a meeting series, the id is used to identify the entire series. For scheduled
    #: meetings from a series, the id is used to identify that scheduled meeting. For a meeting instance that is in
    #: progress or has concluded, the id is used to identify that instance.
    id: Optional[str]
    #: Unique identifier for meeting series. It only apples to scheduled meeting and meeting instance. If it's a
    #: scheduled meeting from a series or a meeting instance that is happening or has happened, the meetingSeriesId is
    #: the id of the primary series.
    meeting_series_id: Optional[str]
    #: Unique identifier for scheduled meeting which current meeting is associated with. It only apples to meeting
    #: instance which is happening or has happened. It's the id of the scheduled meeting this instance is associated
    #: with.
    scheduled_meeting_id: Optional[str]
    #: Meeting number. Applies to meeting series, scheduled meeting, and meeting instances, but not to meeting
    #: instances which have ended.
    meeting_number: Optional[str]
    #: Meeting title. Can be modified for a meeting series or a scheduled meeting using the Update a Meeting API.
    title: Optional[str]
    #: Meeting agenda. The agenda can be a maximum of 1300 characters long. This attribute can be modified for a
    #: meeting series or a scheduled meeting using the Update a Meeting API.
    agenda: Optional[str]
    #: Meeting password. Applies to meeting series, scheduled meetings, and in-progress meeting instances, but not to
    #: meeting instances which have ended. Can be modified for a meeting series or a scheduled meeting using the Update
    #: a Meeting API.
    password: Optional[str]
    #: 8-digit numeric password used to join a meeting from audio and video devices. This attribute applies to meeting
    #: series, scheduled meetings, and in-progress meeting instances, but not to meeting instances which have ended.
    phone_and_video_system_password: Optional[str]
    #: Meeting type.
    meeting_type: Optional[MeetingType]
    #: Meeting state.
    state: Optional[State4]
    #: This state only applies to scheduled meeting. Flag identifying whether or not the scheduled meeting has been
    #: modified.
    is_modified: Optional[bool]
    #: Time zone of start and end, conforming with the IANA time zone database.
    timezone: Optional[str]
    #: Start time for meeting in ISO 8601 compliant format. If the meetingType of a meeting is meetingSeries, start is
    #: the scheduled start time of the first occurrence of this series. If the meeting is a meeting series and the
    #: current filter is true, start is the date and time the upcoming or ongoing meeting of the series starts. If the
    #: meetingType of a meeting is scheduledMeeting, start is the scheduled start time of this occurrence. If the
    #: meetingType of a meeting is meeting, start is the actual start time of the meeting instance. Can be modified for
    #: a meeting series or a scheduled meeting using the Update a Meeting API.
    start: Optional[str]
    #: End time for a meeting in ISO 8601 compliant format. If the meetingType of a meeting is meetingSeries, end is
    #: the scheduled end time of the first occurrence of this series. If the meeting is a meeting series and the
    #: current filter is true, end is the date and time the upcoming or ongoing meeting of the series ends. If the
    #: meetingType of a meeting is scheduledMeeting, end is the scheduled end time of this occurrence. If the
    #: meetingType of a meeting is meeting, end is the actual end time of the meeting instance. If a meeting instance
    #: is in progress, end is not available. Can be modified for a meeting series or a scheduled meeting using the
    #: Update a Meeting API.
    end: Optional[str]
    #: Unique identifier for the meeting host.
    host_user_id: Optional[str]
    #: Display name for the meeting host.
    host_display_name: Optional[str]
    #: Email address for the meeting host.
    host_email: Optional[str]
    #: Key for joining the meeting as host.
    host_key: Optional[str]
    #: Site URL for the meeting.
    site_url: Optional[str]
    #: Link to a meeting information page where the meeting client is launched if the meeting is ready to start or
    #: join.
    web_link: Optional[str]
    #: SIP address for callback from a video system.
    sip_address: Optional[str]
    #: IP address for callback from a video system.
    dial_in_ip_address: Optional[str]
    #: Room ID of the associated Webex space. Only applies to ad-hoc meetings and space meetings.
    room_id: Optional[str]
    #: Whether or not meeting is recorded automatically. Can be modified for a meeting series or a scheduled meeting
    #: using the Update a Meeting API.
    enabled_auto_record_meeting: Optional[bool]
    #: Whether or not to allow any attendee with a host account on the target site to become a cohost when joining the
    #: meeting. The target site is specified by a siteUrl parameter when creating the meeting. If not specified, it's a
    #: user's preferred site. The allowAnyUserToBeCoHost attribute can be modified for a meeting series or a scheduled
    #: meeting using the Update a Meeting API.
    allow_any_user_to_be_co_host: Optional[bool]
    #: Whether or not to allow any attendee to join the meeting before the host joins the meeting. The
    #: enabledJoinBeforeHost attribute can be modified for a meeting series or a scheduled meeting using the Update a
    #: Meeting API.
    enabled_join_before_host: Optional[bool]
    #: Whether or not to allow any attendee to connect to audio before the host joins the meeting. Only applicable if
    #: the enabledJoinBeforeHost attribute is set to true. The enableConnectAudioBeforeHost attribute can be modified
    #: for a meeting series or a scheduled meeting using the Update a Meeting API.
    enable_connect_audio_before_host: Optional[bool]
    #: The number of minutes an attendee can join the meeting before the meeting start time and the host joins. This
    #: attribute is only applicable if the enabledJoinBeforeHost attribute is set to true. The joinBeforeHostMinutes
    #: attribute can be modified for meeting series or scheduled meeting by Update a Meeting API. Valid options are 0,
    #: 5, 10 and 15. Default is 0 if not specified.
    join_before_host_minutes: Optional[int]
    #: Whether or not to exclude the meeting password from the email invitation.
    exclude_password: Optional[bool]
    #: Whether or not to allow the meeting to be listed on the public calendar.
    public_meeting: Optional[bool]
    #: The number of minutes before the meeting begins, that an email reminder is sent to the host.
    reminder_time: Optional[int]
    #: Specifies how the people who aren't on the invite can join the unlocked meeting.
    unlocked_meeting_join_security: Optional[UnlockedMeetingJoinSecurity]
    #: Unique identifier for a meeting session type for the user. This attribute is required when scheduling a webinar
    #: meeting. All available meeting session types enabled for the user can be retrieved using the List Meeting
    #: Session Types API.
    session_type_id: Optional[int]
    #: Specifies whether the meeting is a regular meeting, a webinar, or a meeting scheduled in the user's personal
    #: room.
    scheduled_type: Optional[ScheduledType]
    #: Whether or not webcast view is enabled.
    enabled_webcast_view: Optional[bool]
    #: Password for panelists of webinar meeting. Must conform to the site's password complexity settings. Read
    #: password management for details. If not specified, a random password conforming to the site's password rules
    #: will be generated automatically.
    panelist_password: Optional[str]
    #: 8-digit numeric panelist password to join webinar meeting from audio and video devices.
    phone_and_video_system_panelist_password: Optional[str]
    #: Whether or not to automatically lock the meeting after it starts.
    enable_automatic_lock: Optional[bool]
    #: The number of minutes after the meeting begins, for automatically locking it.
    automatic_lock_minutes: Optional[int]
    #: Whether or not to allow the first attendee of the meeting with a host account on the target site to become a
    #: cohost. The target site is specified by the siteUrl parameter when creating the meeting. If not specified, it's
    #: a user's preferred site. The allowFirstUserToBeCoHost attribute can be modified for a meeting series or a
    #: scheduled meeting uisng the Update a Meeting API.
    allow_first_user_to_be_co_host: Optional[bool]
    #: Whether or not to allow authenticated video devices in the meeting's organization to start or join the meeting
    #: without a prompt. This attribute can be modified for a meeting series or a scheduled meeting using the Update a
    #: Meeting API.
    allow_authenticated_devices: Optional[bool]
    #: Information for callbacks from a meeting to phone or for joining a teleconference using a phone.
    telephony: Optional[Telephony6]
    #: Meeting Options.
    meeting_options: Optional[MeetingOptions]
    #: Attendee Privileges.
    attendee_privileges: Optional[AttendeePrivileges]
    #: Meeting registration. When this option is enabled, meeting invitees must register personal information to join
    #: the meeting. Meeting invitees will receive an email with a registration link for the registration. When the
    #: registration form has been submitted and approved, an email with a real meeting link will be received. By
    #: clicking that link the meeting invitee can join the meeting. Please note that meeting registration does not
    #: apply to a meeting when it's a recurring meeting with a recurrence field or no password, or the Join Before Host
    #: option is enabled for the meeting. See Register for a Meeting in Cisco Webex Meetings for details. +
    #: autoAcceptRequest: false (boolean,optional) - Whether or not meeting registration requests are accepted
    #: automatically.
    registration: Optional[Registration1]
    #: External keys created by an integration application in its domain, for example, Zendesk ticket IDs, Jira IDs,
    #: Salesforce Opportunity IDs, etc.
    integration_tags: Optional[list[str]]
    #: Whether or not breakout sessions are enabled.
    enabled_breakout_sessions: Optional[bool]
    #: HATEOAS Breakout Sessions information for meeting.
    links: Optional[list[Links]]
    #: Tracking codes information.
    tracking_codes: Optional[list[TrackingCodeItemForCreateMeetingObject]]
    #: Audio connection options.
    audio_connection_options: Optional[AudioConnectionOptions]


class PatchMeetingResponse(MeetingSeriesObjectForListMeeting):
    #: Whether or not breakout sessions are enabled.
    enabled_breakout_sessions: Optional[bool]
    #: HATEOAS Breakout Sessions information for meeting.
    links: Optional[list[Links]]


class TemplateObject(Role):
    #: Meeting template locale.
    locale: Optional[str]
    #: Site URL for the meeting template.
    site_url: Optional[str]
    #: Meeting template type.
    template_type: Optional[TemplateType]
    #: Whether or not the meeting template is a default template.
    is_default: Optional[bool]
    #: Whether or not the meeting template is a standard template.
    is_standard: Optional[bool]


class CreateMeetingBody(PatchMeetingBody):
    #: Whether or not to create an ad-hoc meeting for the room specified by roomId. When true, roomId is required.
    adhoc: Optional[bool]
    #: Unique identifier for the Webex space which the meeting is to be associated with. It can be retrieved by List
    #: Rooms. roomId is required when adhoc is true. When roomId is specified, the parameter hostEmail will be ignored.
    room_id: Optional[str]
    #: Unique identifier for meeting template. Please note that start and end are optional when templateId is
    #: specified. The list of meeting templates that is available for the authenticated user can be retrieved from List
    #: Meeting Templates. This parameter is ignored for an ad-hoc meeting.
    template_id: Optional[str]
    #: When set as an attribute in a POST request body, specifies whether it's a regular meeting, a webinar, or a
    #: meeting scheduled in the user's personal room. If not specified, it's a regular meeting by default. The default
    #: value for an ad-hoc meeting is meeting and the user's input value will be ignored.
    scheduled_type: Optional[ScheduledType]
    #: Invitees for meeting. The maximum size of invitees is 1000. If roomId is specified and invitees is missing, all
    #: the members in the space are invited implicitly. If both roomId and invitees are specified, only those in the
    #: invitees list are invited. coHost for each invitee is true by default if roomId is specified when creating a
    #: meeting, and anyone in the invitee list that is not qualified to be a cohost will be invited as a non-cohost
    #: invitee. The user's input value will be ignored for an ad-hoc meeting and the the members of the room specified
    #: by roomId except "me" will be used by default.
    invitees: Optional[list[InviteeObjectForCreateMeeting]]
    #: Meeting registration. When this option is enabled, meeting invitees must register personal information to join
    #: the meeting. Meeting invitees will receive an email with a registration link for the registration. When the
    #: registration form has been submitted and approved, an email with a real meeting link will be received. By
    #: clicking that link the meeting invitee can join the meeting. Please note that meeting registration does not
    #: apply to a meeting when it's a recurring meeting with a recurrence field or no password, or the Join Before Host
    #: option is enabled for the meeting. See Register for a Meeting in Cisco Webex Meetings for details. This
    #: parameter is ignored for an ad-hoc meeting.
    registration: Optional[Registration]
    #: Simultaneous interpretation information for a meeting.
    simultaneous_interpretation: Optional[SimultaneousInterpretation]
    #: Breakout sessions are smaller groups that are split off from the main meeting or webinar. They allow a subset of
    #: participants to collaborate and share ideas over audio and video. Use breakout sessions for workshops,
    #: classrooms, or for when you need a moment to talk privately with a few participants outside of the main session.
    #: Please note that maximum number of breakout sessions in a meeting or webinar is 100. In webinars, if hosts
    #: preassign attendees to breakout sessions, the role of attendee will be changed to panelist. Breakout session is
    #: not supported for a meeting with simultaneous interpretation.
    breakout_sessions: Optional[list[BreakoutSessionObject]]


class GetMeetingControlStatusResponse(ApiModel):
    #: Whether the meeting is locked or not.
    locked: Optional[bool]
    #: The value can be true or false, it indicates the meeting recording started or not.
    recording_started: Optional[bool]
    #: The value can be true or false, it indicates the meeting recording paused or not.
    recording_paused: Optional[bool]


class Type7(TemplateType):
    #: Meeting session type for a private meeting.
    private_meeting = 'privateMeeting'


class MeetingSessionTypeObject(Role):
    #: Meeting session type.
    type: Optional[Type7]
    #: The maximum number of attendees for the meeting session type.
    attendees_capacity: Optional[int]


class CustomizedQuestionForGetMeeting(CustomizedQuestionForCreateMeeting):
    #: Unique identifier for the question.
    id: Optional[int]


class GetRegistrationFormFormeetingResponse(ApiModel):
    #: Whether or not a registrant's first name is required for meeting registration. This option must always be true.
    require_first_name: Optional[bool]
    #: Whether or not a registrant's last name is required for meeting registration. This option must always be true.
    require_last_name: Optional[bool]
    #: Whether or not a registrant's email is required for meeting registration. This option must always be true.
    require_email: Optional[bool]
    #: Whether or not a registrant's job title is shown or required for meeting registration.
    require_job_title: Optional[bool]
    #: Whether or not a registrant's company name is shown or required for meeting registration.
    require_company_name: Optional[bool]
    #: Whether or not a registrant's first address field is shown or required for meeting registration.
    require_address1: Optional[bool]
    #: Whether or not a registrant's second address field is shown or required for meeting registration.
    require_address2: Optional[bool]
    #: Whether or not a registrant's city is shown or required for meeting registration.
    require_city: Optional[bool]
    #: Whether or not a registrant's state is shown or required for meeting registration.
    require_state: Optional[bool]
    #: Whether or not a registrant's postal code is shown or required for meeting registration.
    require_zip_code: Optional[bool]
    #: Whether or not a registrant's country or region is shown or required for meeting registration.
    require_country_region: Optional[bool]
    #: Whether or not a registrant's work phone number is shown or required for meeting registration.
    require_work_phone: Optional[bool]
    #: Whether or not a registrant's fax number is shown or required for meeting registration.
    require_fax: Optional[bool]
    #: Customized questions for meeting registration.
    customized_questions: Optional[list[CustomizedQuestionForGetMeeting]]
    #: The approval rules for standard questions.
    rules: Optional[list[StandardRegistrationApproveRule]]


class AnswerForCustomizedQuestion(ApiModel):
    #: Unique identifier for the option.
    option_id: Optional[int]
    #: The content of the answer or the option for this question.
    answer: Optional[str]


class CustomizedRegistrant(ApiModel):
    #: Unique identifier for the customized questions retrieved from the registration form.
    question_id: Optional[int]
    #: The answers for customized questions. If the question type is checkbox, more than one answer can be set.
    answers: Optional[list[AnswerForCustomizedQuestion]]


class Status9(str, Enum):
    #: Registrant has been approved.
    approved = 'approved'
    #: Registrant is in a pending list waiting for host or cohost approval.
    pending = 'pending'
    #: Registrant has been rejected by the host or cohost.
    rejected = 'rejected'


class RegisterMeetingRegistrantBody(Question1):
    #: The registrant's first name.
    first_name: Optional[str]
    #: If true send email to the registrant. Default: true.
    send_email: Optional[bool]
    #: The registrant's answers for customized questions. Registration options define whether or not this is required.
    customized_questions: Optional[list[CustomizedRegistrant]]


class RegisterMeetingRegistrantResponse(Question1):
    #: New registrant's ID.
    id: Optional[str]
    #: New registrant's status.
    status: Optional[Status9]
    #: Registrant's first name.
    first_name: Optional[str]
    #: Registrant's registration time.
    registration_time: Optional[str]
    #: Registrant's answers for customized questions, Registration options define whether or not this is required.
    customized_questions: Optional[list[CustomizedRegistrant]]


class GetDetailedInformationForMeetingRegistrantResponse(Question1):
    #: New registrant's ID.
    registrant_id: Optional[str]
    #: New registrant's status.
    status: Optional[Status9]
    #: Registrant's first name.
    first_name: Optional[str]
    #: Registrant's registration time.
    registration_time: Optional[str]
    #: Registrant's answers for customized questions, Registration options define whether or not this is required.
    customized_questions: Optional[list[CustomizedRegistrant]]
    #: Registrant's source id.The sourceId is from Create Invitation Sources API.
    source_id: Optional[str]


class OrderType(str, Enum):
    desc = 'DESC'
    asc = 'ASC'


class OrderBy(str, Enum):
    #: Registrant's first name.
    first_name = 'firstName'
    #: Registrant's last name.
    last_name = 'lastName'
    #: Registrant's status.
    status = 'status'
    #: registrant's email.
    email = 'email'


class CreateMeetingInterpreterBody(InterpreterObjectForSimultaneousInterpretationOfCreateOrUpdateMeeting):
    #: Email address for the meeting host. This attribute should only be set if the user or application calling the API
    #: has the admin on-behalf-of scopes. When used, the admin may specify the email of a user in a site they manage to
    #: be the meeting host.
    host_email: Optional[str]
    #: If true, send email to the interpreter.
    send_email: Optional[bool]


class GetBreakoutSessionObject(BreakoutSessionObject):
    #: Unique identifier for breakout session.
    id: Optional[str]


class Type12(str, Enum):
    #: Text input.
    text = 'text'
    #: Rating.
    rating = 'rating'
    #: Check box which requires options.
    checkbox = 'checkbox'
    #: Drop down list box which requires options.
    single_dropdown = 'singleDropdown'
    #: Single radio button which requires options.
    single_radio = 'singleRadio'


class Options(ApiModel):
    #: The unique id of options.
    #: Possible values: 1
    id: Optional[int]
    #: The content of the option.
    #: Possible values: green
    value: Optional[str]


class QuestionObject(ApiModel):
    #: Unique identifier for the question.
    id: Optional[int]
    #: Details for the question.
    question: Optional[str]
    #: Type for the question.
    type: Optional[Type12]
    #: The lowest score of the rating question. This attribute will be ingnored, if the value of type attribute is not
    #: rating.
    from_score: Optional[int]
    #: The lowest score label of the rating question. This attribute will be ingnored, if the value of type attribute
    #: is not rating.
    from_label: Optional[str]
    #: The highest score of the rating question. This attribute will be ingnored, if the value of type attribute is not
    #: rating.
    to_score: Optional[int]
    #: The highest score label of the rating question. This attribute will be ingnored, if the value of type attribute
    #: is not rating.
    to_label: Optional[str]
    #: Options for the question. This attribute will be ingnored, if the value of type attribute is text or rating.
    options: Optional[list[Options]]


class QuestionWithAnswersObject(ApiModel):
    #: Unique identifier for the question.
    id: Optional[int]
    #: Details for the question.
    question: Optional[str]
    #: Type for the question.
    type: Optional[Type12]
    #: The user's answers for the question.
    answers: Optional[list[AnswerForCustomizedQuestion]]


class SurveyResultObject(CoHosts):
    #: Unique identifier for the survey result.
    id: Optional[str]
    #: Name for the survey.
    survey_name: Optional[str]
    #: Unique identifier for the meeting.
    meeting_id: Optional[str]
    #: The time when the user submits the survey.
    create_time: Optional[str]
    #: User's answers for the questions
    questions: Optional[list[QuestionWithAnswersObject]]


class InvitationSourceCreateObject(ApiModel):
    #: Source ID for the invitation.
    source_id: Optional[str]
    #: Email for invitation source.
    source_email: Optional[str]


class InvitationSourceObject(InvitationSourceCreateObject):
    #: Unique identifier for invitation source.
    id: Optional[str]
    #: The link bound to sourceId can directly join the meeting.If the meeting requires registration,joinLink is not
    #: returned.
    join_link: Optional[str]
    #: The link bound to sourceId can directly register the meeting.If the meeting requires registration,registerLink
    #: is returned.
    register_link: Optional[str]


class OptionsForTrackingCodeObject(ApiModel):
    #: The value of a tracking code option. value cannot be empty and the maximum size is 120 characters.
    value: Optional[str]
    #: Whether or not the option is the default option of a tracking code.
    default_value: Optional[bool]


class InputMode(str, Enum):
    #: Text input.
    text = 'text'
    #: Drop down list which requires options.
    select = 'select'
    #: Both text input and select from list.
    editable_select = 'editableSelect'
    #: An input method which is only available for the host profile and sign-up pages.
    host_profile_select = 'hostProfileSelect'


class ServiceType(str, Enum):
    meeting_center = 'MeetingCenter'
    event_center = 'EventCenter'
    training_center = 'TrainingCenter'
    support_center = 'SupportCenter'


class Service(ServiceType):
    #: Tracking codes apply to all services.
    all = 'All'


class HostProfileCode(str, Enum):
    #: Available to be chosen but not compulsory.
    optional = 'optional'
    #: Officially compulsory.
    required = 'required'
    #: The value is set by admin.
    admin_set = 'adminSet'
    #: The value cannot be used.
    not_used = 'notUsed'


class Type14(HostProfileCode):
    #: This value only applies to the service of All. When the type of All for a tracking code is notApplicable, there
    #: are different types for different services. For example, required for MeetingCenter, optional for EventCenter
    #: and notUsed for others.
    not_applicable = 'notApplicable'


class ReassignMeetingErrorDescriptionObject(ApiModel):
    #: Detailed description for the host reassignment of meetingId if it fails.
    description: Optional[str]


class ReassignMeetingResponseObject(ApiModel):
    #: Unique identifier for the meeting to be reassigned host.
    meeting_id: Optional[str]
    #: HTTP status code for the meeting reassignment result.
    http_status: Optional[str]
    #: General message for the host reassignment of meetingId if it fails.
    message: Optional[str]
    #: Detailed descriptions for the host reassignment of meetingId if it fails.
    errors: Optional[list[ReassignMeetingErrorDescriptionObject]]


class ListMeetingsResponse(ApiModel):
    #: Meetings array.
    items: Optional[list[MeetingSeriesObjectForListMeeting]]


class ListMeetingsOfMeetingSeriesResponse(ApiModel):
    #: Meetings array.
    items: Optional[list[ScheduledMeetingObject]]


class JoinMeetingBody(CoHosts):
    #: Unique identifier for the meeting. This parameter applies to meeting series and scheduled meetings. It doesn't
    #: apply to ended or in-progress meeting instances. Please note that currently meeting ID of a scheduled personal
    #: room meeting is also supported for this API.
    meeting_id: Optional[str]
    #: Meeting number. Applies to meeting series, scheduled meeting, and meeting instances, but not to meeting
    #: instances which have ended.
    meeting_number: Optional[str]
    #: Link to a meeting information page where the meeting client is launched if the meeting is ready to start or
    #: join.
    web_link: Optional[str]
    #: Whether or not to redirect to joinLink. It is an optional field and default value is true.
    join_directly: Optional[bool]
    #: It's required when the meeting is protected by a password and the current user is not privileged to view it if
    #: they are not a host, cohost or invitee of the meeting.
    password: Optional[str]
    #: Expiration duration of joinLink in minutes. Must be between 1 and 60.
    expiration_minutes: Optional[int]


class JoinMeetingResponse(ApiModel):
    #: The link is used to start a meeting as the meeting host. Only the meeting host or cohost can generate the
    #: startLink.
    start_link: Optional[str]
    #: The link is used to join the meeting.
    join_link: Optional[str]
    #: Expiration time of joinLink.
    expiration: Optional[str]


class ListMeetingTemplatesResponse(ApiModel):
    #: Meeting templates array.
    items: Optional[list[TemplateObject]]


class GetMeetingTemplateResponse(TemplateObject):
    #: Meeting object which is used to create a meeting by the meeting template. Please note that the meeting object
    #: should be used to create a meeting immediately after retrieval since the start and end may be invalid quickly
    #: after generation.
    meeting: Optional[CreateMeetingBody]


class ListMeetingSessionTypesResponse(ApiModel):
    #: Meeting session type array
    items: Optional[list[MeetingSessionTypeObject]]


class UpdateMeetingRegistrationFormBody(ApiModel):
    #:   * Email address for the meeting host. This parameter is only used if the user or application calling the API
    #:     has the admin-level scopes. If set, the admin may specify the email of a user in a site they manage and the
    #:     API will return an update for a meeting that is hosted by that user.
    host_email: Optional[str]
    #: Whether or not a registrant's first name is required for meeting registration. This option must always be true.
    require_first_name: Optional[bool]
    #: Whether or not a registrant's last name is required for meeting registration. This option must always be true.
    require_last_name: Optional[bool]
    #: Whether or not a registrant's email is required for meeting registration. This option must always be true.
    require_email: Optional[bool]
    #: Whether or not a registrant's job title is shown or required for meeting registration.
    require_job_title: Optional[bool]
    #: Whether or not a registrant's company name is shown or required for meeting registration.
    require_company_name: Optional[bool]
    #: Whether or not a registrant's first address field is shown or required for meeting registration.
    require_address1: Optional[bool]
    #: Whether or not a registrant's second address field is shown or required for meeting registration.
    require_address2: Optional[bool]
    #: Whether or not a registrant's city is shown or required for meeting registration.
    require_city: Optional[bool]
    #: Whether or not a registrant's state is shown or required for meeting registration.
    require_state: Optional[bool]
    #: Whether or not a registrant's postal code is shown or required for meeting registration.
    require_zip_code: Optional[bool]
    #: Whether or not a registrant's country or region is shown or required for meeting registration.
    require_country_region: Optional[bool]
    #: Whether or not a registrant's work phone number is shown or required for meeting registration.
    require_work_phone: Optional[bool]
    #: Whether or not a registrant's fax number is shown or required for meeting registration.
    require_fax: Optional[bool]
    #: Maximum number of meeting registrations. This only applies to meetings. The maximum number of participants for
    #: meetings and webinars, with the limit based on the user capacity and controlled by a toggle at the site level.
    #: The default maximum number of participants for webinars is 10000, but the actual maximum number of participants
    #: is limited by the user capacity.
    max_register_num: Optional[int]
    #: Customized questions for meeting registration.
    customized_questions: Optional[list[CustomizedQuestionForCreateMeeting]]
    #: The approval rule for standard questions.
    rules: Optional[list[StandardRegistrationApproveRule]]


class BatchRegisterMeetingRegistrantsBody(ApiModel):
    #: Registrants array.
    items: Optional[list[RegisterMeetingRegistrantBody]]


class BatchRegisterMeetingRegistrantsResponse(ApiModel):
    items: Optional[list[RegisterMeetingRegistrantResponse]]


class ListMeetingRegistrantsResponse(ApiModel):
    #: Registrants array.
    items: Optional[list[GetDetailedInformationForMeetingRegistrantResponse]]


class QueryMeetingRegistrantsBody(ApiModel):
    #: Registrant's status.
    status: Optional[Status9]
    #: Sort order for the registrants.
    order_type: Optional[OrderType]
    #: Registrant ordering field. Ordered by registrationTime by default.
    order_by: Optional[OrderBy]
    #: List of registrant email addresses.
    #: Possible values: bob@example.com
    emails: Optional[list[str]]


class QueryMeetingRegistrantsResponse(ApiModel):
    #: Registrants array.
    items: Optional[list[GetDetailedInformationForMeetingRegistrantResponse]]


class BatchUpdateMeetingRegistrantsStatusBody(ApiModel):
    #: If true send email to registrants. Default: true.
    send_email: Optional[bool]
    #: Registrants array.
    #: Registrant ID.
    registrants: Optional[list[Registrants]]


class ListMeetingInterpretersResponse(ApiModel):
    #: Array of meeting interpreters.
    items: Optional[list[InterpreterObjectForSimultaneousInterpretationOfGetOrListMeeting]]


class UpdateMeetingBreakoutSessionsBody(ApiModel):
    #: Email address for the meeting host. This parameter is only used if the user or application calling the API has
    #: the admin-level scopes. If set, the admin may specify the email of a user in a site they manage and the API will
    #: return details for a meeting that is hosted by that user.
    host_email: Optional[str]
    #: Whether or not to send emails to host and invitees. It is an optional field and default value is true.
    send_email: Optional[bool]
    #: Breakout sessions are smaller groups that are split off from the main meeting or webinar. They allow a subset of
    #: participants to collaborate and share ideas over audio and video. Use breakout sessions for workshops,
    #: classrooms, or for when you need a moment to talk privately with a few participants outside of the main session.
    #: Please note that maximum number of breakout sessions in a meeting or webinar is 100. In webinars, if hosts
    #: preassign attendees to breakout sessions, the role of attendee will be changed to panelist. Breakout session is
    #: not supported for a meeting with simultaneous interpretation.
    items: Optional[list[BreakoutSessionObject]]


class UpdateMeetingBreakoutSessionsResponse(ApiModel):
    #: Breakout Sessions information for meeting.
    items: Optional[list[GetBreakoutSessionObject]]


class ListMeetingBreakoutSessionsResponse(ApiModel):
    #: Breakout Sessions information for meeting.
    items: Optional[list[GetBreakoutSessionObject]]


class GetMeetingSurveyResponse(ApiModel):
    #: Unique identifier for the survey.
    id: Optional[str]
    #: Name for the survey.
    survey_name: Optional[str]
    #: Unique identifier for the meeting.
    meeting_id: Optional[str]
    #: Description for the survey.
    description: Optional[str]
    #: Whether the survey allows attendees to submit anonymously.
    allow_anonymous_submit: Optional[bool]
    #: Questions for the survey.
    questions: Optional[list[QuestionObject]]


class ListMeetingSurveyResultsResponse(ApiModel):
    #: SurveyResult array
    items: Optional[list[SurveyResultObject]]


class CreateInvitationSourcesBody(ApiModel):
    #: Email address for the meeting host. This parameter is only used if a user or application calling the API has the
    #: admin-level scopes. The admin may specify the email of a user on a site they manage and the API will return
    #: meeting participants of the meetings that are hosted by that user.
    host_email: Optional[str]
    #: Unique identifier for the meeting host. Should only be set if the user or application calling the API has the
    #: admin-level scopes. When used, the admin may specify the email of a user in a site they manage to be the meeting
    #: host.
    person_id: Optional[str]
    items: Optional[list[InvitationSourceCreateObject]]


class CreateInvitationSourcesResponse(ApiModel):
    #: Invitation source array.
    items: Optional[list[InvitationSourceObject]]


class ListInvitationSourcesResponse(ApiModel):
    #: Invitation source array.
    items: Optional[list[InvitationSourceObject]]


class ListMeetingTrackingCodesResponse(Role):
    #: Site URL for the tracking code.
    site_url: Optional[str]
    #: Tracking code option list. The options here differ from those in the site-level tracking codes and the
    #: user-level tracking codes. It is the result of a selective combination of the two. If there's user-level value
    #: for a tracking code, the user-level value becomes the default option for the tracking code, and the site-level
    #: default value becomes non-default.
    options: Optional[list[OptionsForTrackingCodeObject]]
    #: The input mode in which the tracking code value can be assigned.
    input_mode: Optional[InputMode]
    #: Service for schedule or sign up pages
    service: Optional[Service]
    #: Type for meeting scheduler or meeting start pages.
    type: Optional[Type14]


class ReassignMeetingsToNewHostBody(ApiModel):
    #: Email address of the new meeting host.
    host_email: Optional[str]
    #: List of meeting series IDs to be reassigned the new host. The size is between 1 and 100. All the meetings of
    #: meetingIds should belong to the same site, which is the siteUrl in the request header, if specified, or the
    #: admin user's preferred site, if not specified. All available Webex sites and the preferred sites of a user can
    #: be retrieved by Get Site List API.
    meeting_ids: Optional[list[str]]


class ReassignMeetingsToNewHostResponse(ApiModel):
    #: Array of meeting reassignment results.
    items: Optional[list[ReassignMeetingResponseObject]]


class MeetingsApi(ApiChild, base='meetings'):
    """
    Meetings are virtual conferences where users can collaborate in real time using audio, video, content sharing,
    chat, online whiteboards, and to collaborate.
    This API focuses primarily on the scheduling and management of meetings. You can use the Meetings API to list,
    create, get, update, and delete meetings.
    Several types of meeting objects are supported by this API, such as meeting series, scheduled meeting, and ended or
    in-progress meeting instances. See the Meetings Overview for more information about the types of meetings.
    Refer to the Meetings API Scopes section of Meetings Overview for scopes required for each API.
    """

    def create(self, title: str = None, agenda: str = None, password: str = None, start: str = None, end: str = None, timezone: str = None, recurrence: str = None, enabled_auto_record_meeting: bool = None, allow_any_user_to_be_co_host: bool = None, enabled_join_before_host: bool = None, enable_connect_audio_before_host: bool = None, join_before_host_minutes: int = None, exclude_password: bool = None, public_meeting: bool = None, reminder_time: int = None, unlocked_meeting_join_security: UnlockedMeetingJoinSecurity = None, session_type_id: int = None, enabled_webcast_view: bool = None, panelist_password: str = None, enable_automatic_lock: bool = None, automatic_lock_minutes: int = None, allow_first_user_to_be_co_host: bool = None, allow_authenticated_devices: bool = None, send_email: bool = None, host_email: str = None, site_url: str = None, meeting_options: MeetingOptions = None, attendee_privileges: AttendeePrivileges = None, integration_tags: List[str] = None, enabled_breakout_sessions: bool = None, tracking_codes: TrackingCodeItemForCreateMeetingObject = None, audio_connection_options: AudioConnectionOptions = None, adhoc: bool = None, room_id: str = None, template_id: str = None, scheduled_type: ScheduledType = None, invitees: InviteeObjectForCreateMeeting = None, registration: Registration = None, simultaneous_interpretation: SimultaneousInterpretation = None, breakout_sessions: BreakoutSessionObject = None) -> CreateMeetingResponse:
        """
        Creates a new meeting. Regular users can schedule up to 100 meetings in 24 hours and admin users up to 3000.

        :param title: Meeting title. The title can be a maximum of 128 characters long.
        :type title: str
        :param agenda: Meeting agenda. The agenda can be a maximum of 1300 characters long.
        :type agenda: str
        :param password: Meeting password. Must conform to the site's password complexity settings. Read password
            management for details.
        :type password: str
        :param start: Date and time for the start of meeting in any ISO 8601 compliant format. start cannot be before
            current date and time or after end. Duration between start and end cannot be shorter than 10 minutes or
            longer than 24 hours. Refer to the Webex Meetings guide for more information about restrictions on updating
            date and time for a meeting. Please note that when a meeting is being updated, start of the meeting will be
            accurate to minutes, not seconds or milliseconds. Therefore, if start is within the same minute as the
            current time, start will be adjusted to the upcoming minute; otherwise, start will be adjusted with seconds
            and milliseconds stripped off. For instance, if the current time is 2022-03-01T10:32:16.657+08:00, start of
            2022-03-01T10:32:28.076+08:00 or 2022-03-01T10:32:41+08:00 will be adjusted to 2022-03-01T10:33:00+08:00,
            and start of 2022-03-01T11:32:28.076+08:00 or 2022-03-01T11:32:41+08:00 will be adjusted to
            2022-03-01T11:32:00+08:00.
        :type start: str
        :param end: Date and time for the end of meeting in any ISO 8601 compliant format. end cannot be before current
            date and time or before start. Duration between start and end cannot be shorter than 10 minutes or longer
            than 24 hours. Refer to the Webex Meetings guide for more information about restrictions on updating date
            and time for a meeting. Please note that when a meeting is being updated, end of the meeting will be
            accurate to minutes, not seconds or milliseconds. Therefore, end will be adjusted with seconds and
            milliseconds stripped off. For instance, end of 2022-03-01T11:52:28.076+08:00 or 2022-03-01T11:52:41+08:00
            will be adjusted to 2022-03-01T11:52:00+08:00.
        :type end: str
        :param timezone: Time zone in which the meeting was originally scheduled (conforming with the IANA time zone
            database).
        :type timezone: str
        :param recurrence: Meeting series recurrence rule (conforming with RFC 2445). Applies only to a recurring
            meeting series, not to a meeting series with only one scheduled meeting. Multiple days or dates for monthly
            or yearly recurrence rule are not supported, only the first day or date specified is taken. For example,
            "FREQ=MONTHLY;INTERVAL=1;COUNT=10;BYMONTHDAY=10,11,12" is not supported and it will be partially supported
            as "FREQ=MONTHLY;INTERVAL=1;COUNT=10;BYMONTHDAY=10".
        :type recurrence: str
        :param enabled_auto_record_meeting: Whether or not meeting is recorded automatically.
        :type enabled_auto_record_meeting: bool
        :param allow_any_user_to_be_co_host: Whether or not to allow any attendee with a host account on the target
            site to become a cohost when joining the meeting. The target site is specified by siteUrl parameter when
            creating the meeting; if not specified, it's user's preferred site.
        :type allow_any_user_to_be_co_host: bool
        :param enabled_join_before_host: Whether or not to allow any attendee to join the meeting before the host joins
            the meeting.
        :type enabled_join_before_host: bool
        :param enable_connect_audio_before_host: Whether or not to allow any attendee to connect audio in the meeting
            before the host joins the meeting. This attribute is only applicable if the enabledJoinBeforeHost attribute
            is set to true.
        :type enable_connect_audio_before_host: bool
        :param join_before_host_minutes: The number of minutes an attendee can join the meeting before the meeting
            start time and the host joins. This attribute is only applicable if the enabledJoinBeforeHost attribute is
            set to true. Valid options are 0, 5, 10 and 15. Default is 0 if not specified.
        :type join_before_host_minutes: int
        :param exclude_password: Whether or not to exclude the meeting password from the email invitation.
        :type exclude_password: bool
        :param public_meeting: Whether or not to allow the meeting to be listed on the public calendar.
        :type public_meeting: bool
        :param reminder_time: The number of minutes before the meeting begins, that an email reminder is sent to the
            host.
        :type reminder_time: int
        :param unlocked_meeting_join_security: Specifies how the people who aren't on the invite can join the unlocked
            meeting.
        :type unlocked_meeting_join_security: UnlockedMeetingJoinSecurity
        :param session_type_id: Unique identifier for a meeting session type for the user. This attribute is required
            while scheduling webinar meeting. All available meeting session types enabled for the user can be retrieved
            by List Meeting Session Types API.
        :type session_type_id: int
        :param enabled_webcast_view: Whether or not webcast view is enabled.
        :type enabled_webcast_view: bool
        :param panelist_password: Password for panelists of a webinar meeting. Must conform to the site's password
            complexity settings. Read password management for details. If not specified, a random password conforming
            to the site's password rules will be generated automatically.
        :type panelist_password: str
        :param enable_automatic_lock: Whether or not to automatically lock the meeting after it starts.
        :type enable_automatic_lock: bool
        :param automatic_lock_minutes: The number of minutes after the meeting begins, for automatically locking it.
        :type automatic_lock_minutes: int
        :param allow_first_user_to_be_co_host: Whether or not to allow the first attendee of the meeting with a host
            account on the target site to become a cohost. The target site is specified by siteUrl parameter when
            creating the meeting; if not specified, it's user's preferred site.
        :type allow_first_user_to_be_co_host: bool
        :param allow_authenticated_devices: Whether or not to allow authenticated video devices in the meeting's
            organization to start or join the meeting without a prompt.
        :type allow_authenticated_devices: bool
        :param send_email: Whether or not to send emails to host and invitees. It is an optional field and default
            value is true.
        :type send_email: bool
        :param host_email: Email address for the meeting host. This attribute should only be set if the user or
            application calling the API has the admin-level scopes. When used, the admin may specify the email of a
            user in a site they manage to be the meeting host.
        :type host_email: str
        :param site_url: URL of the Webex site which the meeting is updated on. If not specified, the meeting is
            created on user's preferred site. All available Webex sites and preferred site of the user can be retrieved
            by Get Site List API.
        :type site_url: str
        :param meeting_options: Meeting Options.
        :type meeting_options: MeetingOptions
        :param attendee_privileges: Attendee Privileges.
        :type attendee_privileges: AttendeePrivileges
        :param integration_tags: External keys created by an integration application in its own domain, for example
            Zendesk ticket IDs, Jira IDs, Salesforce Opportunity IDs, etc. The integration application queries meetings
            by a key in its own domain. The maximum size of integrationTags is 3 and each item of integrationTags can
            be a maximum of 64 characters long. Please note that an empty or null integrationTags will delete all
            existing integration tags for the meeting implicitly. Developer can update integration tags for a
            meetingSeries but he cannot update it for a scheduledMeeting or a meeting instance.
        :type integration_tags: List[str]
        :param enabled_breakout_sessions: Whether or not breakout sessions are enabled. If the value of
            enabledBreakoutSessions is false, users can not set breakout sessions. If the value of
            enabledBreakoutSessions is true, users can update breakout sessions using the Update Breakout Sessions API.
            Updating breakout sessions are not supported by this API.
        :type enabled_breakout_sessions: bool
        :param tracking_codes: Tracking codes information. All available tracking codes and their options for the
            specified site can be retrieved by List Meeting Tracking Codes API. If an optional tracking code is missing
            from the trackingCodes array and there's a default option for this tracking code, the default option is
            assigned automatically. If the inputMode of a tracking code is select, its value must be one of the
            site-level options or the user-level value. Tracking code is not supported for a personal room meeting or
            an ad-hoc space meeting.
        :type tracking_codes: TrackingCodeItemForCreateMeetingObject
        :param audio_connection_options: Audio connection options.
        :type audio_connection_options: AudioConnectionOptions
        :param adhoc: Whether or not to create an ad-hoc meeting for the room specified by roomId. When true, roomId is
            required.
        :type adhoc: bool
        :param room_id: Unique identifier for the Webex space which the meeting is to be associated with. It can be
            retrieved by List Rooms. roomId is required when adhoc is true. When roomId is specified, the parameter
            hostEmail will be ignored.
        :type room_id: str
        :param template_id: Unique identifier for meeting template. Please note that start and end are optional when
            templateId is specified. The list of meeting templates that is available for the authenticated user can be
            retrieved from List Meeting Templates. This parameter is ignored for an ad-hoc meeting.
        :type template_id: str
        :param scheduled_type: When set as an attribute in a POST request body, specifies whether it's a regular
            meeting, a webinar, or a meeting scheduled in the user's personal room. If not specified, it's a regular
            meeting by default. The default value for an ad-hoc meeting is meeting and the user's input value will be
            ignored.
        :type scheduled_type: ScheduledType
        :param invitees: Invitees for meeting. The maximum size of invitees is 1000. If roomId is specified and
            invitees is missing, all the members in the space are invited implicitly. If both roomId and invitees are
            specified, only those in the invitees list are invited. coHost for each invitee is true by default if
            roomId is specified when creating a meeting, and anyone in the invitee list that is not qualified to be a
            cohost will be invited as a non-cohost invitee. The user's input value will be ignored for an ad-hoc
            meeting and the the members of the room specified by roomId except "me" will be used by default.
        :type invitees: InviteeObjectForCreateMeeting
        :param registration: Meeting registration. When this option is enabled, meeting invitees must register personal
            information to join the meeting. Meeting invitees will receive an email with a registration link for the
            registration. When the registration form has been submitted and approved, an email with a real meeting link
            will be received. By clicking that link the meeting invitee can join the meeting. Please note that meeting
            registration does not apply to a meeting when it's a recurring meeting with a recurrence field or no
            password, or the Join Before Host option is enabled for the meeting. See Register for a Meeting in Cisco
            Webex Meetings for details. This parameter is ignored for an ad-hoc meeting.
        :type registration: Registration
        :param simultaneous_interpretation: Simultaneous interpretation information for a meeting.
        :type simultaneous_interpretation: SimultaneousInterpretation
        :param breakout_sessions: Breakout sessions are smaller groups that are split off from the main meeting or
            webinar. They allow a subset of participants to collaborate and share ideas over audio and video. Use
            breakout sessions for workshops, classrooms, or for when you need a moment to talk privately with a few
            participants outside of the main session. Please note that maximum number of breakout sessions in a meeting
            or webinar is 100. In webinars, if hosts preassign attendees to breakout sessions, the role of attendee
            will be changed to panelist. Breakout session is not supported for a meeting with simultaneous
            interpretation.
        :type breakout_sessions: BreakoutSessionObject

        documentation: https://developer.webex.com/docs/api/v1/meetings/create-a-meeting
        """
        body = CreateMeetingBody()
        if title is not None:
            body.title = title
        if agenda is not None:
            body.agenda = agenda
        if password is not None:
            body.password = password
        if start is not None:
            body.start = start
        if end is not None:
            body.end = end
        if timezone is not None:
            body.timezone = timezone
        if recurrence is not None:
            body.recurrence = recurrence
        if enabled_auto_record_meeting is not None:
            body.enabled_auto_record_meeting = enabled_auto_record_meeting
        if allow_any_user_to_be_co_host is not None:
            body.allow_any_user_to_be_co_host = allow_any_user_to_be_co_host
        if enabled_join_before_host is not None:
            body.enabled_join_before_host = enabled_join_before_host
        if enable_connect_audio_before_host is not None:
            body.enable_connect_audio_before_host = enable_connect_audio_before_host
        if join_before_host_minutes is not None:
            body.join_before_host_minutes = join_before_host_minutes
        if exclude_password is not None:
            body.exclude_password = exclude_password
        if public_meeting is not None:
            body.public_meeting = public_meeting
        if reminder_time is not None:
            body.reminder_time = reminder_time
        if unlocked_meeting_join_security is not None:
            body.unlocked_meeting_join_security = unlocked_meeting_join_security
        if session_type_id is not None:
            body.session_type_id = session_type_id
        if enabled_webcast_view is not None:
            body.enabled_webcast_view = enabled_webcast_view
        if panelist_password is not None:
            body.panelist_password = panelist_password
        if enable_automatic_lock is not None:
            body.enable_automatic_lock = enable_automatic_lock
        if automatic_lock_minutes is not None:
            body.automatic_lock_minutes = automatic_lock_minutes
        if allow_first_user_to_be_co_host is not None:
            body.allow_first_user_to_be_co_host = allow_first_user_to_be_co_host
        if allow_authenticated_devices is not None:
            body.allow_authenticated_devices = allow_authenticated_devices
        if send_email is not None:
            body.send_email = send_email
        if host_email is not None:
            body.host_email = host_email
        if site_url is not None:
            body.site_url = site_url
        if meeting_options is not None:
            body.meeting_options = meeting_options
        if attendee_privileges is not None:
            body.attendee_privileges = attendee_privileges
        if integration_tags is not None:
            body.integration_tags = integration_tags
        if enabled_breakout_sessions is not None:
            body.enabled_breakout_sessions = enabled_breakout_sessions
        if tracking_codes is not None:
            body.tracking_codes = tracking_codes
        if audio_connection_options is not None:
            body.audio_connection_options = audio_connection_options
        if adhoc is not None:
            body.adhoc = adhoc
        if room_id is not None:
            body.room_id = room_id
        if template_id is not None:
            body.template_id = template_id
        if scheduled_type is not None:
            body.scheduled_type = scheduled_type
        if invitees is not None:
            body.invitees = invitees
        if registration is not None:
            body.registration = registration
        if simultaneous_interpretation is not None:
            body.simultaneous_interpretation = simultaneous_interpretation
        if breakout_sessions is not None:
            body.breakout_sessions = breakout_sessions
        url = self.ep()
        data = super().post(url=url, data=body.json())
        return CreateMeetingResponse.parse_obj(data)

    def get(self, meeting_id: str, current: bool = None, host_email: str = None) -> CreateMeetingResponse:
        """
        Retrieves details for a meeting with a specified meeting ID.

        :param meeting_id: Unique identifier for the meeting being requested.
        :type meeting_id: str
        :param current: Whether or not to retrieve only the current scheduled meeting of the meeting series, i.e. the
            meeting ready to join or start or the upcoming meeting of the meeting series. If it's true, return details
            for the current scheduled meeting of the series, i.e. the scheduled meeting ready to join or start or the
            upcoming scheduled meeting of the meeting series. If it's false or not specified, return details for the
            entire meeting series. This parameter only applies to meeting series.
        :type current: bool
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin-level scopes. If set, the admin may specify the email of a user in a site
            they manage and the API will return details for a meeting that is hosted by that user.
        :type host_email: str

        documentation: https://developer.webex.com/docs/api/v1/meetings/get-a-meeting
        """
        params = {}
        if current is not None:
            params['current'] = str(current).lower()
        if host_email is not None:
            params['hostEmail'] = host_email
        url = self.ep(f'{meeting_id}')
        data = super().get(url=url, params=params)
        return CreateMeetingResponse.parse_obj(data)

    def list(self, meeting_number: str = None, web_link: str = None, room_id: str = None, meeting_type: str = None, state: str = None, scheduled_type: str = None, current: bool = None, from_: str = None, to_: str = None, host_email: str = None, site_url: str = None, integration_tag: str = None, **params) -> Generator[MeetingSeriesObjectForListMeeting, None, None]:
        """
        Retrieves details for meetings with a specified meeting number, web link, meeting type, etc. Please note that
        there are various products in the Webex Suite such as Meetings and Events. Currently, only meetings of the
        Meetings product are supported by this API, meetings of others in the suite are not supported. Ad-hoc meetings
        created by Create a Meeting with adhoc of true and a roomId will not be listed, but the ended and ongoing
        ad-hoc meeting instances will be listed.

        :param meeting_number: Meeting number for the meeting objects being requested. meetingNumber, webLink and
            roomId are mutually exclusive. If it's an exceptional meeting from a meeting series, the exceptional
            meeting instead of the primary meeting series is returned.
        :type meeting_number: str
        :param web_link: URL encoded link to information page for the meeting objects being requested. meetingNumber,
            webLink and roomId are mutually exclusive.
        :type web_link: str
        :param room_id: Associated Webex space ID for the meeting objects being requested. meetingNumber, webLink and
            roomId are mutually exclusive.
        :type room_id: str
        :param meeting_type: Meeting type for the meeting objects being requested. This parameter will be ignored if
            meetingNumber, webLink or roomId is specified. Possible values: meetingSeries, scheduledMeeting, meeting
        :type meeting_type: str
        :param state: Meeting state for the meeting objects being requested. If not specified, return meetings of all
            states. This parameter will be ignored if meetingNumber, webLink or roomId is specified. Details of an
            ended meeting will only be available 15 minutes after the meeting has ended. inProgress meetings are not
            fully supported. The API will try to return details of an inProgress meeting 15 minutes after the meeting
            starts. However, it may take longer depending on the traffic. See the Webex Meetings guide for more
            information about the states of meetings. Possible values: active, scheduled, ready, lobby, inProgress,
            ended, missed, expired
        :type state: str
        :param scheduled_type: Scheduled type for the meeting objects being requested. Possible values: meeting,
            webinar, personalRoomMeeting
        :type scheduled_type: str
        :param current: Flag identifying to retrieve the current scheduled meeting of the meeting series or the entire
            meeting series. This parameter only applies to scenarios where meetingNumber is specified and the meeting
            is not an exceptional meeting from a meeting series. If it's true, return the scheduled meeting of the
            meeting series which is ready to join or start or the upcoming scheduled meeting of the meeting series; if
            it's false, return the entire meeting series.
        :type current: bool
        :param from_: Start date and time (inclusive) in any ISO 8601 compliant format for the meeting objects being
            requested. from cannot be after to. This parameter will be ignored if meetingNumber, webLink or roomId is
            specified.
        :type from_: str
        :param to_: End date and time (exclusive) in any ISO 8601 compliant format for the meeting objects being
            requested. to cannot be before from. This parameter will be ignored if meetingNumber, webLink or roomId is
            specified.
        :type to_: str
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin-level scopes. If set, the admin may specify the email of a user in a site
            they manage and the API will return details for meetings that are hosted by that user.
        :type host_email: str
        :param site_url: URL of the Webex site which the API lists meetings from. If not specified, the API lists
            meetings from user's all sites. All available Webex sites of the user can be retrieved by Get Site List
            API.
        :type site_url: str
        :param integration_tag: External key created by an integration application. This parameter is used by the
            integration application to query meetings by a key in its own domain such as a Zendesk ticket ID, a Jira
            ID, a Salesforce Opportunity ID, etc.
        :type integration_tag: str

        documentation: https://developer.webex.com/docs/api/v1/meetings/list-meetings
        """
        if meeting_number is not None:
            params['meetingNumber'] = meeting_number
        if web_link is not None:
            params['webLink'] = web_link
        if room_id is not None:
            params['roomId'] = room_id
        if meeting_type is not None:
            params['meetingType'] = meeting_type
        if state is not None:
            params['state'] = state
        if scheduled_type is not None:
            params['scheduledType'] = scheduled_type
        if current is not None:
            params['current'] = str(current).lower()
        if from_ is not None:
            params['from'] = from_
        if to_ is not None:
            params['to'] = to_
        if host_email is not None:
            params['hostEmail'] = host_email
        if site_url is not None:
            params['siteUrl'] = site_url
        if integration_tag is not None:
            params['integrationTag'] = integration_tag
        url = self.ep()
        return self.session.follow_pagination(url=url, model=MeetingSeriesObjectForListMeeting, params=params)

    def list_of_series(self, meeting_series_id: str, from_: str = None, to_: str = None, meeting_type: str = None, state: str = None, is_modified: bool = None, host_email: str = None, **params) -> Generator[ScheduledMeetingObject, None, None]:
        """
        Lists scheduled meeting and meeting instances of a meeting series identified by meetingSeriesId. Scheduled
        meetings of an ad-hoc meeting created by Create a Meeting with adhoc of true and a roomId will not be listed,
        but the ended and ongoing meeting instances of it will be listed.
        Each scheduled meeting or meeting instance of a meeting series has its own start, end, etc. Thus, for example,
        when a daily meeting has been scheduled from 2019-04-01 to 2019-04-10, there are 10 scheduled meeting instances
        in this series, one instance for each day, and each one has its own attributes. When a scheduled meeting has
        been started and ended or is happening, there are even more ended or in-progress meeting instances.
        Use this operation to list scheduled meeting and meeting instances of a meeting series within a specific date
        range.
        Long result sets are split into pages.
        trackingCodes is not supported for ended meeting instances.

        :param meeting_series_id: Unique identifier for the meeting series. Please note that currently meeting ID of a
            scheduled personal room meeting is not supported for this API.
        :type meeting_series_id: str
        :param from_: Start date and time (inclusive) for the range for which meetings are to be returned in any ISO
            8601 compliant format. from cannot be after to.
        :type from_: str
        :param to_: End date and time (exclusive) for the range for which meetings are to be returned in any ISO 8601
            compliant format. to cannot be before from.
        :type to_: str
        :param meeting_type: Meeting type for the meeting objects being requested. If not specified, return meetings of
            all types. Possible values: scheduledMeeting, meeting
        :type meeting_type: str
        :param state: Meeting state for the meetings being requested. If not specified, return meetings of all states.
            Details of an ended meeting will only be available 15 minutes after the meeting has ended. inProgress
            meetings are not fully supported. The API will try to return details of an inProgress meeting 15 minutes
            after the meeting starts. However, it may take longer depending on the traffic. See the Webex Meetings
            guide for more information about the states of meetings. Possible values: scheduled, ready, lobby,
            inProgress, ended, missed
        :type state: str
        :param is_modified: Flag identifying whether or not only to retrieve scheduled meeting instances which have
            been modified. This parameter only applies to scheduled meetings. If it's true, only return modified
            scheduled meetings; if it's false, only return unmodified scheduled meetings; if not specified, all
            scheduled meetings will be returned.
        :type is_modified: bool
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin-level scopes. If set, the admin may specify the email of a user in a site
            they manage and the API will return meetings that are hosted by that user.
        :type host_email: str

        documentation: https://developer.webex.com/docs/api/v1/meetings/list-meetings-of-a-meeting-series
        """
        params['meetingSeriesId'] = meeting_series_id
        if from_ is not None:
            params['from'] = from_
        if to_ is not None:
            params['to'] = to_
        if meeting_type is not None:
            params['meetingType'] = meeting_type
        if state is not None:
            params['state'] = state
        if is_modified is not None:
            params['isModified'] = str(is_modified).lower()
        if host_email is not None:
            params['hostEmail'] = host_email
        url = self.ep()
        return self.session.follow_pagination(url=url, model=ScheduledMeetingObject, params=params)

    def patch(self, meeting_id: str, title: str = None, agenda: str = None, password: str = None, start: str = None, end: str = None, timezone: str = None, recurrence: str = None, enabled_auto_record_meeting: bool = None, allow_any_user_to_be_co_host: bool = None, enabled_join_before_host: bool = None, enable_connect_audio_before_host: bool = None, join_before_host_minutes: int = None, exclude_password: bool = None, public_meeting: bool = None, reminder_time: int = None, unlocked_meeting_join_security: UnlockedMeetingJoinSecurity = None, session_type_id: int = None, enabled_webcast_view: bool = None, panelist_password: str = None, enable_automatic_lock: bool = None, automatic_lock_minutes: int = None, allow_first_user_to_be_co_host: bool = None, allow_authenticated_devices: bool = None, send_email: bool = None, host_email: str = None, site_url: str = None, meeting_options: MeetingOptions = None, attendee_privileges: AttendeePrivileges = None, integration_tags: List[str] = None, enabled_breakout_sessions: bool = None, tracking_codes: TrackingCodeItemForCreateMeetingObject = None, audio_connection_options: AudioConnectionOptions = None) -> PatchMeetingResponse:
        """
        Updates details for a meeting with a specified meeting ID. This operation applies to meeting series and
        scheduled meetings. It doesn't apply to ended or in-progress meeting instances. Ad-hoc meetings created by
        Create a Meeting with adhoc of true and a roomId cannot be updated.

        :param meeting_id: Unique identifier for the meeting to be updated. This parameter applies to meeting series
            and scheduled meetings. It doesn't apply to ended or in-progress meeting instances. Please note that
            currently meeting ID of a scheduled personal room meeting is not supported for this API.
        :type meeting_id: str
        :param title: Meeting title. The title can be a maximum of 128 characters long.
        :type title: str
        :param agenda: Meeting agenda. The agenda can be a maximum of 1300 characters long.
        :type agenda: str
        :param password: Meeting password. Must conform to the site's password complexity settings. Read password
            management for details.
        :type password: str
        :param start: Date and time for the start of meeting in any ISO 8601 compliant format. start cannot be before
            current date and time or after end. Duration between start and end cannot be shorter than 10 minutes or
            longer than 24 hours. Refer to the Webex Meetings guide for more information about restrictions on updating
            date and time for a meeting. Please note that when a meeting is being updated, start of the meeting will be
            accurate to minutes, not seconds or milliseconds. Therefore, if start is within the same minute as the
            current time, start will be adjusted to the upcoming minute; otherwise, start will be adjusted with seconds
            and milliseconds stripped off. For instance, if the current time is 2022-03-01T10:32:16.657+08:00, start of
            2022-03-01T10:32:28.076+08:00 or 2022-03-01T10:32:41+08:00 will be adjusted to 2022-03-01T10:33:00+08:00,
            and start of 2022-03-01T11:32:28.076+08:00 or 2022-03-01T11:32:41+08:00 will be adjusted to
            2022-03-01T11:32:00+08:00.
        :type start: str
        :param end: Date and time for the end of meeting in any ISO 8601 compliant format. end cannot be before current
            date and time or before start. Duration between start and end cannot be shorter than 10 minutes or longer
            than 24 hours. Refer to the Webex Meetings guide for more information about restrictions on updating date
            and time for a meeting. Please note that when a meeting is being updated, end of the meeting will be
            accurate to minutes, not seconds or milliseconds. Therefore, end will be adjusted with seconds and
            milliseconds stripped off. For instance, end of 2022-03-01T11:52:28.076+08:00 or 2022-03-01T11:52:41+08:00
            will be adjusted to 2022-03-01T11:52:00+08:00.
        :type end: str
        :param timezone: Time zone in which the meeting was originally scheduled (conforming with the IANA time zone
            database).
        :type timezone: str
        :param recurrence: Meeting series recurrence rule (conforming with RFC 2445). Applies only to a recurring
            meeting series, not to a meeting series with only one scheduled meeting. Multiple days or dates for monthly
            or yearly recurrence rule are not supported, only the first day or date specified is taken. For example,
            "FREQ=MONTHLY;INTERVAL=1;COUNT=10;BYMONTHDAY=10,11,12" is not supported and it will be partially supported
            as "FREQ=MONTHLY;INTERVAL=1;COUNT=10;BYMONTHDAY=10".
        :type recurrence: str
        :param enabled_auto_record_meeting: Whether or not meeting is recorded automatically.
        :type enabled_auto_record_meeting: bool
        :param allow_any_user_to_be_co_host: Whether or not to allow any attendee with a host account on the target
            site to become a cohost when joining the meeting. The target site is specified by siteUrl parameter when
            creating the meeting; if not specified, it's user's preferred site.
        :type allow_any_user_to_be_co_host: bool
        :param enabled_join_before_host: Whether or not to allow any attendee to join the meeting before the host joins
            the meeting.
        :type enabled_join_before_host: bool
        :param enable_connect_audio_before_host: Whether or not to allow any attendee to connect audio in the meeting
            before the host joins the meeting. This attribute is only applicable if the enabledJoinBeforeHost attribute
            is set to true.
        :type enable_connect_audio_before_host: bool
        :param join_before_host_minutes: The number of minutes an attendee can join the meeting before the meeting
            start time and the host joins. This attribute is only applicable if the enabledJoinBeforeHost attribute is
            set to true. Valid options are 0, 5, 10 and 15. Default is 0 if not specified.
        :type join_before_host_minutes: int
        :param exclude_password: Whether or not to exclude the meeting password from the email invitation.
        :type exclude_password: bool
        :param public_meeting: Whether or not to allow the meeting to be listed on the public calendar.
        :type public_meeting: bool
        :param reminder_time: The number of minutes before the meeting begins, that an email reminder is sent to the
            host.
        :type reminder_time: int
        :param unlocked_meeting_join_security: Specifies how the people who aren't on the invite can join the unlocked
            meeting.
        :type unlocked_meeting_join_security: UnlockedMeetingJoinSecurity
        :param session_type_id: Unique identifier for a meeting session type for the user. This attribute is required
            while scheduling webinar meeting. All available meeting session types enabled for the user can be retrieved
            by List Meeting Session Types API.
        :type session_type_id: int
        :param enabled_webcast_view: Whether or not webcast view is enabled.
        :type enabled_webcast_view: bool
        :param panelist_password: Password for panelists of a webinar meeting. Must conform to the site's password
            complexity settings. Read password management for details. If not specified, a random password conforming
            to the site's password rules will be generated automatically.
        :type panelist_password: str
        :param enable_automatic_lock: Whether or not to automatically lock the meeting after it starts.
        :type enable_automatic_lock: bool
        :param automatic_lock_minutes: The number of minutes after the meeting begins, for automatically locking it.
        :type automatic_lock_minutes: int
        :param allow_first_user_to_be_co_host: Whether or not to allow the first attendee of the meeting with a host
            account on the target site to become a cohost. The target site is specified by siteUrl parameter when
            creating the meeting; if not specified, it's user's preferred site.
        :type allow_first_user_to_be_co_host: bool
        :param allow_authenticated_devices: Whether or not to allow authenticated video devices in the meeting's
            organization to start or join the meeting without a prompt.
        :type allow_authenticated_devices: bool
        :param send_email: Whether or not to send emails to host and invitees. It is an optional field and default
            value is true.
        :type send_email: bool
        :param host_email: Email address for the meeting host. This attribute should only be set if the user or
            application calling the API has the admin-level scopes. When used, the admin may specify the email of a
            user in a site they manage to be the meeting host.
        :type host_email: str
        :param site_url: URL of the Webex site which the meeting is updated on. If not specified, the meeting is
            created on user's preferred site. All available Webex sites and preferred site of the user can be retrieved
            by Get Site List API.
        :type site_url: str
        :param meeting_options: Meeting Options.
        :type meeting_options: MeetingOptions
        :param attendee_privileges: Attendee Privileges.
        :type attendee_privileges: AttendeePrivileges
        :param integration_tags: External keys created by an integration application in its own domain, for example
            Zendesk ticket IDs, Jira IDs, Salesforce Opportunity IDs, etc. The integration application queries meetings
            by a key in its own domain. The maximum size of integrationTags is 3 and each item of integrationTags can
            be a maximum of 64 characters long. Please note that an empty or null integrationTags will delete all
            existing integration tags for the meeting implicitly. Developer can update integration tags for a
            meetingSeries but he cannot update it for a scheduledMeeting or a meeting instance.
        :type integration_tags: List[str]
        :param enabled_breakout_sessions: Whether or not breakout sessions are enabled. If the value of
            enabledBreakoutSessions is false, users can not set breakout sessions. If the value of
            enabledBreakoutSessions is true, users can update breakout sessions using the Update Breakout Sessions API.
            Updating breakout sessions are not supported by this API.
        :type enabled_breakout_sessions: bool
        :param tracking_codes: Tracking codes information. All available tracking codes and their options for the
            specified site can be retrieved by List Meeting Tracking Codes API. If an optional tracking code is missing
            from the trackingCodes array and there's a default option for this tracking code, the default option is
            assigned automatically. If the inputMode of a tracking code is select, its value must be one of the
            site-level options or the user-level value. Tracking code is not supported for a personal room meeting or
            an ad-hoc space meeting.
        :type tracking_codes: TrackingCodeItemForCreateMeetingObject
        :param audio_connection_options: Audio connection options.
        :type audio_connection_options: AudioConnectionOptions

        documentation: https://developer.webex.com/docs/api/v1/meetings/patch-a-meeting
        """
        body = PatchMeetingBody()
        if title is not None:
            body.title = title
        if agenda is not None:
            body.agenda = agenda
        if password is not None:
            body.password = password
        if start is not None:
            body.start = start
        if end is not None:
            body.end = end
        if timezone is not None:
            body.timezone = timezone
        if recurrence is not None:
            body.recurrence = recurrence
        if enabled_auto_record_meeting is not None:
            body.enabled_auto_record_meeting = enabled_auto_record_meeting
        if allow_any_user_to_be_co_host is not None:
            body.allow_any_user_to_be_co_host = allow_any_user_to_be_co_host
        if enabled_join_before_host is not None:
            body.enabled_join_before_host = enabled_join_before_host
        if enable_connect_audio_before_host is not None:
            body.enable_connect_audio_before_host = enable_connect_audio_before_host
        if join_before_host_minutes is not None:
            body.join_before_host_minutes = join_before_host_minutes
        if exclude_password is not None:
            body.exclude_password = exclude_password
        if public_meeting is not None:
            body.public_meeting = public_meeting
        if reminder_time is not None:
            body.reminder_time = reminder_time
        if unlocked_meeting_join_security is not None:
            body.unlocked_meeting_join_security = unlocked_meeting_join_security
        if session_type_id is not None:
            body.session_type_id = session_type_id
        if enabled_webcast_view is not None:
            body.enabled_webcast_view = enabled_webcast_view
        if panelist_password is not None:
            body.panelist_password = panelist_password
        if enable_automatic_lock is not None:
            body.enable_automatic_lock = enable_automatic_lock
        if automatic_lock_minutes is not None:
            body.automatic_lock_minutes = automatic_lock_minutes
        if allow_first_user_to_be_co_host is not None:
            body.allow_first_user_to_be_co_host = allow_first_user_to_be_co_host
        if allow_authenticated_devices is not None:
            body.allow_authenticated_devices = allow_authenticated_devices
        if send_email is not None:
            body.send_email = send_email
        if host_email is not None:
            body.host_email = host_email
        if site_url is not None:
            body.site_url = site_url
        if meeting_options is not None:
            body.meeting_options = meeting_options
        if attendee_privileges is not None:
            body.attendee_privileges = attendee_privileges
        if integration_tags is not None:
            body.integration_tags = integration_tags
        if enabled_breakout_sessions is not None:
            body.enabled_breakout_sessions = enabled_breakout_sessions
        if tracking_codes is not None:
            body.tracking_codes = tracking_codes
        if audio_connection_options is not None:
            body.audio_connection_options = audio_connection_options
        url = self.ep(f'{meeting_id}')
        data = super().patch(url=url, data=body.json())
        return PatchMeetingResponse.parse_obj(data)

    def update(self, meeting_id: str, title: str = None, agenda: str = None, password: str = None, start: str = None, end: str = None, timezone: str = None, recurrence: str = None, enabled_auto_record_meeting: bool = None, allow_any_user_to_be_co_host: bool = None, enabled_join_before_host: bool = None, enable_connect_audio_before_host: bool = None, join_before_host_minutes: int = None, exclude_password: bool = None, public_meeting: bool = None, reminder_time: int = None, unlocked_meeting_join_security: UnlockedMeetingJoinSecurity = None, session_type_id: int = None, enabled_webcast_view: bool = None, panelist_password: str = None, enable_automatic_lock: bool = None, automatic_lock_minutes: int = None, allow_first_user_to_be_co_host: bool = None, allow_authenticated_devices: bool = None, send_email: bool = None, host_email: str = None, site_url: str = None, meeting_options: MeetingOptions = None, attendee_privileges: AttendeePrivileges = None, integration_tags: List[str] = None, enabled_breakout_sessions: bool = None, tracking_codes: TrackingCodeItemForCreateMeetingObject = None, audio_connection_options: AudioConnectionOptions = None) -> PatchMeetingResponse:
        """
        Updates details for a meeting with a specified meeting ID. This operation applies to meeting series and
        scheduled meetings. It doesn't apply to ended or in-progress meeting instances. Ad-hoc meetings created by
        Create a Meeting with adhoc of true and a roomId cannot be updated.

        :param meeting_id: Unique identifier for the meeting to be updated. This parameter applies to meeting series
            and scheduled meetings. It doesn't apply to ended or in-progress meeting instances. Please note that
            currently meeting ID of a scheduled personal room meeting is not supported for this API.
        :type meeting_id: str
        :param title: Meeting title. The title can be a maximum of 128 characters long.
        :type title: str
        :param agenda: Meeting agenda. The agenda can be a maximum of 1300 characters long.
        :type agenda: str
        :param password: Meeting password. Must conform to the site's password complexity settings. Read password
            management for details.
        :type password: str
        :param start: Date and time for the start of meeting in any ISO 8601 compliant format. start cannot be before
            current date and time or after end. Duration between start and end cannot be shorter than 10 minutes or
            longer than 24 hours. Refer to the Webex Meetings guide for more information about restrictions on updating
            date and time for a meeting. Please note that when a meeting is being updated, start of the meeting will be
            accurate to minutes, not seconds or milliseconds. Therefore, if start is within the same minute as the
            current time, start will be adjusted to the upcoming minute; otherwise, start will be adjusted with seconds
            and milliseconds stripped off. For instance, if the current time is 2022-03-01T10:32:16.657+08:00, start of
            2022-03-01T10:32:28.076+08:00 or 2022-03-01T10:32:41+08:00 will be adjusted to 2022-03-01T10:33:00+08:00,
            and start of 2022-03-01T11:32:28.076+08:00 or 2022-03-01T11:32:41+08:00 will be adjusted to
            2022-03-01T11:32:00+08:00.
        :type start: str
        :param end: Date and time for the end of meeting in any ISO 8601 compliant format. end cannot be before current
            date and time or before start. Duration between start and end cannot be shorter than 10 minutes or longer
            than 24 hours. Refer to the Webex Meetings guide for more information about restrictions on updating date
            and time for a meeting. Please note that when a meeting is being updated, end of the meeting will be
            accurate to minutes, not seconds or milliseconds. Therefore, end will be adjusted with seconds and
            milliseconds stripped off. For instance, end of 2022-03-01T11:52:28.076+08:00 or 2022-03-01T11:52:41+08:00
            will be adjusted to 2022-03-01T11:52:00+08:00.
        :type end: str
        :param timezone: Time zone in which the meeting was originally scheduled (conforming with the IANA time zone
            database).
        :type timezone: str
        :param recurrence: Meeting series recurrence rule (conforming with RFC 2445). Applies only to a recurring
            meeting series, not to a meeting series with only one scheduled meeting. Multiple days or dates for monthly
            or yearly recurrence rule are not supported, only the first day or date specified is taken. For example,
            "FREQ=MONTHLY;INTERVAL=1;COUNT=10;BYMONTHDAY=10,11,12" is not supported and it will be partially supported
            as "FREQ=MONTHLY;INTERVAL=1;COUNT=10;BYMONTHDAY=10".
        :type recurrence: str
        :param enabled_auto_record_meeting: Whether or not meeting is recorded automatically.
        :type enabled_auto_record_meeting: bool
        :param allow_any_user_to_be_co_host: Whether or not to allow any attendee with a host account on the target
            site to become a cohost when joining the meeting. The target site is specified by siteUrl parameter when
            creating the meeting; if not specified, it's user's preferred site.
        :type allow_any_user_to_be_co_host: bool
        :param enabled_join_before_host: Whether or not to allow any attendee to join the meeting before the host joins
            the meeting.
        :type enabled_join_before_host: bool
        :param enable_connect_audio_before_host: Whether or not to allow any attendee to connect audio in the meeting
            before the host joins the meeting. This attribute is only applicable if the enabledJoinBeforeHost attribute
            is set to true.
        :type enable_connect_audio_before_host: bool
        :param join_before_host_minutes: The number of minutes an attendee can join the meeting before the meeting
            start time and the host joins. This attribute is only applicable if the enabledJoinBeforeHost attribute is
            set to true. Valid options are 0, 5, 10 and 15. Default is 0 if not specified.
        :type join_before_host_minutes: int
        :param exclude_password: Whether or not to exclude the meeting password from the email invitation.
        :type exclude_password: bool
        :param public_meeting: Whether or not to allow the meeting to be listed on the public calendar.
        :type public_meeting: bool
        :param reminder_time: The number of minutes before the meeting begins, that an email reminder is sent to the
            host.
        :type reminder_time: int
        :param unlocked_meeting_join_security: Specifies how the people who aren't on the invite can join the unlocked
            meeting.
        :type unlocked_meeting_join_security: UnlockedMeetingJoinSecurity
        :param session_type_id: Unique identifier for a meeting session type for the user. This attribute is required
            while scheduling webinar meeting. All available meeting session types enabled for the user can be retrieved
            by List Meeting Session Types API.
        :type session_type_id: int
        :param enabled_webcast_view: Whether or not webcast view is enabled.
        :type enabled_webcast_view: bool
        :param panelist_password: Password for panelists of a webinar meeting. Must conform to the site's password
            complexity settings. Read password management for details. If not specified, a random password conforming
            to the site's password rules will be generated automatically.
        :type panelist_password: str
        :param enable_automatic_lock: Whether or not to automatically lock the meeting after it starts.
        :type enable_automatic_lock: bool
        :param automatic_lock_minutes: The number of minutes after the meeting begins, for automatically locking it.
        :type automatic_lock_minutes: int
        :param allow_first_user_to_be_co_host: Whether or not to allow the first attendee of the meeting with a host
            account on the target site to become a cohost. The target site is specified by siteUrl parameter when
            creating the meeting; if not specified, it's user's preferred site.
        :type allow_first_user_to_be_co_host: bool
        :param allow_authenticated_devices: Whether or not to allow authenticated video devices in the meeting's
            organization to start or join the meeting without a prompt.
        :type allow_authenticated_devices: bool
        :param send_email: Whether or not to send emails to host and invitees. It is an optional field and default
            value is true.
        :type send_email: bool
        :param host_email: Email address for the meeting host. This attribute should only be set if the user or
            application calling the API has the admin-level scopes. When used, the admin may specify the email of a
            user in a site they manage to be the meeting host.
        :type host_email: str
        :param site_url: URL of the Webex site which the meeting is updated on. If not specified, the meeting is
            created on user's preferred site. All available Webex sites and preferred site of the user can be retrieved
            by Get Site List API.
        :type site_url: str
        :param meeting_options: Meeting Options.
        :type meeting_options: MeetingOptions
        :param attendee_privileges: Attendee Privileges.
        :type attendee_privileges: AttendeePrivileges
        :param integration_tags: External keys created by an integration application in its own domain, for example
            Zendesk ticket IDs, Jira IDs, Salesforce Opportunity IDs, etc. The integration application queries meetings
            by a key in its own domain. The maximum size of integrationTags is 3 and each item of integrationTags can
            be a maximum of 64 characters long. Please note that an empty or null integrationTags will delete all
            existing integration tags for the meeting implicitly. Developer can update integration tags for a
            meetingSeries but he cannot update it for a scheduledMeeting or a meeting instance.
        :type integration_tags: List[str]
        :param enabled_breakout_sessions: Whether or not breakout sessions are enabled. If the value of
            enabledBreakoutSessions is false, users can not set breakout sessions. If the value of
            enabledBreakoutSessions is true, users can update breakout sessions using the Update Breakout Sessions API.
            Updating breakout sessions are not supported by this API.
        :type enabled_breakout_sessions: bool
        :param tracking_codes: Tracking codes information. All available tracking codes and their options for the
            specified site can be retrieved by List Meeting Tracking Codes API. If an optional tracking code is missing
            from the trackingCodes array and there's a default option for this tracking code, the default option is
            assigned automatically. If the inputMode of a tracking code is select, its value must be one of the
            site-level options or the user-level value. Tracking code is not supported for a personal room meeting or
            an ad-hoc space meeting.
        :type tracking_codes: TrackingCodeItemForCreateMeetingObject
        :param audio_connection_options: Audio connection options.
        :type audio_connection_options: AudioConnectionOptions

        documentation: https://developer.webex.com/docs/api/v1/meetings/update-a-meeting
        """
        body = PatchMeetingBody()
        if title is not None:
            body.title = title
        if agenda is not None:
            body.agenda = agenda
        if password is not None:
            body.password = password
        if start is not None:
            body.start = start
        if end is not None:
            body.end = end
        if timezone is not None:
            body.timezone = timezone
        if recurrence is not None:
            body.recurrence = recurrence
        if enabled_auto_record_meeting is not None:
            body.enabled_auto_record_meeting = enabled_auto_record_meeting
        if allow_any_user_to_be_co_host is not None:
            body.allow_any_user_to_be_co_host = allow_any_user_to_be_co_host
        if enabled_join_before_host is not None:
            body.enabled_join_before_host = enabled_join_before_host
        if enable_connect_audio_before_host is not None:
            body.enable_connect_audio_before_host = enable_connect_audio_before_host
        if join_before_host_minutes is not None:
            body.join_before_host_minutes = join_before_host_minutes
        if exclude_password is not None:
            body.exclude_password = exclude_password
        if public_meeting is not None:
            body.public_meeting = public_meeting
        if reminder_time is not None:
            body.reminder_time = reminder_time
        if unlocked_meeting_join_security is not None:
            body.unlocked_meeting_join_security = unlocked_meeting_join_security
        if session_type_id is not None:
            body.session_type_id = session_type_id
        if enabled_webcast_view is not None:
            body.enabled_webcast_view = enabled_webcast_view
        if panelist_password is not None:
            body.panelist_password = panelist_password
        if enable_automatic_lock is not None:
            body.enable_automatic_lock = enable_automatic_lock
        if automatic_lock_minutes is not None:
            body.automatic_lock_minutes = automatic_lock_minutes
        if allow_first_user_to_be_co_host is not None:
            body.allow_first_user_to_be_co_host = allow_first_user_to_be_co_host
        if allow_authenticated_devices is not None:
            body.allow_authenticated_devices = allow_authenticated_devices
        if send_email is not None:
            body.send_email = send_email
        if host_email is not None:
            body.host_email = host_email
        if site_url is not None:
            body.site_url = site_url
        if meeting_options is not None:
            body.meeting_options = meeting_options
        if attendee_privileges is not None:
            body.attendee_privileges = attendee_privileges
        if integration_tags is not None:
            body.integration_tags = integration_tags
        if enabled_breakout_sessions is not None:
            body.enabled_breakout_sessions = enabled_breakout_sessions
        if tracking_codes is not None:
            body.tracking_codes = tracking_codes
        if audio_connection_options is not None:
            body.audio_connection_options = audio_connection_options
        url = self.ep(f'{meeting_id}')
        data = super().put(url=url, data=body.json())
        return PatchMeetingResponse.parse_obj(data)

    def delete(self, meeting_id: str, host_email: str = None, send_email: bool = None):
        """
        Deletes a meeting with a specified meeting ID. The deleted meeting cannot be recovered. This operation applies
        to meeting series and scheduled meetings. It doesn't apply to ended or in-progress meeting instances. Ad-hoc
        meetings created by Create a Meeting with adhoc of true and a roomId cannot be deleted.

        :param meeting_id: Unique identifier for the meeting to be deleted. This parameter applies to meeting series
            and scheduled meetings. It doesn't apply to ended or in-progress meeting instances.
        :type meeting_id: str
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin-level scopes. If set, the admin may specify the email of a user in a site
            they manage and the API will delete a meeting that is hosted by that user.
        :type host_email: str
        :param send_email: Whether or not to send emails to host and invitees. It is an optional field and default
            value is true.
        :type send_email: bool

        documentation: https://developer.webex.com/docs/api/v1/meetings/delete-a-meeting
        """
        params = {}
        if host_email is not None:
            params['hostEmail'] = host_email
        if send_email is not None:
            params['sendEmail'] = str(send_email).lower()
        url = self.ep(f'{meeting_id}')
        super().delete(url=url, params=params)
        return

    def join(self, email: str = None, display_name: str = None, meeting_id: str = None, meeting_number: str = None, web_link: str = None, join_directly: bool = None, password: str = None, expiration_minutes: int = None) -> JoinMeetingResponse:
        """
        Retrieves links for a meeting with a specified meetingId, meetingNumber, or webLink that allow users to start
        or join the meeting directly without logging in and entering a password.

        :param email: Email address for cohost. This attribute can be modified with the Update Personal Meeting Room
            Options API. Possible values: john.andersen@example.com
        :type email: str
        :param display_name: Display name for cohost. This attribute can be modified with the Update Personal Meeting
            Room Options API. Possible values: John Andersen
        :type display_name: str
        :param meeting_id: Unique identifier for the meeting. This parameter applies to meeting series and scheduled
            meetings. It doesn't apply to ended or in-progress meeting instances. Please note that currently meeting ID
            of a scheduled personal room meeting is also supported for this API.
        :type meeting_id: str
        :param meeting_number: Meeting number. Applies to meeting series, scheduled meeting, and meeting instances, but
            not to meeting instances which have ended.
        :type meeting_number: str
        :param web_link: Link to a meeting information page where the meeting client is launched if the meeting is
            ready to start or join.
        :type web_link: str
        :param join_directly: Whether or not to redirect to joinLink. It is an optional field and default value is
            true.
        :type join_directly: bool
        :param password: It's required when the meeting is protected by a password and the current user is not
            privileged to view it if they are not a host, cohost or invitee of the meeting.
        :type password: str
        :param expiration_minutes: Expiration duration of joinLink in minutes. Must be between 1 and 60.
        :type expiration_minutes: int

        documentation: https://developer.webex.com/docs/api/v1/meetings/join-a-meeting
        """
        body = JoinMeetingBody()
        if email is not None:
            body.email = email
        if display_name is not None:
            body.display_name = display_name
        if meeting_id is not None:
            body.meeting_id = meeting_id
        if meeting_number is not None:
            body.meeting_number = meeting_number
        if web_link is not None:
            body.web_link = web_link
        if join_directly is not None:
            body.join_directly = join_directly
        if password is not None:
            body.password = password
        if expiration_minutes is not None:
            body.expiration_minutes = expiration_minutes
        url = self.ep('join')
        data = super().post(url=url, data=body.json())
        return JoinMeetingResponse.parse_obj(data)

    def list_templates(self, template_type: str = None, locale: str = None, is_default: bool = None, is_standard: bool = None, host_email: str = None, site_url: str = None) -> list[TemplateObject]:
        """
        Retrieves the list of meeting templates that is available for the authenticated user.
        There are separate lists of meeting templates for different templateType, locale and siteUrl.

        :param template_type: Meeting template type for the meeting template objects being requested. If not specified,
            return meeting templates of all types. Possible values: meeting, webinar
        :type template_type: str
        :param locale: Locale for the meeting template objects being requested. If not specified, return meeting
            templates of the default en_US locale. Refer to Meeting Template Locales for all the locales supported by
            Webex.
        :type locale: str
        :param is_default: The value is true or false. If it's true, return the default meeting templates; if it's
            false, return the non-default meeting templates. If it's not specified, return both default and non-default
            meeting templates.
        :type is_default: bool
        :param is_standard: The value is true or false. If it's true, return the standard meeting templates; if it's
            false, return the non-standard meeting templates. If it's not specified, return both standard and
            non-standard meeting templates.
        :type is_standard: bool
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin-level scopes. If set, the admin may specify the email of a user in a site
            they manage and the API will return meeting templates that are available for that user.
        :type host_email: str
        :param site_url: URL of the Webex site which the API lists meeting templates from. If not specified, the API
            lists meeting templates from user's preferred site. All available Webex sites and preferred site of the
            user can be retrieved by Get Site List API.
        :type site_url: str

        documentation: https://developer.webex.com/docs/api/v1/meetings/list-meeting-templates
        """
        params = {}
        if template_type is not None:
            params['templateType'] = template_type
        if locale is not None:
            params['locale'] = locale
        if is_default is not None:
            params['isDefault'] = str(is_default).lower()
        if is_standard is not None:
            params['isStandard'] = str(is_standard).lower()
        if host_email is not None:
            params['hostEmail'] = host_email
        if site_url is not None:
            params['siteUrl'] = site_url
        url = self.ep('templates')
        data = super().get(url=url, params=params)
        return parse_obj_as(list[TemplateObject], data["items"])

    def template(self, template_id: str, host_email: str = None) -> GetMeetingTemplateResponse:
        """
        Retrieves details for a meeting template with a specified meeting template ID.

        :param template_id: Unique identifier for the meeting template being requested.
        :type template_id: str
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin-level scopes. If set, the admin may specify the email of a user in a site
            they manage and the API will return the meeting template that is available for that user.
        :type host_email: str

        documentation: https://developer.webex.com/docs/api/v1/meetings/get-a-meeting-template
        """
        params = {}
        if host_email is not None:
            params['hostEmail'] = host_email
        url = self.ep(f'templates/{template_id}')
        data = super().get(url=url, params=params)
        return GetMeetingTemplateResponse.parse_obj(data)

    def control_status(self, meeting_id: str) -> GetMeetingControlStatusResponse:
        """
        Get the meeting control of a live meeting, which is consisted of meeting control status on "locked" and
        "recording" to reflect whether the meeting is currently locked and there is recording in progress.

        :param meeting_id: Unique identifier for the meeting. Does not support meeting IDs for a scheduled personal
            room meeting.
        :type meeting_id: str

        documentation: https://developer.webex.com/docs/api/v1/meetings/get-meeting-control-status
        """
        params = {}
        params['meetingId'] = meeting_id
        url = self.ep('controls')
        data = super().get(url=url, params=params)
        return GetMeetingControlStatusResponse.parse_obj(data)

    def update_control_status(self, meeting_id: str, locked: bool = None, recording_started: bool = None, recording_paused: bool = None) -> GetMeetingControlStatusResponse:
        """
        To start, pause, resume, or stop a meeting recording; To lock or unlock an on-going meeting.

        :param meeting_id: Unique identifier for the meeting. Does not support meeting IDs for a scheduled personal
            room meeting.
        :type meeting_id: str
        :param locked: Whether the meeting is locked or not.
        :type locked: bool
        :param recording_started: The value can be true or false, it indicates the meeting recording started or not.
        :type recording_started: bool
        :param recording_paused: The value can be true or false, it indicates the meeting recording paused or not.
        :type recording_paused: bool

        documentation: https://developer.webex.com/docs/api/v1/meetings/update-meeting-control-status
        """
        params = {}
        params['meetingId'] = meeting_id
        body = GetMeetingControlStatusResponse()
        if locked is not None:
            body.locked = locked
        if recording_started is not None:
            body.recording_started = recording_started
        if recording_paused is not None:
            body.recording_paused = recording_paused
        url = self.ep('controls')
        data = super().put(url=url, params=params, data=body.json())
        return GetMeetingControlStatusResponse.parse_obj(data)

    def list_session_types(self, host_email: str = None, site_url: str = None) -> list[MeetingSessionTypeObject]:
        """
        List all the meeting session types enabled for a given user.

        :param host_email: Email address for the user. This parameter is only used if the user or application calling
            the API has the admin-level scopes. If set, the admin may specify the email of a user in a site they manage
            and the API will list all the meeting session types enabled for the user.
        :type host_email: str
        :param site_url: Webex site URL to query. If siteUrl is not specified, the users' preferred site will be used.
            If the authorization token has the admin-level scopes, the admin can set the Webex site URL on behalf of
            the user specified in the hostEmail parameter.
        :type site_url: str

        documentation: https://developer.webex.com/docs/api/v1/meetings/list-meeting-session-types
        """
        params = {}
        if host_email is not None:
            params['hostEmail'] = host_email
        if site_url is not None:
            params['siteUrl'] = site_url
        url = self.ep('sessionTypes')
        data = super().get(url=url, params=params)
        return parse_obj_as(list[MeetingSessionTypeObject], data["items"])

    def session_type(self, session_type_id: int, host_email: str = None, site_url: str = None) -> MeetingSessionTypeObject:
        """
        Retrieves details for a meeting session type with a specified session type ID.

        :param session_type_id: A unique identifier for the sessionType.
        :type session_type_id: int
        :param host_email: Email address for the user. This parameter is only used if the user or application calling
            the API has the admin-level scopes. If set, the admin may specify the email of a user in a site they manage
            and the API will get a meeting session type with the specified session type ID enabled for the user.
        :type host_email: str
        :param site_url: Webex site URL to query. If siteUrl is not specified, the users' preferred site will be used.
            If the authorization token has the admin-level scopes, the admin can set the Webex site URL on behalf of
            the user specified in the hostEmail parameter.
        :type site_url: str

        documentation: https://developer.webex.com/docs/api/v1/meetings/get-a-meeting-session-type
        """
        params = {}
        if host_email is not None:
            params['hostEmail'] = host_email
        if site_url is not None:
            params['siteUrl'] = site_url
        url = self.ep(f'sessionTypes/{session_type_id}')
        data = super().get(url=url, params=params)
        return MeetingSessionTypeObject.parse_obj(data)

    def registration_form_formeeting(self, meeting_id: str, current: bool = None, host_email: str = None) -> GetRegistrationFormFormeetingResponse:
        """
        Get a meeting's registration form to understand which fields are required.

        :param meeting_id: Unique identifier for the meeting. Only the ID of the meeting series is supported for
            meetingId. IDs of scheduled meetings, meeting instances, or scheduled personal room meetings are not
            supported. See the Meetings Overview for more information about meeting types.
        :type meeting_id: str
        :param current: Whether or not to retrieve only the current scheduled meeting of the meeting series, i.e. the
            meeting ready to join or start or the upcoming meeting of the meeting series. If it's true, return details
            for the current scheduled meeting of the series, i.e. the scheduled meeting ready to join or start or the
            upcoming scheduled meeting of the meeting series. If it's false or not specified, return details for the
            entire meeting series. This parameter only applies to meeting series.
        :type current: bool
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin-level scopes. If set, the admin may specify the email of a user in a site
            they manage and the API will return details for a meeting that is hosted by that user.
        :type host_email: str

        documentation: https://developer.webex.com/docs/api/v1/meetings/get-registration-form-for-a-meeting
        """
        params = {}
        if current is not None:
            params['current'] = str(current).lower()
        if host_email is not None:
            params['hostEmail'] = host_email
        url = self.ep(f'{meeting_id}/registration')
        data = super().get(url=url, params=params)
        return GetRegistrationFormFormeetingResponse.parse_obj(data)

    def update_registration_form(self, meeting_id: str, host_email: str = None, require_first_name: bool = None, require_last_name: bool = None, require_email: bool = None, require_job_title: bool = None, require_company_name: bool = None, require_address1: bool = None, require_address2: bool = None, require_city: bool = None, require_state: bool = None, require_zip_code: bool = None, require_country_region: bool = None, require_work_phone: bool = None, require_fax: bool = None, max_register_num: int = None, customized_questions: CustomizedQuestionForCreateMeeting = None, rules: StandardRegistrationApproveRule = None) -> GetRegistrationFormFormeetingResponse:
        """
        Enable or update a registration form for a meeting.

        :param meeting_id: Unique identifier for the meeting. Only the ID of the meeting series is supported for
            meetingId. IDs of scheduled meetings, meeting instances, or scheduled personal room meetings are not
            supported. See the Meetings Overview for more information about meeting types.
        :type meeting_id: str
        :param host_email:   * Email address for the meeting host. This parameter is only used if the user or
                application calling the API has the admin-level scopes. If set, the admin may specify the email of a
                user in a site they manage and the API will return an update for a meeting that is hosted by that user.
        :type host_email: str
        :param require_first_name: Whether or not a registrant's first name is required for meeting registration. This
            option must always be true.
        :type require_first_name: bool
        :param require_last_name: Whether or not a registrant's last name is required for meeting registration. This
            option must always be true.
        :type require_last_name: bool
        :param require_email: Whether or not a registrant's email is required for meeting registration. This option
            must always be true.
        :type require_email: bool
        :param require_job_title: Whether or not a registrant's job title is shown or required for meeting
            registration.
        :type require_job_title: bool
        :param require_company_name: Whether or not a registrant's company name is shown or required for meeting
            registration.
        :type require_company_name: bool
        :param require_address1: Whether or not a registrant's first address field is shown or required for meeting
            registration.
        :type require_address1: bool
        :param require_address2: Whether or not a registrant's second address field is shown or required for meeting
            registration.
        :type require_address2: bool
        :param require_city: Whether or not a registrant's city is shown or required for meeting registration.
        :type require_city: bool
        :param require_state: Whether or not a registrant's state is shown or required for meeting registration.
        :type require_state: bool
        :param require_zip_code: Whether or not a registrant's postal code is shown or required for meeting
            registration.
        :type require_zip_code: bool
        :param require_country_region: Whether or not a registrant's country or region is shown or required for meeting
            registration.
        :type require_country_region: bool
        :param require_work_phone: Whether or not a registrant's work phone number is shown or required for meeting
            registration.
        :type require_work_phone: bool
        :param require_fax: Whether or not a registrant's fax number is shown or required for meeting registration.
        :type require_fax: bool
        :param max_register_num: Maximum number of meeting registrations. This only applies to meetings. The maximum
            number of participants for meetings and webinars, with the limit based on the user capacity and controlled
            by a toggle at the site level. The default maximum number of participants for webinars is 10000, but the
            actual maximum number of participants is limited by the user capacity.
        :type max_register_num: int
        :param customized_questions: Customized questions for meeting registration.
        :type customized_questions: CustomizedQuestionForCreateMeeting
        :param rules: The approval rule for standard questions.
        :type rules: StandardRegistrationApproveRule

        documentation: https://developer.webex.com/docs/api/v1/meetings/update-meeting-registration-form
        """
        body = UpdateMeetingRegistrationFormBody()
        if host_email is not None:
            body.host_email = host_email
        if require_first_name is not None:
            body.require_first_name = require_first_name
        if require_last_name is not None:
            body.require_last_name = require_last_name
        if require_email is not None:
            body.require_email = require_email
        if require_job_title is not None:
            body.require_job_title = require_job_title
        if require_company_name is not None:
            body.require_company_name = require_company_name
        if require_address1 is not None:
            body.require_address1 = require_address1
        if require_address2 is not None:
            body.require_address2 = require_address2
        if require_city is not None:
            body.require_city = require_city
        if require_state is not None:
            body.require_state = require_state
        if require_zip_code is not None:
            body.require_zip_code = require_zip_code
        if require_country_region is not None:
            body.require_country_region = require_country_region
        if require_work_phone is not None:
            body.require_work_phone = require_work_phone
        if require_fax is not None:
            body.require_fax = require_fax
        if max_register_num is not None:
            body.max_register_num = max_register_num
        if customized_questions is not None:
            body.customized_questions = customized_questions
        if rules is not None:
            body.rules = rules
        url = self.ep(f'{meeting_id}/registration')
        data = super().put(url=url, data=body.json())
        return GetRegistrationFormFormeetingResponse.parse_obj(data)

    def delete_registration_form(self, meeting_id: str):
        """
        Disable the registration form for a meeting.

        :param meeting_id: Unique identifier for the meeting. Only the ID of the meeting series is supported for
            meetingId. IDs of scheduled meetings, meeting instances, or scheduled personal room meetings are not
            supported. See the Meetings Overview for more information about meeting types.
        :type meeting_id: str

        documentation: https://developer.webex.com/docs/api/v1/meetings/delete-meeting-registration-form
        """
        url = self.ep(f'{meeting_id}/registration')
        super().delete(url=url)
        return

    def register_registrant(self, meeting_id: str, first_name: str, current: bool = None, host_email: str = None, last_name: str = None, email: str = None, job_title: str = None, company_name: str = None, address1: str = None, address2: str = None, city: str = None, state: str = None, zip_code: str = None, country_region: str = None, work_phone: str = None, fax: str = None, send_email: bool = None, customized_questions: CustomizedRegistrant = None) -> RegisterMeetingRegistrantResponse:
        """
        Register a new registrant for a meeting.

        :param meeting_id: Unique identifier for the meeting. Only the ID of the meeting series is supported for
            meetingId. IDs of scheduled meetings, meeting instances, or scheduled personal room meetings are not
            supported. See the Meetings Overview for more information about meeting types.
        :type meeting_id: str
        :param first_name: The registrant's first name.
        :type first_name: str
        :param current: Whether or not to retrieve only the current scheduled meeting of the meeting series, i.e. the
            meeting ready to join or start or the upcoming meeting of the meeting series. If it's true, return details
            for the current scheduled meeting of the series, i.e. the scheduled meeting ready to join or start or the
            upcoming scheduled meeting of the meeting series. If it's false or not specified, return details for the
            entire meeting series. This parameter only applies to meeting series.
        :type current: bool
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin-level scopes. If set, the admin may specify the email of a user in a site
            they manage and the API will return details for a meeting that is hosted by that user.
        :type host_email: str
        :param last_name: If the value is lastName, this approval rule applies to the standard question of "Last Name".
        :type last_name: str
        :param email: If the value is email, this approval rule applies to the standard question of "Email".
        :type email: str
        :param job_title: If the value is jobTitle, this approval rule applies to the standard question of "Job Title".
        :type job_title: str
        :param company_name: If the value is companyName, this approval rule applies to the standard question of
            "Company Name".
        :type company_name: str
        :param address1: If the value is address1, this approval rule applies to the standard question of "Address 1".
        :type address1: str
        :param address2: If the value is address2, this approval rule applies to the standard question of "Address 2".
        :type address2: str
        :param city: If the value is city, this approval rule applies to the standard question of "City".
        :type city: str
        :param state: If the value is state, this approval rule applies to the standard question of "State".
        :type state: str
        :param zip_code: If the value is zipCode, this approval rule applies to the standard question of "Zip/Post
            Code".
        :type zip_code: str
        :param country_region: If the value is countryRegion, this approval rule applies to the standard question of
            "Country Region".
        :type country_region: str
        :param work_phone: If the value is workPhone, this approval rule applies to the standard question of "Work
            Phone".
        :type work_phone: str
        :param fax: If the value is fax, this approval rule applies to the standard question of "Fax".
        :type fax: str
        :param send_email: If true send email to the registrant. Default: true.
        :type send_email: bool
        :param customized_questions: The registrant's answers for customized questions. Registration options define
            whether or not this is required.
        :type customized_questions: CustomizedRegistrant

        documentation: https://developer.webex.com/docs/api/v1/meetings/register-a-meeting-registrant
        """
        params = {}
        if current is not None:
            params['current'] = str(current).lower()
        if host_email is not None:
            params['hostEmail'] = host_email
        body = RegisterMeetingRegistrantBody()
        if first_name is not None:
            body.first_name = first_name
        if last_name is not None:
            body.last_name = last_name
        if email is not None:
            body.email = email
        if job_title is not None:
            body.job_title = job_title
        if company_name is not None:
            body.company_name = company_name
        if address1 is not None:
            body.address1 = address1
        if address2 is not None:
            body.address2 = address2
        if city is not None:
            body.city = city
        if state is not None:
            body.state = state
        if zip_code is not None:
            body.zip_code = zip_code
        if country_region is not None:
            body.country_region = country_region
        if work_phone is not None:
            body.work_phone = work_phone
        if fax is not None:
            body.fax = fax
        if send_email is not None:
            body.send_email = send_email
        if customized_questions is not None:
            body.customized_questions = customized_questions
        url = self.ep(f'{meeting_id}/registrants')
        data = super().post(url=url, params=params, data=body.json())
        return RegisterMeetingRegistrantResponse.parse_obj(data)

    def batch_register_registrants(self, meeting_id: str, current: bool = None, host_email: str = None, items: RegisterMeetingRegistrantBody = None) -> list[RegisterMeetingRegistrantResponse]:
        """
        Bulk register new registrants for a meeting.

        :param meeting_id: Unique identifier for the meeting. Only the ID of the meeting series is supported for
            meetingId. IDs of scheduled meetings, meeting instances, or scheduled personal room meetings are not
            supported. See the Meetings Overview for more information about meeting types.
        :type meeting_id: str
        :param current: Whether or not to retrieve only the current scheduled meeting of the meeting series, i.e. the
            meeting ready to join or start or the upcoming meeting of the meeting series. If it's true, return details
            for the current scheduled meeting of the series, i.e. the scheduled meeting ready to join or start or the
            upcoming scheduled meeting of the meeting series. If it's false or not specified, return details for the
            entire meeting series. This parameter only applies to meeting series.
        :type current: bool
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin-level scopes. If set, the admin may specify the email of a user in a site
            they manage and the API will return details for a meeting that is hosted by that user.
        :type host_email: str
        :param items: Registrants array.
        :type items: RegisterMeetingRegistrantBody

        documentation: https://developer.webex.com/docs/api/v1/meetings/batch-register-meeting-registrants
        """
        params = {}
        if current is not None:
            params['current'] = str(current).lower()
        if host_email is not None:
            params['hostEmail'] = host_email
        body = BatchRegisterMeetingRegistrantsBody()
        if items is not None:
            body.items = items
        url = self.ep(f'{meeting_id}/registrants/bulkInsert')
        data = super().post(url=url, params=params, data=body.json())
        return parse_obj_as(list[RegisterMeetingRegistrantResponse], data["items"])

    def detailed_information_for_registrant(self, meeting_id: str, registrant_id: str, current: bool = None, host_email: str = None) -> GetDetailedInformationForMeetingRegistrantResponse:
        """
        Retrieves details for a meeting registrant with a specified registrant Id.

        :param meeting_id: Unique identifier for the meeting. Only the ID of the meeting series is supported for
            meetingId. IDs of scheduled meetings, meeting instances, or scheduled personal room meetings are not
            supported. See the Meetings Overview for more information about meeting types.
        :type meeting_id: str
        :param registrant_id: Unique identifier for the registrant
        :type registrant_id: str
        :param current: Whether or not to retrieve only the current scheduled meeting of the meeting series, i.e. the
            meeting ready to join or start or the upcoming meeting of the meeting series. If it's true, return details
            for the current scheduled meeting of the series, i.e. the scheduled meeting ready to join or start or the
            upcoming scheduled meeting of the meeting series. If it's false or not specified, return details for the
            entire meeting series. This parameter only applies to meeting series.
        :type current: bool
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin-level scopes. If set, the admin may specify the email of a user in a site
            they manage and the API will return details for a meeting that is hosted by that user.
        :type host_email: str

        documentation: https://developer.webex.com/docs/api/v1/meetings/get-detailed-information-for-a-meeting-registrant
        """
        params = {}
        if current is not None:
            params['current'] = str(current).lower()
        if host_email is not None:
            params['hostEmail'] = host_email
        url = self.ep(f'{meeting_id}/registrants/{registrant_id}')
        data = super().get(url=url, params=params)
        return GetDetailedInformationForMeetingRegistrantResponse.parse_obj(data)

    def list_registrants(self, meeting_id: str, host_email: str = None, current: bool = None, email: str = None, registration_time_from: str = None, registration_time_to: str = None, **params) -> Generator[GetDetailedInformationForMeetingRegistrantResponse, None, None]:
        """
        Meeting's host and cohost can retrieve the list of registrants for a meeting with a specified meeting Id.

        :param meeting_id: Unique identifier for the meeting. Only the ID of the meeting series is supported for
            meetingId. IDs of scheduled meetings, meeting instances, or scheduled personal room meetings are not
            supported. See the Meetings Overview for more information about meeting types.
        :type meeting_id: str
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin-level scopes. If set, the admin may specify the email of a user in a site
            they manage and the API will return details for a meeting that is hosted by that user.
        :type host_email: str
        :param current: Whether or not to retrieve only the current scheduled meeting of the meeting series, i.e. the
            meeting ready to join or start or the upcoming meeting of the meeting series. If it's true, return details
            for the current scheduled meeting of the series, i.e. the scheduled meeting ready to join or start or the
            upcoming scheduled meeting of the meeting series. If it's false or not specified, return details for the
            entire meeting series. This parameter only applies to meeting series.
        :type current: bool
        :param email: Registrant's email to filter registrants.
        :type email: str
        :param registration_time_from: The time registrants register a meeting starts from the specified date and time
            (inclusive) in any ISO 8601 compliant format. If registrationTimeFrom is not specified, it equals
            registrationTimeTo minus 7 days.
        :type registration_time_from: str
        :param registration_time_to: The time registrants register a meeting before the specified date and time
            (exclusive) in any ISO 8601 compliant format. If registrationTimeTo is not specified, it equals
            registrationTimeFrom plus 7 days. The interval between registrationTimeFrom and registrationTimeTo must be
            within 90 days.
        :type registration_time_to: str

        documentation: https://developer.webex.com/docs/api/v1/meetings/list-meeting-registrants
        """
        if host_email is not None:
            params['hostEmail'] = host_email
        if current is not None:
            params['current'] = str(current).lower()
        if email is not None:
            params['email'] = email
        if registration_time_from is not None:
            params['registrationTimeFrom'] = registration_time_from
        if registration_time_to is not None:
            params['registrationTimeTo'] = registration_time_to
        url = self.ep(f'{meeting_id}/registrants')
        return self.session.follow_pagination(url=url, model=GetDetailedInformationForMeetingRegistrantResponse, params=params)

    def query_registrants(self, meeting_id: str, emails: List[str], current: bool = None, host_email: str = None, status: Status9 = None, order_type: OrderType = None, order_by: OrderBy = None, **params) -> Generator[GetDetailedInformationForMeetingRegistrantResponse, None, None]:
        """
        Meeting's host and cohost can query the list of registrants for a meeting with a specified meeting ID and
        registrants email.

        :param meeting_id: Unique identifier for the meeting. Only the ID of the meeting series is supported for
            meetingId. IDs of scheduled meetings, meeting instances, or scheduled personal room meetings are not
            supported. See the Meetings Overview for more information about meeting types.
        :type meeting_id: str
        :param emails: List of registrant email addresses. Possible values: bob@example.com
        :type emails: List[str]
        :param current: Whether or not to retrieve only the current scheduled meeting of the meeting series, i.e. the
            meeting ready to join or start or the upcoming meeting of the meeting series. If it's true, return details
            for the current scheduled meeting of the series, i.e. the scheduled meeting ready to join or start or the
            upcoming scheduled meeting of the meeting series. If it's false or not specified, return details for the
            entire meeting series. This parameter only applies to meeting series.
        :type current: bool
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin-level scopes. If set, the admin may specify the email of a user in a site
            they manage and the API will return details for a meeting that is hosted by that user.
        :type host_email: str
        :param status: Registrant's status.
        :type status: Status9
        :param order_type: Sort order for the registrants.
        :type order_type: OrderType
        :param order_by: Registrant ordering field. Ordered by registrationTime by default.
        :type order_by: OrderBy

        documentation: https://developer.webex.com/docs/api/v1/meetings/query-meeting-registrants
        """
        if current is not None:
            params['current'] = str(current).lower()
        if host_email is not None:
            params['hostEmail'] = host_email
        body = QueryMeetingRegistrantsBody()
        if emails is not None:
            body.emails = emails
        if status is not None:
            body.status = status
        if order_type is not None:
            body.order_type = order_type
        if order_by is not None:
            body.order_by = order_by
        url = self.ep(f'{meeting_id}/registrants/query')
        return self.session.follow_pagination(url=url, model=GetDetailedInformationForMeetingRegistrantResponse, params=params, data=body.json())

    def batch_update_registrants_status(self, meeting_id: str, status_op_type: str, current: bool = None, host_email: str = None, send_email: bool = None, registrants: List[Registrants] = None):
        """
        Meeting's host or cohost can update the set of registrants for a meeting. cancel means the registrant(s) will
        be moved back to the registration list. bulkDelete means the registrant(s) will be deleted.

        :param meeting_id: Unique identifier for the meeting. Only the ID of the meeting series is supported for
            meetingId. IDs of scheduled meetings, meeting instances, or scheduled personal room meetings are not
            supported. See the Meetings Overview for more information about meeting types.
        :type meeting_id: str
        :param status_op_type: Update registrant's status. Possible values: approve, reject, cancel, bulkDelete
        :type status_op_type: str
        :param current: Whether or not to retrieve only the current scheduled meeting of the meeting series, i.e. the
            meeting ready to join or start or the upcoming meeting of the meeting series. If it's true, return details
            for the current scheduled meeting of the series, i.e. the scheduled meeting ready to join or start or the
            upcoming scheduled meeting of the meeting series. If it's false or not specified, return details for the
            entire meeting series. This parameter only applies to meeting series. + Default: false
        :type current: bool
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin-level scopes. If set, the admin may specify the email of a user in a site
            they manage and the API will return details for a meeting that is hosted by that user.
        :type host_email: str
        :param send_email: If true send email to registrants. Default: true.
        :type send_email: bool
        :param registrants: Registrants array. Registrant ID.
        :type registrants: List[Registrants]

        documentation: https://developer.webex.com/docs/api/v1/meetings/batch-update-meeting-registrants-status
        """
        params = {}
        if current is not None:
            params['current'] = str(current).lower()
        if host_email is not None:
            params['hostEmail'] = host_email
        body = BatchUpdateMeetingRegistrantsStatusBody()
        if send_email is not None:
            body.send_email = send_email
        if registrants is not None:
            body.registrants = registrants
        url = self.ep(f'{meeting_id}/registrants/{status_op_type}')
        super().post(url=url, params=params, data=body.json())
        return

    def delete_registrant(self, meeting_id: str, registrant_id: str, current: bool = None, host_email: str = None):
        """
        Meeting's host or cohost can delete a registrant with a specified registrant ID.

        :param meeting_id: Unique identifier for the meeting. Only the ID of the meeting series is supported for
            meetingId. IDs of scheduled meetings, meeting instances, or scheduled personal room meetings are not
            supported. See the Meetings Overview for more information about meeting types.
        :type meeting_id: str
        :param registrant_id: Unique identifier for the registrant.
        :type registrant_id: str
        :param current: Whether or not to retrieve only the current scheduled meeting of the meeting series, i.e. the
            meeting ready to join or start or the upcoming meeting of the meeting series. If it's true, return details
            for the current scheduled meeting of the series, i.e. the scheduled meeting ready to join or start or the
            upcoming scheduled meeting of the meeting series. If it's false or not specified, return details for the
            entire meeting series. This parameter only applies to meeting series.
        :type current: bool
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin-level scopes. If set, the admin may specify the email of a user in a site
            they manage and the API will return details for a meeting that is hosted by that user.
        :type host_email: str

        documentation: https://developer.webex.com/docs/api/v1/meetings/delete-a-meeting-registrant
        """
        params = {}
        if current is not None:
            params['current'] = str(current).lower()
        if host_email is not None:
            params['hostEmail'] = host_email
        url = self.ep(f'{meeting_id}/registrants/{registrant_id}')
        super().delete(url=url, params=params)
        return

    def update_simultaneous_interpretation(self, meeting_id: str, enabled: bool, interpreters: InterpreterObjectForSimultaneousInterpretationOfCreateOrUpdateMeeting = None) -> SimultaneousInterpretation1:
        """
        Updates simultaneous interpretation options of a meeting with a specified meeting ID. This operation applies to
        meeting series and scheduled meetings. It doesn't apply to ended or in-progress meeting instances.

        :param meeting_id: Unique identifier for the meeting. Does not support meeting IDs for a scheduled personal
            room meeting.
        :type meeting_id: str
        :param enabled: Whether or not simultaneous interpretation is enabled.
        :type enabled: bool
        :param interpreters: Interpreters for meeting.
        :type interpreters: InterpreterObjectForSimultaneousInterpretationOfCreateOrUpdateMeeting

        documentation: https://developer.webex.com/docs/api/v1/meetings/update-meeting-simultaneous-interpretation
        """
        body = SimultaneousInterpretation()
        if enabled is not None:
            body.enabled = enabled
        if interpreters is not None:
            body.interpreters = interpreters
        url = self.ep(f'{meeting_id}/simultaneousInterpretation')
        data = super().put(url=url, data=body.json())
        return SimultaneousInterpretation1.parse_obj(data)

    def create_interpreter(self, meeting_id: str, language_code1: str, language_code2: str, email: str = None, display_name: str = None, host_email: str = None, send_email: bool = None) -> InterpreterObjectForSimultaneousInterpretationOfGetOrListMeeting:
        """
        Assign an interpreter to a bi-directional simultaneous interpretation language channel for a meeting.

        :param meeting_id: Unique identifier for the meeting to which the interpreter is to be assigned.
        :type meeting_id: str
        :param language_code1: Forms a set of simultaneous interpretation channels together with languageCode2.
            Standard language format from ISO 639-1 code. Read ISO 639-1 for details.
        :type language_code1: str
        :param language_code2: Forms a set of simultaneous interpretation channels together with languageCode1.
            Standard language format from ISO 639-1 code. Read ISO 639-1 for details.
        :type language_code2: str
        :param email: Email address for cohost. This attribute can be modified with the Update Personal Meeting Room
            Options API. Possible values: john.andersen@example.com
        :type email: str
        :param display_name: Display name for cohost. This attribute can be modified with the Update Personal Meeting
            Room Options API. Possible values: John Andersen
        :type display_name: str
        :param host_email: Email address for the meeting host. This attribute should only be set if the user or
            application calling the API has the admin on-behalf-of scopes. When used, the admin may specify the email
            of a user in a site they manage to be the meeting host.
        :type host_email: str
        :param send_email: If true, send email to the interpreter.
        :type send_email: bool

        documentation: https://developer.webex.com/docs/api/v1/meetings/create-a-meeting-interpreter
        """
        body = CreateMeetingInterpreterBody()
        if language_code1 is not None:
            body.language_code1 = language_code1
        if language_code2 is not None:
            body.language_code2 = language_code2
        if email is not None:
            body.email = email
        if display_name is not None:
            body.display_name = display_name
        if host_email is not None:
            body.host_email = host_email
        if send_email is not None:
            body.send_email = send_email
        url = self.ep(f'{meeting_id}/interpreters')
        data = super().post(url=url, data=body.json())
        return InterpreterObjectForSimultaneousInterpretationOfGetOrListMeeting.parse_obj(data)

    def interpreter(self, meeting_id: str, interpreter_id: str, host_email: str = None) -> InterpreterObjectForSimultaneousInterpretationOfGetOrListMeeting:
        """
        Retrieves details for a meeting interpreter identified by meetingId and interpreterId in the URI.

        :param meeting_id: Unique identifier for the meeting to which the interpreter has been assigned.
        :type meeting_id: str
        :param interpreter_id: Unique identifier for the interpreter whose details are being requested.
        :type interpreter_id: str
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin on-behalf-of scopes. If set, the admin may specify the email of a user in a
            site they manage and the API will return details for an interpreter of the meeting that is hosted by that
            user.
        :type host_email: str

        documentation: https://developer.webex.com/docs/api/v1/meetings/get-a-meeting-interpreter
        """
        params = {}
        if host_email is not None:
            params['hostEmail'] = host_email
        url = self.ep(f'{meeting_id}/interpreters/{interpreter_id}')
        data = super().get(url=url, params=params)
        return InterpreterObjectForSimultaneousInterpretationOfGetOrListMeeting.parse_obj(data)

    def list_interpreters(self, meeting_id: str, host_email: str = None) -> list[InterpreterObjectForSimultaneousInterpretationOfGetOrListMeeting]:
        """
        Lists meeting interpreters for a meeting with a specified meetingId.
        This operation can be used for meeting series, scheduled meeting and ended or ongoing meeting instance objects.
        If the specified meetingId is for a meeting series, the interpreters for the series will be listed; if the
        meetingId is for a scheduled meeting, the interpreters for the particular scheduled meeting will be listed; if
        the meetingId is for an ended or ongoing meeting instance, the interpreters for the particular meeting instance
        will be listed. See the Webex Meetings guide for more information about the types of meetings.
        The list returned is sorted in descending order by when interpreters were created.

        :param meeting_id: Unique identifier for the meeting for which interpreters are being requested. The meeting
            can be meeting series, scheduled meeting or meeting instance which has ended or is ongoing. Please note
            that currently meeting ID of a scheduled personal room meeting is not supported for this API.
        :type meeting_id: str
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin on-behalf-of scopes. If set, the admin may specify the email of a user in a
            site they manage and the API will return interpreters of the meeting that is hosted by that user.
        :type host_email: str

        documentation: https://developer.webex.com/docs/api/v1/meetings/list-meeting-interpreters
        """
        params = {}
        if host_email is not None:
            params['hostEmail'] = host_email
        url = self.ep(f'{meeting_id}/interpreters')
        data = super().get(url=url, params=params)
        return parse_obj_as(list[InterpreterObjectForSimultaneousInterpretationOfGetOrListMeeting], data["items"])

    def update_interpreter(self, meeting_id: str, interpreter_id: str, language_code1: str, language_code2: str, email: str = None, display_name: str = None, host_email: str = None, send_email: bool = None) -> InterpreterObjectForSimultaneousInterpretationOfGetOrListMeeting:
        """
        Updates details for a meeting interpreter identified by meetingId and interpreterId in the URI.

        :param meeting_id: Unique identifier for the meeting whose interpreters were belong to.
        :type meeting_id: str
        :param interpreter_id: Unique identifier for the interpreter whose details are being requested.
        :type interpreter_id: str
        :param language_code1: Forms a set of simultaneous interpretation channels together with languageCode2.
            Standard language format from ISO 639-1 code. Read ISO 639-1 for details.
        :type language_code1: str
        :param language_code2: Forms a set of simultaneous interpretation channels together with languageCode1.
            Standard language format from ISO 639-1 code. Read ISO 639-1 for details.
        :type language_code2: str
        :param email: Email address for cohost. This attribute can be modified with the Update Personal Meeting Room
            Options API. Possible values: john.andersen@example.com
        :type email: str
        :param display_name: Display name for cohost. This attribute can be modified with the Update Personal Meeting
            Room Options API. Possible values: John Andersen
        :type display_name: str
        :param host_email: Email address for the meeting host. This attribute should only be set if the user or
            application calling the API has the admin on-behalf-of scopes. When used, the admin may specify the email
            of a user in a site they manage to be the meeting host.
        :type host_email: str
        :param send_email: If true, send email to the interpreter.
        :type send_email: bool

        documentation: https://developer.webex.com/docs/api/v1/meetings/update-a-meeting-interpreter
        """
        body = CreateMeetingInterpreterBody()
        if language_code1 is not None:
            body.language_code1 = language_code1
        if language_code2 is not None:
            body.language_code2 = language_code2
        if email is not None:
            body.email = email
        if display_name is not None:
            body.display_name = display_name
        if host_email is not None:
            body.host_email = host_email
        if send_email is not None:
            body.send_email = send_email
        url = self.ep(f'{meeting_id}/interpreters/{interpreter_id}')
        data = super().put(url=url, data=body.json())
        return InterpreterObjectForSimultaneousInterpretationOfGetOrListMeeting.parse_obj(data)

    def delete_interpreter(self, meeting_id: str, interpreter_id: str, host_email: str = None, send_email: bool = None):
        """
        Removes a meeting interpreter identified by meetingId and interpreterId in the URI. The deleted meeting
        interpreter cannot be recovered.

        :param meeting_id: Unique identifier for the meeting whose interpreters were belong to.
        :type meeting_id: str
        :param interpreter_id: Unique identifier for the interpreter to be removed.
        :type interpreter_id: str
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin on-behalf-of scopes. If set, the admin may specify the email of a user in a
            site they manage and the API will delete an interpreter of the meeting that is hosted by that user.
        :type host_email: str
        :param send_email: If true, send email to the interpreter.
        :type send_email: bool

        documentation: https://developer.webex.com/docs/api/v1/meetings/delete-a-meeting-interpreter
        """
        params = {}
        if host_email is not None:
            params['hostEmail'] = host_email
        if send_email is not None:
            params['sendEmail'] = str(send_email).lower()
        url = self.ep(f'{meeting_id}/interpreters/{interpreter_id}')
        super().delete(url=url, params=params)
        return

    def update_breakout_sessions(self, meeting_id: str, host_email: str = None, send_email: bool = None, items: BreakoutSessionObject = None) -> list[GetBreakoutSessionObject]:
        """
        Updates breakout sessions of a meeting with a specified meeting ID in the pre-meeting state. This operation
        applies to meeting series and scheduled meetings.

        :param meeting_id: Unique identifier for the meeting. Does not support meeting IDs for a scheduled personal
            room meeting.
        :type meeting_id: str
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin-level scopes. If set, the admin may specify the email of a user in a site
            they manage and the API will return details for a meeting that is hosted by that user.
        :type host_email: str
        :param send_email: Whether or not to send emails to host and invitees. It is an optional field and default
            value is true.
        :type send_email: bool
        :param items: Breakout sessions are smaller groups that are split off from the main meeting or webinar. They
            allow a subset of participants to collaborate and share ideas over audio and video. Use breakout sessions
            for workshops, classrooms, or for when you need a moment to talk privately with a few participants outside
            of the main session. Please note that maximum number of breakout sessions in a meeting or webinar is 100.
            In webinars, if hosts preassign attendees to breakout sessions, the role of attendee will be changed to
            panelist. Breakout session is not supported for a meeting with simultaneous interpretation.
        :type items: BreakoutSessionObject

        documentation: https://developer.webex.com/docs/api/v1/meetings/update-meeting-breakout-sessions
        """
        body = UpdateMeetingBreakoutSessionsBody()
        if host_email is not None:
            body.host_email = host_email
        if send_email is not None:
            body.send_email = send_email
        if items is not None:
            body.items = items
        url = self.ep(f'{meeting_id}/breakoutSessions')
        data = super().put(url=url, data=body.json())
        return parse_obj_as(list[GetBreakoutSessionObject], data["items"])

    def list_breakout_sessions(self, meeting_id: str) -> list[GetBreakoutSessionObject]:
        """
        Lists meeting breakout sessions for a meeting with a specified meetingId.
        This operation can be used for meeting series, scheduled meeting and ended or ongoing meeting instance objects.
        See the Webex Meetings guide for more information about the types of meetings.

        :param meeting_id: Unique identifier for the meeting. This parameter applies to meeting series, scheduled
            meeting and ended or ongoing meeting instance objects. Please note that currently meeting ID of a scheduled
            personal room meeting is not supported for this API.
        :type meeting_id: str

        documentation: https://developer.webex.com/docs/api/v1/meetings/list-meeting-breakout-sessions
        """
        url = self.ep(f'{meeting_id}/breakoutSessions')
        data = super().get(url=url)
        return parse_obj_as(list[GetBreakoutSessionObject], data["items"])

    def delete_breakout_sessions(self, meeting_id: str, send_email: bool = None):
        """
        Deletes breakout sessions with a specified meeting ID. The deleted breakout sessions cannot be recovered. The
        value of enabledBreakoutSessions attribute is set to false automatically.
        This operation applies to meeting series and scheduled meetings. It doesn't apply to ended or in-progress
        meeting instances.

        :param meeting_id: Unique identifier for the meeting. This parameter applies to meeting series and scheduled
            meetings. It doesn't apply to ended or in-progress meeting instances.
        :type meeting_id: str
        :param send_email: Whether or not to send emails to host and invitees. It is an optional field and default
            value is true.
        :type send_email: bool

        documentation: https://developer.webex.com/docs/api/v1/meetings/delete-meeting-breakout-sessions
        """
        params = {}
        if send_email is not None:
            params['sendEmail'] = str(send_email).lower()
        url = self.ep(f'{meeting_id}/breakoutSessions')
        super().delete(url=url, params=params)
        return

    def survey(self, meeting_id: str) -> GetMeetingSurveyResponse:
        """
        Retrieves details for a meeting survey identified by meetingId.

        :param meeting_id: Unique identifier for the meeting. Please note that only the meeting ID of a scheduled
            webinar is supported for this API.
        :type meeting_id: str

        documentation: https://developer.webex.com/docs/api/v1/meetings/get-a-meeting-survey
        """
        url = self.ep(f'{meeting_id}/survey')
        data = super().get(url=url)
        return GetMeetingSurveyResponse.parse_obj(data)

    def list_survey_results(self, meeting_id: str, meeting_start_time_from: str = None, meeting_start_time_to: str = None, **params) -> Generator[SurveyResultObject, None, None]:
        """
        Retrieves results for a meeting survey identified by meetingId.

        :param meeting_id: Unique identifier for the meeting. Please note that only the meeting ID of a scheduled
            webinar is supported for this API.
        :type meeting_id: str
        :param meeting_start_time_from: Start date and time (inclusive) in any ISO 8601 compliant format for the
            meeting objects being requested. meetingStartTimeFrom cannot be after meetingStartTimeTo. This parameter
            will be ignored if meetingId is the unique identifier for the specific meeting instance. When meetingId is
            not the unique identifier for the specific meeting instance, the meetingStartTimeFrom, if not specified,
            equals meetingStartTimeTo minus 1 month; if meetingStartTimeTo is also not specified, the default value for
            meetingStartTimeFrom is 1 month before the current date and time.
        :type meeting_start_time_from: str
        :param meeting_start_time_to: End date and time (exclusive) in any ISO 8601 compliant format for the meeting
            objects being requested. meetingStartTimeTo cannot be prior to meetingStartTimeFrom. This parameter will be
            ignored if meetingId is the unique identifier for the specific meeting instance. When meetingId is not the
            unique identifier for the specific meeting instance, if meetingStartTimeFrom is also not specified, the
            default value for meetingStartTimeTo is the current date and time;For example,if meetingStartTimeFrom is a
            month ago, the default value for meetingStartTimeTo is 1 month after meetingStartTimeFrom.Otherwise it is
            the current date and time.
        :type meeting_start_time_to: str

        documentation: https://developer.webex.com/docs/api/v1/meetings/list-meeting-survey-results
        """
        if meeting_start_time_from is not None:
            params['meetingStartTimeFrom'] = meeting_start_time_from
        if meeting_start_time_to is not None:
            params['meetingStartTimeTo'] = meeting_start_time_to
        url = self.ep(f'{meeting_id}/surveyResults')
        return self.session.follow_pagination(url=url, model=SurveyResultObject, params=params)

    def create_invitation_sources(self, meeting_id: str, host_email: str = None, person_id: str = None, items: InvitationSourceCreateObject = None) -> list[InvitationSourceObject]:
        """
        Creates one or more invitation sources for a meeting.

        :param meeting_id: Unique identifier for the meeting. Only the meeting ID of a scheduled webinar is supported
            for this API.
        :type meeting_id: str
        :param host_email: Email address for the meeting host. This parameter is only used if a user or application
            calling the API has the admin-level scopes. The admin may specify the email of a user on a site they manage
            and the API will return meeting participants of the meetings that are hosted by that user.
        :type host_email: str
        :param person_id: Unique identifier for the meeting host. Should only be set if the user or application calling
            the API has the admin-level scopes. When used, the admin may specify the email of a user in a site they
            manage to be the meeting host.
        :type person_id: str
        :param items: 
        :type items: InvitationSourceCreateObject

        documentation: https://developer.webex.com/docs/api/v1/meetings/create-invitation-sources
        """
        body = CreateInvitationSourcesBody()
        if host_email is not None:
            body.host_email = host_email
        if person_id is not None:
            body.person_id = person_id
        if items is not None:
            body.items = items
        url = self.ep(f'{meeting_id}/invitationSources')
        data = super().post(url=url, data=body.json())
        return parse_obj_as(list[InvitationSourceObject], data["items"])

    def list_invitation_sources(self, meeting_id: str) -> list[InvitationSourceObject]:
        """
        Lists invitation sources for a meeting.

        :param meeting_id: Unique identifier for the meeting. Only the meeting ID of a scheduled webinar is supported
            for this API.
        :type meeting_id: str

        documentation: https://developer.webex.com/docs/api/v1/meetings/list-invitation-sources
        """
        url = self.ep(f'{meeting_id}/invitationSources')
        data = super().get(url=url)
        return parse_obj_as(list[InvitationSourceObject], data["items"])

    def list_tracking_codes(self, service: str, site_url: str = None, host_email: str = None) -> ListMeetingTrackingCodesResponse:
        """
        Lists tracking codes on a site by a meeting host. The result indicates which tracking codes and what options
        can be used to create or update a meeting on the specified site.

        :param service: Service for schedule or sign-up pages.
        :type service: str
        :param site_url: URL of the Webex site which the API retrieves the tracking code from. If not specified, the
            API retrieves the tracking code from the user's preferred site. All available Webex sites and preferred
            sites of a user can be retrieved by Get Site List API.
        :type site_url: str
        :param host_email: Email address for the meeting host. This parameter is only used if a user or application
            calling the API has the admin-level scopes. The admin may specify the email of a user on a site they manage
            and the API will return meeting participants of the meetings that are hosted by that user.
        :type host_email: str

        documentation: https://developer.webex.com/docs/api/v1/meetings/list-meeting-tracking-codes
        """
        params = {}
        params['service'] = service
        if site_url is not None:
            params['siteUrl'] = site_url
        if host_email is not None:
            params['hostEmail'] = host_email
        url = self.ep('trackingCodes')
        data = super().get(url=url, params=params)
        return ListMeetingTrackingCodesResponse.parse_obj(data)

    def reassign_to_new_host(self, host_email: str, meeting_ids: List[str]) -> list[ReassignMeetingResponseObject]:
        """
        Reassigns a list of meetings to a new host by an admin user.
        All the meetings of meetingIds should belong to the same site, which is the siteUrl in the request header, if
        specified, or the admin user's preferred site, if not specified. All available Webex sites and the preferred
        sites of a user can be retrieved by Get Site List API.
        If the user of hostEmail is not qualified to be a host of the target site, the API returns an error with the
        HTTP status code 403. If all the meetings referenced by meetingIds have been reassigned the new host
        successfully, the API returns an empty response with the HTTP status code 204. Otherwise, if all the meetings
        of meetingIds fail or some of them fail, the API returns a "Multi-Status" response with status code of 207, and
        individual errors for each meeting in the response body.
        Only IDs of meeting series are supported for the meetingIds. IDs of scheduled meetings, meeting instances, or
        scheduled personal room meetings are not supported. See the Meetings Overview for more information about the
        types of meetings.
        There are several limitations when reassigning meetings:

        :param host_email: Email address of the new meeting host.
        :type host_email: str
        :param meeting_ids: List of meeting series IDs to be reassigned the new host. The size is between 1 and 100.
            All the meetings of meetingIds should belong to the same site, which is the siteUrl in the request header,
            if specified, or the admin user's preferred site, if not specified. All available Webex sites and the
            preferred sites of a user can be retrieved by Get Site List API.
        :type meeting_ids: List[str]

        documentation: https://developer.webex.com/docs/api/v1/meetings/reassign-meetings-to-a-new-host
        """
        body = ReassignMeetingsToNewHostBody()
        if host_email is not None:
            body.host_email = host_email
        if meeting_ids is not None:
            body.meeting_ids = meeting_ids
        url = self.ep('reassignHost')
        data = super().post(url=url, data=body.json())
        return parse_obj_as(list[ReassignMeetingResponseObject], data["items"])

class DurationMetric(ApiModel):
    #: Timestamp indicating the start of the aggregation bucket (ISO 8601).
    start: Optional[str]
    #: Timestamp indicating the end of the aggregation bucket (ISO 8601).
    end: Optional[str]
    #: The time duration (in a given state) in the bucket.
    duration: Optional[int]


class MeetingUsageReportObject(DurationMetric):
    #: Unique identifier for the meeting.
    meeting_id: Optional[str]
    #: Meeting number.
    meeting_number: Optional[str]
    #: Meeting title.
    meeting_title: Optional[str]
    #: Scheduled type for the meeting.
    scheduled_type: Optional[TemplateType]
    #: Display name for the meeting host.
    host_display_name: Optional[str]
    #: Email address for the meeting host.
    host_email: Optional[str]
    #: Aggregated attendee minutes.
    total_people_minutes: Optional[int]
    #: Aggregated attendee PSTN call-in minutes.
    total_call_in_minutes: Optional[int]
    #: Aggregated attendee domestic PSTN call-out minutes.
    total_call_out_domestic: Optional[int]
    #: Aggregated attendee toll-free PSTN call-in minutes.
    total_call_in_toll_free_minutes: Optional[int]
    #: Aggregated attendee international PSTN call-out minutes.
    total_call_out_international: Optional[int]
    #: Aggregated attendee VoIP minutes.
    total_voip_minutes: Optional[int]
    #: Total number of participants of the meeting.
    total_participants: Optional[int]
    #: Total number of VoIP participants of the meeting.
    total_participants_voip: Optional[int]
    #: Total number of PSTN call-in participants of the meeting.
    total_participants_call_in: Optional[int]
    #: Total number of PSTN call-out participants of the meeting.
    total_participants_call_out: Optional[int]
    #: Peak number of attendees throughout the meeting.
    peak_attendee: Optional[int]
    #: Total number of registrants of the meeting.
    total_registered: Optional[int]
    #: Total number of invitees of the meeting.
    total_invitee: Optional[int]
    #: Tracking codes of the meeting.
    tracking_codes: Optional[list[TrackingCodeItemForCreateMeetingObject]]


class ParticipantsByRoles(ApiModel):
    host: Optional[int]
    attendee: Optional[int]


class MeetingAttendeeReportObject(CoHosts):
    #: Unique identifier for the meeting.
    meeting_id: Optional[str]
    #: Meeting number.
    meeting_number: Optional[int]
    #: Meeting title.
    meeting_title: Optional[str]
    #: The date and time when the attendee joined the meeting. It's in the timezone specified in the request header or
    #: in the UTC timezone if timezone is not specified.
    joined_time: Optional[str]
    #: The date and time when the attendee left the meeting. It's in the timezone specified in the request header or in
    #: the UTC timezone if timezone is not specified.
    left_time: Optional[str]
    #: Duration of the attendee in the meeting in minutes.
    duration: Optional[int]
    #: The attendee's role in the meeting.
    participant_type: Optional[ParticipantsByRoles]
    #: IP address of the attendee when he attended the meeting.
    ip_address: Optional[str]
    #: Information of the attendee's operating system and application when he attended the meeting.
    client_agent: Optional[str]
    #: Attendee's company.
    company: Optional[str]
    #: Attendee's phone number.
    phone_number: Optional[str]
    #: Attendee's address, part one.
    address1: Optional[str]
    #: Attendee's address, part two.
    address2: Optional[str]
    #: Attendee's city.
    city: Optional[str]
    #: Attendee's state.
    state: Optional[str]
    #: Attendee's country.
    country: Optional[str]
    #: Attendee's zip code.
    zip_code: Optional[str]
    #: Whether or not the attendee has registered the meeting.
    registered: Optional[bool]
    #: Whether or not the attendee has been invited to the meeting.
    invited: Optional[bool]


class ListMeetingUsageReportsResponse(ApiModel):
    #: An array of meeting usage report objects.
    items: Optional[list[MeetingUsageReportObject]]


class ListMeetingAttendeeReportsResponse(ApiModel):
    #: An array of meeting attendee report objects.
    items: Optional[list[MeetingAttendeeReportObject]]


class MeetingsSummaryReportApi(ApiChild, base='meetingReports/'):
    """
    The meeting usage report API is used to retrieve aggregated meeting usage information, like totalCallInMinutes,
    totalParticipants, etc. It also includes the meeting trackingCodes.
    The meeting attendee report API is used to retrieve aggregated meeting attendee information, like joinedTime,
    leftTime, duration, etc.
    The report data for a meeting should be available within 24 hours after the meeting ended.
    Refer to the Meetings API Scopes section of Meetings Overview for scopes required for each API.
    """

    def list_meeting_usage_reports(self, site_url: str, from_: str = None, to_: str = None, **params) -> Generator[MeetingUsageReportObject, None, None]:
        """
        List meeting usage reports of all the users on the specified site by an admin. You can specify a date range and
        the maximum number of meeting usage reports to return.
        The list returned is sorted in descending order by the date and time the meetings were started.
        Long result sets are split into pages.

        :param site_url: URL of the Webex site which the API lists meeting usage reports from. All available Webex
            sites can be retrieved by the Get Site List API.
        :type site_url: str
        :param from_: Starting date and time for meeting usage reports to return, in any ISO 8601 compliant format.
            from cannot be after to. The interval between to and from cannot exceed 30 days and from cannot be earlier
            than 90 days ago.
        :type from_: str
        :param to_: Ending date and time for meeting usage reports to return, in any ISO 8601 compliant format. to
            cannot be before from. The interval between to and from cannot exceed 30 days.
        :type to_: str

        documentation: https://developer.webex.com/docs/api/v1/meetings-summary-report/list-meeting-usage-reports
        """
        params['siteUrl'] = site_url
        if from_ is not None:
            params['from'] = from_
        if to_ is not None:
            params['to'] = to_
        url = self.ep('usage')
        return self.session.follow_pagination(url=url, model=MeetingUsageReportObject, params=params)

    def list_meeting_attendee_reports(self, site_url: str, meeting_id: str = None, meeting_number: str = None, meeting_title: str = None, from_: str = None, to_: str = None, **params) -> Generator[MeetingAttendeeReportObject, None, None]:
        """
        Lists of meeting attendee reports by a date range, the maximum number of meeting attendee reports, a meeting
        ID, a meeting number or a meeting title.
        If the requesting user is an admin, the API returns meeting attendee reports of the meetings hosted by all the
        users on the specified site filtered by meeting ID, meeting number or meeting title.
        If it's a normal meeting host, the API returns meeting attendee reports of the meetings hosted by the user
        himself on the specified site filtered by meeting ID, meeting number or meeting title.
        The list returned is grouped by meeting instances. Both the groups and items of each group are sorted in
        descending order of joinedTime. For example, if meetingId is specified and it's a meeting series ID, the
        returned list is grouped by meeting instances of that series. The groups are sorted in descending order of
        joinedTime, and within each group the items are also sorted in descending order of joinedTime. Please refer to
        Meetings Overview for details of meeting series, scheduled meeting and meeting instance.
        Long result sets are split into pages.

        :param site_url: URL of the Webex site which the API lists meeting attendee reports from. All available Webex
            sites can be retrieved by the Get Site List API.
        :type site_url: str
        :param meeting_id: Meeting ID for the meeting attendee reports to return. If specified, return meeting attendee
            reports of the specified meeting; otherwise, return meeting attendee reports of all meetings. Currently,
            only ended meeting instance IDs are supported. IDs of meeting series, scheduled meetings or personal room
            meetings are not supported.
        :type meeting_id: str
        :param meeting_number: Meeting number for the meeting attendee reports to return. If specified, return meeting
            attendee reports of the specified meeting; otherwise, return meeting attendee reports of all meetings.
        :type meeting_number: str
        :param meeting_title: Meeting title for the meeting attendee reports to return. If specified, return meeting
            attendee reports of the specified meeting; otherwise, return meeting attendee reports of all meetings.
        :type meeting_title: str
        :param from_: Starting date and time for the meeting attendee reports to return, in any ISO 8601 compliant
            format. from cannot be after to. The interval between to and from cannot exceed 30 days and from cannot be
            earlier than 90 days ago.
        :type from_: str
        :param to_: Ending date and time for the meeting attendee reports to return, in any ISO 8601 compliant format.
            to cannot be before from. The interval between to and from cannot exceed 30 days.
        :type to_: str

        documentation: https://developer.webex.com/docs/api/v1/meetings-summary-report/list-meeting-attendee-reports
        """
        params['siteUrl'] = site_url
        if meeting_id is not None:
            params['meetingId'] = meeting_id
        if meeting_number is not None:
            params['meetingNumber'] = meeting_number
        if meeting_title is not None:
            params['meetingTitle'] = meeting_title
        if from_ is not None:
            params['from'] = from_
        if to_ is not None:
            params['to'] = to_
        url = self.ep('attendees')
        return self.session.follow_pagination(url=url, model=MeetingAttendeeReportObject, params=params)

class RoomType(str, Enum):
    #: 1:1 room.
    direct = 'direct'
    #: Group room.
    group = 'group'


class CreateMembershipBody(ApiModel):
    #: The room ID.
    room_id: Optional[str]
    #: The person ID.
    person_id: Optional[str]
    #: The email address of the person.
    person_email: Optional[str]
    #: Whether or not the participant is a room moderator.
    is_moderator: Optional[bool]


class Membership(CreateMembershipBody):
    #: A unique identifier for the membership.
    id: Optional[str]
    #: The display name of the person.
    person_display_name: Optional[str]
    #: The organization ID of the person.
    person_org_id: Optional[str]
    #: Whether or not the direct type room is hidden in the Webex clients.
    is_room_hidden: Optional[bool]
    #: The type of room the membership is associated with.
    room_type: Optional[RoomType]
    #: Whether or not the participant is a monitoring bot (deprecated).
    is_monitor: Optional[bool]
    #: The date and time when the membership was created.
    created: Optional[str]


class ListMembershipsResponse(ApiModel):
    items: Optional[list[Membership]]


class UpdateMembershipBody(ApiModel):
    #: Whether or not the participant is a room moderator.
    is_moderator: Optional[bool]
    #: When set to true, hides direct spaces in the teams client. Any new message will make the room visible again.
    is_room_hidden: Optional[bool]


class MembershipsApi(ApiChild, base='memberships'):
    """
    Memberships represent a person's relationship to a room. Use this API to list members of any room that you're in or
    create memberships to invite someone to a room. Compliance Officers can now also list memberships for personEmails
    where the CO is not part of the room.
    Memberships can also be updated to make someone a moderator, or deleted, to remove someone from the room.
    Just like in the Webex client, you must be a member of the room in order to list its memberships or invite people.
    """

    def list(self, room_id: str = None, person_id: str = None, person_email: str = None, **params) -> Generator[Membership, None, None]:
        """
        Lists all room memberships. By default, lists memberships for rooms to which the authenticated user belongs.
        Use query parameters to filter the response.
        Use roomId to list memberships for a room, by ID.
        NOTE: For moderated team spaces, the list of memberships will include only the space moderators if the user is
        a team member but not a direct participant of the space.
        Use either personId or personEmail to filter the results. The roomId parameter is required when using these
        parameters.
        Long result sets will be split into pages.

        :param room_id: List memberships associated with a room, by ID.
        :type room_id: str
        :param person_id: List memberships associated with a person, by ID. The roomId parameter is required when using
            this parameter.
        :type person_id: str
        :param person_email: List memberships associated with a person, by email address. The roomId parameter is
            required when using this parameter.
        :type person_email: str

        documentation: https://developer.webex.com/docs/api/v1/memberships/list-memberships
        """
        if room_id is not None:
            params['roomId'] = room_id
        if person_id is not None:
            params['personId'] = person_id
        if person_email is not None:
            params['personEmail'] = person_email
        url = self.ep()
        return self.session.follow_pagination(url=url, model=Membership, params=params)

    def create(self, room_id: str, person_id: str = None, person_email: str = None, is_moderator: bool = None) -> Membership:
        """
        Add someone to a room by Person ID or email address, optionally making them a moderator. Compliance Officers
        cannot add people to empty (team) spaces.

        :param room_id: The room ID.
        :type room_id: str
        :param person_id: The person ID.
        :type person_id: str
        :param person_email: The email address of the person.
        :type person_email: str
        :param is_moderator: Whether or not the participant is a room moderator.
        :type is_moderator: bool

        documentation: https://developer.webex.com/docs/api/v1/memberships/create-a-membership
        """
        body = CreateMembershipBody()
        if room_id is not None:
            body.room_id = room_id
        if person_id is not None:
            body.person_id = person_id
        if person_email is not None:
            body.person_email = person_email
        if is_moderator is not None:
            body.is_moderator = is_moderator
        url = self.ep()
        data = super().post(url=url, data=body.json())
        return Membership.parse_obj(data)

    def details(self, membership_id: str) -> Membership:
        """
        Get details for a membership by ID.
        Specify the membership ID in the membershipId URI parameter.

        :param membership_id: The unique identifier for the membership.
        :type membership_id: str

        documentation: https://developer.webex.com/docs/api/v1/memberships/get-membership-details
        """
        url = self.ep(f'{membership_id}')
        data = super().get(url=url)
        return Membership.parse_obj(data)

    def update(self, membership_id: str, is_moderator: bool, is_room_hidden: bool) -> Membership:
        """
        Updates properties for a membership by ID.
        Specify the membership ID in the membershipId URI parameter.

        :param membership_id: The unique identifier for the membership.
        :type membership_id: str
        :param is_moderator: Whether or not the participant is a room moderator.
        :type is_moderator: bool
        :param is_room_hidden: When set to true, hides direct spaces in the teams client. Any new message will make the
            room visible again.
        :type is_room_hidden: bool

        documentation: https://developer.webex.com/docs/api/v1/memberships/update-a-membership
        """
        body = UpdateMembershipBody()
        if is_moderator is not None:
            body.is_moderator = is_moderator
        if is_room_hidden is not None:
            body.is_room_hidden = is_room_hidden
        url = self.ep(f'{membership_id}')
        data = super().put(url=url, data=body.json())
        return Membership.parse_obj(data)

    def delete(self, membership_id: str):
        """
        Deletes a membership by ID.
        Specify the membership ID in the membershipId URI parameter.
        The membership for the last moderator of a Team's General space may not be deleted; promote another user to
        team moderator first.

        :param membership_id: The unique identifier for the membership.
        :type membership_id: str

        documentation: https://developer.webex.com/docs/api/v1/memberships/delete-a-membership
        """
        url = self.ep(f'{membership_id}')
        super().delete(url=url)
        return

class Body(ApiModel):
    #: Possible values: TextBlock
    type: Optional[str]
    #: Possible values: Adaptive Cards
    text: Optional[str]
    #: Possible values: large
    size: Optional[str]


class Actions(ApiModel):
    #: Possible values: Action.OpenUrl
    type: Optional[str]
    #: Possible values: http://adaptivecards.io
    url: Optional[str]
    #: Possible values: Learn More
    title: Optional[str]


class AdaptiveCard(ApiModel):
    #: Must be AdaptiveCard.
    type: Optional[str]
    #: Adaptive Card schema version.
    version: Optional[str]
    #: The card's elements.
    body: Optional[list[Body]]
    #: The card's actions.
    actions: Optional[list[Actions]]


class Attachment(ApiModel):
    #: The content type of the attachment.
    content_type: Optional[str]
    #: Adaptive Card content.
    content: Optional[AdaptiveCard]


class EditMessageBody(ApiModel):
    #: The room ID of the message.
    room_id: Optional[str]
    #: The message, in plain text. If markdown is specified this parameter may be optionally used to provide alternate
    #: text for UI clients that do not support rich text. The maximum message length is 7439 bytes.
    text: Optional[str]
    #: The message, in Markdown format. If this attribute is set ensure that the request does NOT contain an html
    #: attribute.
    markdown: Optional[str]


class ListMessage(EditMessageBody):
    #: The unique identifier for the message.
    id: Optional[str]
    #: The unique identifier for the parent message.
    parent_id: Optional[str]
    #: The type of room.
    room_type: Optional[RoomType]
    #: The text content of the message, in HTML format. This read-only property is used by the Webex clients.
    html: Optional[str]
    #: Public URLs for files attached to the message. For the supported media types and the behavior of file uploads,
    #: see Message Attachments.
    files: Optional[list[str]]
    #: The person ID of the message author.
    person_id: Optional[str]
    #: The email address of the message author.
    person_email: Optional[str]
    #: People IDs for anyone mentioned in the message.
    mentioned_people: Optional[list[str]]
    #: Group names for the groups mentioned in the message.
    mentioned_groups: Optional[list[str]]
    #: Message content attachments attached to the message. See the Cards Guide for more information.
    attachments: Optional[list[Attachment]]
    #: The date and time the message was created.
    created: Optional[str]
    #: The date and time that the message was last edited by the author. This field is only present when the message
    #: contents have changed.
    updated: Optional[str]
    #: true if the audio file is a voice clip recorded by the client; false if the audio file is a standard audio file
    #: not posted using the voice clip feature.
    is_voice_clip: Optional[bool]


class DirectMessage(EditMessageBody):
    #: The unique identifier for the message.
    id: Optional[str]
    #: The unique identifier for the parent message.
    parent_id: Optional[str]
    #: The type of room. Will always be direct.
    room_type: Optional[str]
    #: The text content of the message, in HTML format. This read-only property is used by the Webex clients.
    html: Optional[str]
    #: Public URLs for files attached to the message. For the supported media types and the behavior of file uploads,
    #: see Message Attachments.
    files: Optional[list[str]]
    #: The person ID of the message author.
    person_id: Optional[str]
    #: The email address of the message author.
    person_email: Optional[str]
    #: Message content attachments attached to the message. See the Cards Guide for more information.
    attachments: Optional[list[Attachment]]
    #: The date and time the message was created.
    created: Optional[str]
    #: The date and time that the message was last edited by the author. This field is only present when the message
    #: contents have changed.
    updated: Optional[str]
    #: True if the audio file is a voice clip recorded by the client; false if the audio file is a standard audio file
    #: not posted using the voice clip feature.
    is_voice_clip: Optional[bool]


class ListMessagesResponse(ApiModel):
    items: Optional[list[ListMessage]]


class ListDirectMessagesResponse(ApiModel):
    items: Optional[list[DirectMessage]]


class CreateMessageBody(EditMessageBody):
    #: The parent message to reply to.
    parent_id: Optional[str]
    #: The person ID of the recipient when sending a private 1:1 message.
    to_person_id: Optional[str]
    #: The email address of the recipient when sending a private 1:1 message.
    to_person_email: Optional[str]
    #: The public URL to a binary file to be posted into the room. Only one file is allowed per message. Uploaded files
    #: are automatically converted into a format that all Webex clients can render. For the supported media types and
    #: the behavior of uploads, see the Message Attachments Guide.
    #: Possible values: http://www.example.com/images/media.png
    files: Optional[list[str]]
    #: Content attachments to attach to the message. Only one card per message is supported. See the Cards Guide for
    #: more information.
    attachments: Optional[list[Attachment]]


class CreateMessageResponse(ListMessage):
    #: The person ID of the recipient when sending a private 1:1 message.
    to_person_id: Optional[str]
    #: The email address of the recipient when sending a private 1:1 message.
    to_person_email: Optional[str]


class MessagesApi(ApiChild, base='messages'):
    """
    Messages are how you communicate in a room. In Webex, each message is displayed on its own line along with a
    timestamp and sender information. Use this API to list, create, update, and delete messages.
    Message can contain plain text, rich text, and a file attachment.
    Just like in the Webex app, you must be a member of the room in order to target it with this API.
    """

    def list(self, room_id: str, parent_id: str = None, mentioned_people: List[str] = None, before: str = None, before_message: str = None, **params) -> Generator[ListMessage, None, None]:
        """
        Lists all messages in a room. Each message will include content attachments if present.
        The list sorts the messages in descending order by creation date.
        Long result sets will be split into pages.

        :param room_id: List messages in a room, by ID.
        :type room_id: str
        :param parent_id: List messages with a parent, by ID.
        :type parent_id: str
        :param mentioned_people: List messages with these people mentioned, by ID. Use me as a shorthand for the
            current API user. Only me or the person ID of the current user may be specified. Bots must include this
            parameter to list messages in group rooms (spaces).
        :type mentioned_people: List[str]
        :param before: List messages sent before a date and time.
        :type before: str
        :param before_message: List messages sent before a message, by ID.
        :type before_message: str

        documentation: https://developer.webex.com/docs/api/v1/messages/list-messages
        """
        params['roomId'] = room_id
        if parent_id is not None:
            params['parentId'] = parent_id
        if mentioned_people is not None:
            params['mentionedPeople'] = mentioned_people
        if before is not None:
            params['before'] = before
        if before_message is not None:
            params['beforeMessage'] = before_message
        url = self.ep()
        return self.session.follow_pagination(url=url, model=ListMessage, params=params)

    def list_direct(self, parent_id: str = None, person_id: str = None, person_email: str = None) -> list[DirectMessage]:
        """
        List all messages in a 1:1 (direct) room. Use the personId or personEmail query parameter to specify the room.
        Each message will include content attachments if present.
        The list sorts the messages in descending order by creation date.

        :param parent_id: List messages with a parent, by ID.
        :type parent_id: str
        :param person_id: List messages in a 1:1 room, by person ID.
        :type person_id: str
        :param person_email: List messages in a 1:1 room, by person email.
        :type person_email: str

        documentation: https://developer.webex.com/docs/api/v1/messages/list-direct-messages
        """
        params = {}
        if parent_id is not None:
            params['parentId'] = parent_id
        if person_id is not None:
            params['personId'] = person_id
        if person_email is not None:
            params['personEmail'] = person_email
        url = self.ep('direct')
        data = super().get(url=url, params=params)
        return parse_obj_as(list[DirectMessage], data["items"])

    def create(self, room_id: str, text: str = None, markdown: str = None, parent_id: str = None, to_person_id: str = None, to_person_email: str = None, files: List[str] = None, attachments: Attachment = None) -> CreateMessageResponse:
        """
        Post a plain text or rich text message, and optionally, a file attachment attachment, to a room.
        The files parameter is an array, which accepts multiple values to allow for future expansion, but currently
        only one file may be included with the message. File previews are only rendered for attachments of 1MB or less.

        :param room_id: The room ID of the message.
        :type room_id: str
        :param text: The message, in plain text. If markdown is specified this parameter may be optionally used to
            provide alternate text for UI clients that do not support rich text. The maximum message length is 7439
            bytes.
        :type text: str
        :param markdown: The message, in Markdown format. If this attribute is set ensure that the request does NOT
            contain an html attribute.
        :type markdown: str
        :param parent_id: The parent message to reply to.
        :type parent_id: str
        :param to_person_id: The person ID of the recipient when sending a private 1:1 message.
        :type to_person_id: str
        :param to_person_email: The email address of the recipient when sending a private 1:1 message.
        :type to_person_email: str
        :param files: The public URL to a binary file to be posted into the room. Only one file is allowed per message.
            Uploaded files are automatically converted into a format that all Webex clients can render. For the
            supported media types and the behavior of uploads, see the Message Attachments Guide. Possible values:
            http://www.example.com/images/media.png
        :type files: List[str]
        :param attachments: Content attachments to attach to the message. Only one card per message is supported. See
            the Cards Guide for more information.
        :type attachments: Attachment

        documentation: https://developer.webex.com/docs/api/v1/messages/create-a-message
        """
        body = CreateMessageBody()
        if room_id is not None:
            body.room_id = room_id
        if text is not None:
            body.text = text
        if markdown is not None:
            body.markdown = markdown
        if parent_id is not None:
            body.parent_id = parent_id
        if to_person_id is not None:
            body.to_person_id = to_person_id
        if to_person_email is not None:
            body.to_person_email = to_person_email
        if files is not None:
            body.files = files
        if attachments is not None:
            body.attachments = attachments
        url = self.ep()
        data = super().post(url=url, data=body.json())
        return CreateMessageResponse.parse_obj(data)

    def edit(self, message_id: str, room_id: str, text: str = None, markdown: str = None) -> ListMessage:
        """
        Update a message you have posted not more than 10 times.
        Specify the messageId of the message you want to edit.
        Edits of messages containing files or attachments are not currently supported.
        If a user attempts to edit a message containing files or attachments a 400 Bad Request will be returned by the
        API with a message stating that the feature is currently unsupported.
        There is also a maximum number of times a user can edit a message. The maximum currently supported is 10 edits
        per message.
        If a user attempts to edit a message greater that the maximum times allowed the API will return 400 Bad Request
        with a message stating the edit limit has been reached.
        While only the roomId and text or markdown attributes are required in the request body, a common pattern for
        editing message is to first call GET /messages/{id} for the message you wish to edit and to then update the
        text or markdown attribute accordingly, passing the updated message object in the request body of the PUT
        /messages/{id} request.
        When this pattern is used on a message that included markdown, the html attribute must be deleted prior to
        making the PUT request.

        :param message_id: The unique identifier for the message.
        :type message_id: str
        :param room_id: The room ID of the message.
        :type room_id: str
        :param text: The message, in plain text. If markdown is specified this parameter may be optionally used to
            provide alternate text for UI clients that do not support rich text. The maximum message length is 7439
            bytes.
        :type text: str
        :param markdown: The message, in Markdown format. If this attribute is set ensure that the request does NOT
            contain an html attribute.
        :type markdown: str

        documentation: https://developer.webex.com/docs/api/v1/messages/edit-a-message
        """
        body = EditMessageBody()
        if room_id is not None:
            body.room_id = room_id
        if text is not None:
            body.text = text
        if markdown is not None:
            body.markdown = markdown
        url = self.ep(f'{message_id}')
        data = super().put(url=url, data=body.json())
        return ListMessage.parse_obj(data)

    def details(self, message_id: str) -> ListMessage:
        """
        Show details for a message, by message ID.
        Specify the message ID in the messageId parameter in the URI.

        :param message_id: The unique identifier for the message.
        :type message_id: str

        documentation: https://developer.webex.com/docs/api/v1/messages/get-message-details
        """
        url = self.ep(f'{message_id}')
        data = super().get(url=url)
        return ListMessage.parse_obj(data)

    def delete(self, message_id: str):
        """
        Delete a message, by message ID.
        Specify the message ID in the messageId parameter in the URI.

        :param message_id: The unique identifier for the message.
        :type message_id: str

        documentation: https://developer.webex.com/docs/api/v1/messages/delete-a-message
        """
        url = self.ep(f'{message_id}')
        super().delete(url=url)
        return

class ListOrganizationsResponse(ApiModel):
    items: Optional[list[Organization]]


class OrganizationsApi(ApiChild, base='organizations'):
    """
    A set of people in Webex. Organizations may manage other organizations or be managed themselves. This organizations
    resource can be accessed only by an admin.
    Applications can delete an Organization only after they have been authorized by a user with the Full Administrator
    Role which may be a user in the customer org or a user in a managing partner organization to which the role has
    been granted. The authorizing admin must grant the spark-admin:organizations-write scope.
    """

    def list(self) -> list[Organization]:
        """
        List all organizations visible by your account. The results will not be paginated.

        documentation: https://developer.webex.com/docs/api/v1/organizations/list-organizations
        """
        url = self.ep()
        data = super().get(url=url)
        return parse_obj_as(list[Organization], data["items"])

    def details(self, org_id: str) -> Organization:
        """
        Shows details for an organization, by ID.
        Specify the org ID in the orgId parameter in the URI.

        :param org_id: The unique identifier for the organization.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/organizations/get-organization-details
        """
        url = self.ep(f'{org_id}')
        data = super().get(url=url)
        return Organization.parse_obj(data)

    def delete(self, org_id: str):
        """
        Deletes an organization, by ID. It may take up to 10 minutes for the organization to be deleted after the
        response is returned.
        Specify the org ID in the orgId parameter in the URI.
        Deleting an Organization may fail with a HTTP 409 Conflict response and encounter one or more of the errors
        described below. Resolve these conditions to allow the delete to succeed.

        :param org_id: The unique identifier for the organization.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/organizations/delete-organization
        """
        url = self.ep(f'{org_id}')
        super().delete(url=url)
        return

class IdentityManagedOrg(ApiModel):
    #: The org ID of the managed org.
    org_id: Optional[str]
    #: role ID of the user to this org.
    role: Optional[str]


class PartnerAdminUser(ApiModel):
    #: The user ID of the partner admin.
    id: Optional[str]
    #: The display name of the partner admin.
    display_name: Optional[str]
    #: The first name of the partner admin.
    first_name: Optional[str]
    #: The last name of the partner admin.
    last_name: Optional[str]
    #: List of emails for the partner admin.
    emails: Optional[list[str]]
    #: The role of this partner admin in the given customer org.
    role_in_customer_org: Optional[str]


class GetAllCustomersManagedBypartnerAdminResponse(ApiModel):
    #: An array of managed orgs objects.
    items: Optional[list[IdentityManagedOrg]]


class GetAllPartnerAdminsAssignedTocustomerResponse(ApiModel):
    #: An array of partner admin user details.
    items: Optional[list[PartnerAdminUser]]


class PartnerManagementApi(ApiChild, base='partner/organizations'):
    """
    Partner organizations that manage their customers through Webex Partner Hub can leverage this API to assign or
    unassign partner administrator roles to their users, as well as assign or unassign customer organizations to
    specific partner administrators.
    Managing other partner administrators in an organization requires the partner full administrator role. The users
    being acted upon also exist in the partners own organization. To create a user, see People API. The authorizing
    admin must grant the spark-admin:organizations-read scope for read operations and spark-admin:organizations-write
    scope for write operations.
    """

    def all_customers_managed_bypartner(self, managed_by: str) -> list[IdentityManagedOrg]:
        """
        Get all customers managed by given partner admin, in the managedBy request parameter.
        This API can be used by partner full admin and partner readonly admin.
        Specify the personId in the managedBy parameter in the URI.

        :param managed_by: List customer orgs associated with this person ID.
        :type managed_by: str

        documentation: https://developer.webex.com/docs/api/v1/partner-management/get-all-customers-managed-by-a-partner-admin
        """
        params = {}
        params['managedBy'] = managed_by
        url = self.ep()
        data = super().get(url=url, params=params)
        return parse_obj_as(list[IdentityManagedOrg], data["items"])

    def all_partner_assigned_tocustomer(self, org_id: str) -> list[PartnerAdminUser]:
        """
        For a given customer, get all the partner admins with their role details.
        This API can be used by partner full admin.
        Specify the orgId in the path parameter.

        :param org_id: List partner admins associated with this customer org ID.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/partner-management/get-all-partner-admins-assigned-to-a-customer
        """
        url = self.ep(f'{org_id}/partnerAdmins')
        data = super().get(url=url)
        return parse_obj_as(list[PartnerAdminUser], data["items"])

    def assign_partner_tocustomer(self, org_id: str, person_id: str):
        """
        Assign a specific partner admin to a customer organization. The partner admin is a user that has the partner
        administrator role.
        Other partner roles, such as partner full administrator are not applicable for this API, since this role
        manages all customer organizations.
        This API can be used by partner full admin.
        Specify the orgId and the personId in the path param.

        :param org_id: The ID of the customer organization.
        :type org_id: str
        :param person_id: User ID of the partner admin in the partners org.
        :type person_id: str

        documentation: https://developer.webex.com/docs/api/v1/partner-management/assign-partner-admin-to-a-customer
        """
        url = self.ep(f'{org_id}/partnerAdmin/{person_id}/assign')
        super().post(url=url)
        return

    def unassign_partner_fromcustomer(self, org_id: str, person_id: str):
        """
        Unassign a specific partner admin from a customer organization. The partner admin is a user that has the
        partner administrator role.
        Unassigning a customer organization from a partner admin does not remove the role from the user.
        This API can be used by partner full admin.
        Specify the orgId and the personId in the path param.

        :param org_id: The ID of the customer organization.
        :type org_id: str
        :param person_id: User ID of the partner admin in the partners org.
        :type person_id: str

        documentation: https://developer.webex.com/docs/api/v1/partner-management/unassign-partner-admin-from-a-customer
        """
        url = self.ep(f'{org_id}/partnerAdmin/{person_id}/unassign')
        super().delete(url=url)
        return

    def revoke_all_partner_roles_forgiven_person_id(self, person_id: str):
        """
        Revoke all partner administrator roles from a user, thereby revoking access to Partner Hub and all managed
        customer organizations.
        This action does not grant or revoke Control Hub administrator roles (e.g. full administrator, user and device
        administrator, etc.).
        This API can be used by partner full admin.
        Specify the personId in the path param.

        :param person_id: ID of the user whose partner roles needs to be revoked.
        :type person_id: str

        documentation: https://developer.webex.com/docs/api/v1/partner-management/revoke-all-partner-admin-roles-for-a-given-person-id
        """
        url = self.ep(f'partnerAdmin/{person_id}')
        super().delete(url=url)
        return

class TagsObj(ApiModel):
    #: Name of the tag.
    name: Optional[str]
    #: Description of the tag
    description: Optional[str]


class GetCustomerOrganizationsTagsResponse(ApiModel):
    #: Name of the customer organization.
    org_name: Optional[str]
    #: The unique identifier for the customer organization.
    org_id: Optional[str]
    #: An array of tags.
    tags: Optional[list[str]]


class CreateOrReplaceExistingCustomerTagsWithprovidedOnesBody(ApiModel):
    #: An array of tags.
    tags: Optional[list[TagsObj]]


class CreateOrReplaceExistingSubscriptionTagsWithprovidedOnesBody(ApiModel):
    #: An array of tags.
    tags: Optional[list[TagsObj]]


class FetchSubscriptionResponse(GetCustomerOrganizationsTagsResponse):
    #: The unique identifier for the subscription.
    subscription_id: Optional[str]
    #: boolean flag for trial or not.
    trial: Optional[str]


class PartnerTagsApi(ApiChild, base='partner/tags'):
    """
    Customer organization tags offer a flexible way of identifying and grouping customer organizations. Tags are
    configured by partners for their customers and are neither visible to other partners nor the customers themselves.
    To manage tags, the user must have a full partner admin or partner admin role. The authorizing admin must grant the
    spark-admin:organizations-read scope for read operations and spark-admin:organizations-write scope for write
    operations.
    """

    def retrieve_all_customer(self, type_: str):
        """
        Retrieves all tags which are being used by any customer organizations. Once a tag is unassigned from the last
        customer, it is automatically removed and is not returned by this API.
        This API can be used by a partner full admin, a read-only partner, or an partner admin.
        The type can have the value ORGANIZATION or SUBSCRIPTION. If not provided, the value is ORGANIZATION

        :param type_: List tags associated with an organization.
        :type type_: str

        documentation: https://developer.webex.com/docs/api/v1/partner-tags/retrieve-all-customer-tags
        """
        params = {}
        params['type'] = type_
        url = self.ep()
        super().get(url=url, params=params)
        return $!$!$!   # this is weird. Check the spec at https://developer.webex.com/docs/api/v1/partner-tags/retrieve-all-customer-tags

    def create_or_replace_existing_customer_withprovided_ones(self, org_id: str, tags: TagsObj = None):
        """
        Assign or replace tag(s) which for a customer organization. If the tag doesn't already exist, a new one is
        created and assigned to the customer automatically.
        This API can be used by partner full admins and partner admins.
        Each tag has a character limit of 25. Currently, there is a limit of 5 tags per organization when creating
        tags. To remove all the tags, pass an empty array.
        Specify the customer organization ID in the orgId parameter in the URI.

        :param org_id: The unique identifier for the customer organization.
        :type org_id: str
        :param tags: An array of tags.
        :type tags: TagsObj

        documentation: https://developer.webex.com/docs/api/v1/partner-tags/create-or-replace-existing-customer-tags-with-the-provided-ones
        """
        body = CreateOrReplaceExistingCustomerTagsWithprovidedOnesBody()
        if tags is not None:
            body.tags = tags
        url = self.ep(f'organizations/{org_id}/assignTags')
        super().post(url=url, data=body.json())
        return

    def customer_organizations(self, org_id: str) -> GetCustomerOrganizationsTagsResponse:
        """
        Retrieve tags associated with a customer organization based on the orgId provided.
        This API can be used by a partner full admin, a read-only partner, or an partner admin.
        Specify the customer orgId in the orgId parameter in the URI.

        :param org_id: Fetch all customers and associated tags for the customer.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/partner-tags/get-customer-organization's-tags
        """
        url = self.ep(f'organizations/{org_id}')
        data = super().get(url=url)
        return GetCustomerOrganizationsTagsResponse.parse_obj(data)

    def fetch_all_customers_forgiven_set_of(self, tags: str, max: int = None):
        """
        For a set of tags, retrieve all customer organizations that match any one of the tags.
        This API can be used by a partner full admin, a read-only partner, or an partner admin.

        :param tags: A comma separated list of tags to filter by.
        :type tags: str
        :param max: Value must be between 1 and 100, inclusive.
        :type max: int

        documentation: https://developer.webex.com/docs/api/v1/partner-tags/fetch-all-customers-for-a-given-set-of-tags
        """
        params = {}
        params['tags'] = tags
        if max is not None:
            params['max'] = max
        url = self.ep('organizations')
        super().get(url=url, params=params)
        return $!$!$!   # this is weird. Check the spec at https://developer.webex.com/docs/api/v1/partner-tags/fetch-all-customers-for-a-given-set-of-tags

    def create_or_replace_existing_subscription_withprovided_ones(self, org_id: str, subscription_id: str, tags: TagsObj = None):
        """
        Assign or replace tags specific to each subscription for an organization. Each organization may have one or
        more subscriptions.
        This API can be used by partner full admins and partner admins.
        Currently there is a limit of 5 tags per subscription when creating tags. To remove all the tags, pass an empty
        array.
        Specify the customer organization ID in the orgId parameter in the URI and subscription ID in subscriptionId
        parameter

        :param org_id: The unique identifier for the customer organization.
        :type org_id: str
        :param subscription_id: The unique identifier for the subscription.
        :type subscription_id: str
        :param tags: An array of tags.
        :type tags: TagsObj

        documentation: https://developer.webex.com/docs/api/v1/partner-tags/create-or-replace-existing-subscription-tags-with-the-provided-ones
        """
        body = CreateOrReplaceExistingSubscriptionTagsWithprovidedOnesBody()
        if tags is not None:
            body.tags = tags
        url = self.ep(f'organizations/{org_id}/subscriptions/{subscription_id}/assignTags')
        super().post(url=url, data=body.json())
        return

    def subscription_list_ongiven_tag_name_orset_of(self, tags: str, max: int = None):
        """
        For a partner organization fetch all it's subscriptions with their tag list for a given tag names.
        This API can be used by partner full admins, partner admins and admin read-only partners.

        :param tags: A comma separated list of tags to filter by.
        :type tags: str
        :param max: Value must be between 1 and 100, inclusive.
        :type max: int

        documentation: https://developer.webex.com/docs/api/v1/partner-tags/subscription-list-on-a-given-tag-name-or-a-set-of-tags
        """
        params = {}
        params['tags'] = tags
        if max is not None:
            params['max'] = max
        url = self.ep('subscriptions')
        super().get(url=url, params=params)
        return $!$!$!   # this is weird. Check the spec at https://developer.webex.com/docs/api/v1/partner-tags/subscription-list-on-a-given-tag-name-or-a-set-of-tags

    def fetch_subscription(self, org_id: str, subscription_id: str) -> FetchSubscriptionResponse:
        """
        For a given partner org, customer org and external subscription id, fetch subscription details with its
        associated tags.
        This API can be used by partner full admins, partner admins and admin read-only partners.

        :param org_id: The unique identifier for the customer organization.
        :type org_id: str
        :param subscription_id: The unique identifier for the subscription.
        :type subscription_id: str

        documentation: https://developer.webex.com/docs/api/v1/partner-tags/fetch-a-subscription
        """
        url = self.ep(f'organizations/{org_id}/subscriptions/{subscription_id}')
        data = super().get(url=url)
        return FetchSubscriptionResponse.parse_obj(data)

class PhoneNumbers(ApiModel):
    #: The type of phone number.
    #: Possible values: work, mobile, fax
    type: Optional[str]
    #: The phone number.
    #: Possible values: +1 408 526 7209
    value: Optional[str]


class SipAddressesType(PhoneNumbers):
    primary: Optional[bool]


class Status32(str, Enum):
    #: The webhook is active.
    active = 'active'
    #: The webhook is inactive.
    inactive = 'inactive'


class Status15(Status32):
    #: The user is in a call
    call = 'call'
    #: The user has manually set their status to "Do Not Disturb"
    do_not_disturb = 'DoNotDisturb'
    #: The user is in a meeting
    meeting = 'meeting'
    #: The user or a Hybrid Calendar service has indicated that they are "Out of Office"
    out_of_office = 'OutOfOffice'
    #: The user has never logged in; a status cannot be determined
    pending = 'pending'
    #: The user is sharing content
    presenting = 'presenting'
    #: The user’s status could not be determined
    unknown = 'unknown'


class Type15(str, Enum):
    #: Account belongs to a person
    person = 'person'
    #: Account is a bot user
    bot = 'bot'
    #: Account is a guest user
    appuser = 'appuser'


class Addresses(ApiModel):
    #: The type of address
    #: Possible values: work
    type: Optional[str]
    #: The user's country
    #: Possible values: US
    country: Optional[str]
    #: the user's locality, often city
    #: Possible values: Milpitas
    locality: Optional[str]
    #: the user's region, often state
    #: Possible values: California
    region: Optional[str]
    #: the user's street
    #: Possible values: 1099 Bird Ave.
    street_address: Optional[str]
    #: the user's postal or zip code
    #: Possible values: 99212
    postal_code: Optional[str]


class CreatePersonBody(ApiModel):
    #: The email addresses of the person. Only one email address is allowed per person.
    #: Possible values: john.andersen@example.com
    emails: Optional[list[str]]
    #: Phone numbers for the person. Only settable for Webex Calling. Requires a Webex Calling license.
    phone_numbers: Optional[list[PhoneNumbers]]
    #: Webex Calling extension of the person. This is only settable for a person with a Webex Calling license.
    extension: Optional[str]
    #: The ID of the location for this person.
    location_id: Optional[str]
    #: The full name of the person.
    display_name: Optional[str]
    #: The first name of the person.
    first_name: Optional[str]
    #: The last name of the person.
    last_name: Optional[str]
    #: The URL to the person's avatar in PNG format.
    avatar: Optional[str]
    #: The ID of the organization to which this person belongs.
    org_id: Optional[str]
    #: An array of role strings representing the roles to which this admin user belongs.
    #: Possible values: Y2lzY29zcGFyazovL3VzL1JPTEUvOTZhYmMyYWEtM2RjYy0xMWU1LWExNTItZmUzNDgxOWNkYzlh,
    #: Y2lzY29zcGFyazovL3VzL1JPTEUvOTZhYmMyYWEtM2RjYy0xMWU1LWIyNjMtMGY0NTkyYWRlZmFi
    roles: Optional[list[str]]
    #: An array of license strings allocated to this person.
    #: Possible values: Y2lzY29zcGFyazovL3VzL0xJQ0VOU0UvOTZhYmMyYWEtM2RjYy0xMWU1LWExNTItZmUzNDgxOWNkYzlh,
    #: Y2lzY29zcGFyazovL3VzL0xJQ0VOU0UvOTZhYmMyYWEtM2RjYy0xMWU1LWIyNjMtMGY0NTkyYWRlZmFi
    licenses: Optional[list[str]]
    #: The business department the user belongs to.
    department: Optional[str]
    #: A manager identifier.
    manager: Optional[str]
    #: Person Id of the manager
    manager_id: Optional[str]
    #: the person's title
    title: Optional[str]
    #: Person's address
    addresses: Optional[list[Addresses]]
    #: One or several site names where this user has an attendee role. Append #attendee to the sitename (eg:
    #: mysite.webex.com#attendee)
    #: Possible values: mysite.webex.com#attendee
    site_urls: Optional[list[str]]


class Person(CreatePersonBody):
    #: A unique identifier for the person.
    id: Optional[str]
    #: The nickname of the person if configured. If no nickname is configured for the person, this field will not be
    #: present.
    nick_name: Optional[str]
    #: The date and time the person was created.
    created: Optional[str]
    #: The date and time the person was last changed.
    last_modified: Optional[str]
    #: The time zone of the person if configured. If no timezone is configured on the account, this field will not be
    #: present
    timezone: Optional[str]
    #: The date and time of the person's last activity within Webex. This will only be returned for people within your
    #: organization or an organization you manage. Presence information will not be shown if the authenticated user has
    #: disabled status sharing.
    last_activity: Optional[str]
    #: The users sip addresses. Read-only.
    sip_addresses: Optional[list[SipAddressesType]]
    #: The current presence status of the person. This will only be returned for people within your organization or an
    #: organization you manage. Presence information will not be shown if the authenticated user has disabled status
    #: sharing.
    status: Optional[Status15]
    #: Whether or not an invite is pending for the user to complete account activation. This property is only returned
    #: if the authenticated user is an admin user for the person's organization.
    invite_pending: Optional[bool]
    #: Whether or not the user is allowed to use Webex. This property is only returned if the authenticated user is an
    #: admin user for the person's organization.
    login_enabled: Optional[bool]
    #: The type of person account, such as person or bot.
    type: Optional[Type15]


class ListPeopleResponse(ApiModel):
    #: An array of person objects.
    items: Optional[list[Person]]
    #: An array of person IDs that could not be found.
    not_found_ids: Optional[list[str]]


class UpdatePersonBody(CreatePersonBody):
    #: The nickname of the person if configured. Set to the firstName automatically in update request.
    nick_name: Optional[str]
    #: Whether or not the user is allowed to use Webex. This property is only accessible if the authenticated user is
    #: an admin user for the person's organization.
    login_enabled: Optional[bool]


class PeopleApi(ApiChild, base='people'):
    """
    People are registered users of Webex. Searching and viewing People requires an auth token with a scope of
    spark:people_read. Viewing the list of all People in your Organization requires an administrator auth token with
    spark-admin:people_read scope. Adding, updating, and removing People requires an administrator auth token with the
    spark-admin:people_write and spark-admin:people_read scope.
    A person's call settings are for Webex Calling and necessitate Webex Calling licenses.
    To learn more about managing people in a room see the Memberships API. For information about how to allocate Hybrid
    Services licenses to people, see the Managing Hybrid Services guide.
    """

    def list_people(self, email: str = None, display_name: str = None, id: str = None, org_id: str = None, roles: str = None, calling_data: bool = None, location_id: str = None, **params) -> Generator[Person, None, None]:
        """
        List people in your organization. For most users, either the email or displayName parameter is required. Admin
        users can omit these fields and list all users in their organization.
        Response properties associated with a user's presence status, such as status or lastActivity, will only be
        returned for people within your organization or an organization you manage. Presence information will not be
        returned if the authenticated user has disabled status sharing.
        Admin users can include Webex Calling (BroadCloud) user details in the response by specifying callingData
        parameter as true. Admin users can list all users in a location or with a specific phone number. Admin users
        will receive an enriched payload with additional administrative fields like liceneses,roles etc. These fields
        are shown when accessing a user via GET /people/{id}, not when doing a GET /people?id=
        Lookup by email is only supported for people within the same org or where a partner admin relationship is in
        place.
        Lookup by roles is only supported for Admin users for the people within the same org.
        Long result sets will be split into pages.

        :param email: List people with this email address. For non-admin requests, either this or displayName are
            required. With the exception of partner admins and a managed org relationship, people lookup by email is
            only available for users in the same org.
        :type email: str
        :param display_name: List people whose name starts with this string. For non-admin requests, either this or
            email are required.
        :type display_name: str
        :param id: List people by ID. Accepts up to 85 person IDs separated by commas. If this parameter is provided
            then presence information (such as the lastActivity or status properties) will not be included in the
            response.
        :type id: str
        :param org_id: List people in this organization. Only admin users of another organization (such as partners)
            may use this parameter.
        :type org_id: str
        :param roles: List of roleIds separated by commas.
        :type roles: str
        :param calling_data: Include Webex Calling user details in the response.
        :type calling_data: bool
        :param location_id: List people present in this location.
        :type location_id: str

        documentation: https://developer.webex.com/docs/api/v1/people/list-people
        """
        if email is not None:
            params['email'] = email
        if display_name is not None:
            params['displayName'] = display_name
        if id is not None:
            params['id'] = id
        if org_id is not None:
            params['orgId'] = org_id
        if roles is not None:
            params['roles'] = roles
        if calling_data is not None:
            params['callingData'] = str(calling_data).lower()
        if location_id is not None:
            params['locationId'] = location_id
        url = self.ep()
        return self.session.follow_pagination(url=url, model=Person, params=params)

    def create(self, emails: List[str], calling_data: bool = None, phone_numbers: PhoneNumbers = None, extension: str = None, location_id: str = None, display_name: str = None, first_name: str = None, last_name: str = None, avatar: str = None, org_id: str = None, roles: List[str] = None, licenses: List[str] = None, department: str = None, manager: str = None, manager_id: str = None, title: str = None, addresses: Addresses = None, site_urls: List[str] = None) -> Person:
        """
        Create a new user account for a given organization. Only an admin can create a new user account.
        At least one of the following body parameters is required to create a new user: displayName, firstName,
        lastName.
        Currently, users may have only one email address associated with their account. The emails parameter is an
        array, which accepts multiple values to allow for future expansion, but currently only one email address will
        be used for the new user.
        Admin users can include Webex calling (BroadCloud) user details in the response by specifying callingData
        parameter as true.
        When doing attendee management, append #attendee to the siteUrl parameter (e.g. mysite.webex.com#attendee) to
        make the new user an attendee for a site.

        :param emails: The email addresses of the person. Only one email address is allowed per person. Possible
            values: john.andersen@example.com
        :type emails: List[str]
        :param calling_data: Include Webex Calling user details in the response.
        :type calling_data: bool
        :param phone_numbers: Phone numbers for the person. Only settable for Webex Calling. Requires a Webex Calling
            license.
        :type phone_numbers: PhoneNumbers
        :param extension: Webex Calling extension of the person. This is only settable for a person with a Webex
            Calling license.
        :type extension: str
        :param location_id: The ID of the location for this person.
        :type location_id: str
        :param display_name: The full name of the person.
        :type display_name: str
        :param first_name: The first name of the person.
        :type first_name: str
        :param last_name: The last name of the person.
        :type last_name: str
        :param avatar: The URL to the person's avatar in PNG format.
        :type avatar: str
        :param org_id: The ID of the organization to which this person belongs.
        :type org_id: str
        :param roles: An array of role strings representing the roles to which this admin user belongs. Possible
            values: Y2lzY29zcGFyazovL3VzL1JPTEUvOTZhYmMyYWEtM2RjYy0xMWU1LWExNTItZmUzNDgxOWNkYzlh,
            Y2lzY29zcGFyazovL3VzL1JPTEUvOTZhYmMyYWEtM2RjYy0xMWU1LWIyNjMtMGY0NTkyYWRlZmFi
        :type roles: List[str]
        :param licenses: An array of license strings allocated to this person. Possible values:
            Y2lzY29zcGFyazovL3VzL0xJQ0VOU0UvOTZhYmMyYWEtM2RjYy0xMWU1LWExNTItZmUzNDgxOWNkYzlh,
            Y2lzY29zcGFyazovL3VzL0xJQ0VOU0UvOTZhYmMyYWEtM2RjYy0xMWU1LWIyNjMtMGY0NTkyYWRlZmFi
        :type licenses: List[str]
        :param department: The business department the user belongs to.
        :type department: str
        :param manager: A manager identifier.
        :type manager: str
        :param manager_id: Person Id of the manager
        :type manager_id: str
        :param title: the person's title
        :type title: str
        :param addresses: Person's address
        :type addresses: Addresses
        :param site_urls: One or several site names where this user has an attendee role. Append #attendee to the
            sitename (eg: mysite.webex.com#attendee) Possible values: mysite.webex.com#attendee
        :type site_urls: List[str]

        documentation: https://developer.webex.com/docs/api/v1/people/create-a-person
        """
        params = {}
        if calling_data is not None:
            params['callingData'] = str(calling_data).lower()
        body = CreatePersonBody()
        if emails is not None:
            body.emails = emails
        if phone_numbers is not None:
            body.phone_numbers = phone_numbers
        if extension is not None:
            body.extension = extension
        if location_id is not None:
            body.location_id = location_id
        if display_name is not None:
            body.display_name = display_name
        if first_name is not None:
            body.first_name = first_name
        if last_name is not None:
            body.last_name = last_name
        if avatar is not None:
            body.avatar = avatar
        if org_id is not None:
            body.org_id = org_id
        if roles is not None:
            body.roles = roles
        if licenses is not None:
            body.licenses = licenses
        if department is not None:
            body.department = department
        if manager is not None:
            body.manager = manager
        if manager_id is not None:
            body.manager_id = manager_id
        if title is not None:
            body.title = title
        if addresses is not None:
            body.addresses = addresses
        if site_urls is not None:
            body.site_urls = site_urls
        url = self.ep()
        data = super().post(url=url, params=params, data=body.json())
        return Person.parse_obj(data)

    def details(self, person_id: str, calling_data: bool = None) -> Person:
        """
        Shows details for a person, by ID.
        Response properties associated with a user's presence status, such as status or lastActivity, will only be
        displayed for people within your organization or an organization you manage. Presence information will not be
        shown if the authenticated user has disabled status sharing.
        Admin users can include Webex Calling (BroadCloud) user details in the response by specifying callingData
        parameter as true.
        Specify the person ID in the personId parameter in the URI.

        :param person_id: A unique identifier for the person.
        :type person_id: str
        :param calling_data: Include Webex Calling user details in the response.
        :type calling_data: bool

        documentation: https://developer.webex.com/docs/api/v1/people/get-person-details
        """
        params = {}
        if calling_data is not None:
            params['callingData'] = str(calling_data).lower()
        url = self.ep(f'{person_id}')
        data = super().get(url=url, params=params)
        return Person.parse_obj(data)

    def update(self, person_id: str, emails: List[str], calling_data: bool = None, show_all_types: bool = None, phone_numbers: PhoneNumbers = None, extension: str = None, location_id: str = None, display_name: str = None, first_name: str = None, last_name: str = None, avatar: str = None, org_id: str = None, roles: List[str] = None, licenses: List[str] = None, department: str = None, manager: str = None, manager_id: str = None, title: str = None, addresses: Addresses = None, site_urls: List[str] = None, nick_name: str = None, login_enabled: bool = None) -> Person:
        """
        Update details for a person, by ID.
        Specify the person ID in the personId parameter in the URI. Only an admin can update a person details.
        Include all details for the person. This action expects all user details to be present in the request. A common
        approach is to first GET the person's details, make changes, then PUT both the changed and unchanged values.
        Admin users can include Webex Calling (BroadCloud) user details in the response by specifying callingData
        parameter as true.
        Note: The locationId can only be set when adding a calling license to a user. It cannot be changed if a user is
        already an existing calling user.
        When doing attendee management, to update a user from host role to an attendee for a site append #attendee to
        the respective siteUrl and remove the meeting host license for this site from the license array.
        To update a person from an attendee role to a host for a site, add the meeting license for this site in the
        meeting array, and remove that site from the siteurl parameter.
        To remove the attendee privilege for a user on a meeting site, remove the sitename#attendee from the siteUrls
        array. The showAllTypes parameter must be set to true.

        :param person_id: A unique identifier for the person.
        :type person_id: str
        :param emails: The email addresses of the person. Only one email address is allowed per person. Possible
            values: john.andersen@example.com
        :type emails: List[str]
        :param calling_data: Include Webex Calling user details in the response.
        :type calling_data: bool
        :param show_all_types: Include additional user data like #attendee role
        :type show_all_types: bool
        :param phone_numbers: Phone numbers for the person. Only settable for Webex Calling. Requires a Webex Calling
            license.
        :type phone_numbers: PhoneNumbers
        :param extension: Webex Calling extension of the person. This is only settable for a person with a Webex
            Calling license.
        :type extension: str
        :param location_id: The ID of the location for this person.
        :type location_id: str
        :param display_name: The full name of the person.
        :type display_name: str
        :param first_name: The first name of the person.
        :type first_name: str
        :param last_name: The last name of the person.
        :type last_name: str
        :param avatar: The URL to the person's avatar in PNG format.
        :type avatar: str
        :param org_id: The ID of the organization to which this person belongs.
        :type org_id: str
        :param roles: An array of role strings representing the roles to which this admin user belongs. Possible
            values: Y2lzY29zcGFyazovL3VzL1JPTEUvOTZhYmMyYWEtM2RjYy0xMWU1LWExNTItZmUzNDgxOWNkYzlh,
            Y2lzY29zcGFyazovL3VzL1JPTEUvOTZhYmMyYWEtM2RjYy0xMWU1LWIyNjMtMGY0NTkyYWRlZmFi
        :type roles: List[str]
        :param licenses: An array of license strings allocated to this person. Possible values:
            Y2lzY29zcGFyazovL3VzL0xJQ0VOU0UvOTZhYmMyYWEtM2RjYy0xMWU1LWExNTItZmUzNDgxOWNkYzlh,
            Y2lzY29zcGFyazovL3VzL0xJQ0VOU0UvOTZhYmMyYWEtM2RjYy0xMWU1LWIyNjMtMGY0NTkyYWRlZmFi
        :type licenses: List[str]
        :param department: The business department the user belongs to.
        :type department: str
        :param manager: A manager identifier.
        :type manager: str
        :param manager_id: Person Id of the manager
        :type manager_id: str
        :param title: the person's title
        :type title: str
        :param addresses: Person's address
        :type addresses: Addresses
        :param site_urls: One or several site names where this user has an attendee role. Append #attendee to the
            sitename (eg: mysite.webex.com#attendee) Possible values: mysite.webex.com#attendee
        :type site_urls: List[str]
        :param nick_name: The nickname of the person if configured. Set to the firstName automatically in update
            request.
        :type nick_name: str
        :param login_enabled: Whether or not the user is allowed to use Webex. This property is only accessible if the
            authenticated user is an admin user for the person's organization.
        :type login_enabled: bool

        documentation: https://developer.webex.com/docs/api/v1/people/update-a-person
        """
        params = {}
        if calling_data is not None:
            params['callingData'] = str(calling_data).lower()
        if show_all_types is not None:
            params['showAllTypes'] = str(show_all_types).lower()
        body = UpdatePersonBody()
        if emails is not None:
            body.emails = emails
        if phone_numbers is not None:
            body.phone_numbers = phone_numbers
        if extension is not None:
            body.extension = extension
        if location_id is not None:
            body.location_id = location_id
        if display_name is not None:
            body.display_name = display_name
        if first_name is not None:
            body.first_name = first_name
        if last_name is not None:
            body.last_name = last_name
        if avatar is not None:
            body.avatar = avatar
        if org_id is not None:
            body.org_id = org_id
        if roles is not None:
            body.roles = roles
        if licenses is not None:
            body.licenses = licenses
        if department is not None:
            body.department = department
        if manager is not None:
            body.manager = manager
        if manager_id is not None:
            body.manager_id = manager_id
        if title is not None:
            body.title = title
        if addresses is not None:
            body.addresses = addresses
        if site_urls is not None:
            body.site_urls = site_urls
        if nick_name is not None:
            body.nick_name = nick_name
        if login_enabled is not None:
            body.login_enabled = login_enabled
        url = self.ep(f'{person_id}')
        data = super().put(url=url, params=params, data=body.json())
        return Person.parse_obj(data)

    def delete(self, person_id: str):
        """
        Remove a person from the system. Only an admin can remove a person.
        Specify the person ID in the personId parameter in the URI.

        :param person_id: A unique identifier for the person.
        :type person_id: str

        documentation: https://developer.webex.com/docs/api/v1/people/delete-a-person
        """
        url = self.ep(f'{person_id}')
        super().delete(url=url)
        return

    def my_own_details(self, calling_data: bool = None) -> Person:
        """
        Get profile details for the authenticated user. This is the same as GET /people/{personId} using the Person ID
        associated with your Auth token.
        Admin users can include Webex Calling (BroadCloud) user details in the response by specifying callingData
        parameter as true.

        :param calling_data: Include Webex Calling user details in the response.
        :type calling_data: bool

        documentation: https://developer.webex.com/docs/api/v1/people/get-my-own-details
        """
        params = {}
        if calling_data is not None:
            params['callingData'] = str(calling_data).lower()
        url = self.ep('me')
        data = super().get(url=url, params=params)
        return Person.parse_obj(data)

class RecordingReportSummaryObject(ApiModel):
    #: A unique identifier for the recording.
    recording_id: Optional[str]
    #: The recording's topic.
    topic: Optional[str]
    #: The date and time the recording started in ISO 8601 compliant format. the time is the record button was clicked
    #: in the meeting.
    time_recorded: Optional[str]
    #: Site URL for the recording.
    site_url: Optional[str]
    #: Email address for the meeting host.
    host_email: Optional[str]
    #: The number of times the recording was viewed.
    view_count: Optional[int]
    #: The number of times the recording was downloaded.
    download_count: Optional[int]


class RecordingReportObject(ApiModel):
    #: A unique identifier for the recording.
    recording_id: Optional[str]
    #: The recording's topic.
    topic: Optional[str]
    #: The name of the person who accessed the recording.
    name: Optional[str]
    #: The email address of the person who accessed the recording.
    email: Optional[str]
    #: The date and time the recording was accessed in ISO 8601 compliant format.
    access_time: Optional[str]
    #: Whether or not the recording was viewed by the person.
    viewed: Optional[bool]
    #: Whether or not the recording was downloaded by the person.
    downloaded: Optional[bool]


class RecordingAchriveSummaryObject(ApiModel):
    #: A unique identifier for the meeting archive summary.
    archive_id: Optional[str]
    #: Recording achrive summary's service-type.
    service_type: Optional[ServiceType]
    #: Meeting title.
    title: Optional[str]
    #: The date and time in ISO 8601 compliant format that when the archive was created by the system.
    create_time: Optional[str]


class MeetingRecordingArchiveParticipant(CoHosts):
    #: An internal ID that is associated with each join.
    correlation_id: Optional[int]
    #: The time the participant joined the meeting.
    joined_time: Optional[str]
    #: The time the participant left the meeting.
    left_time: Optional[str]


class MeetingRecordingArchiveChat(ApiModel):
    #: Whether the type of the chat is private, public or group. Private chat is for the 1:1 chat. Public chat is for
    #: the message which is sent to all the people in the meeting. Group chat is for the message which is sent to a
    #: small group of people, like a message to the "host and presenter".
    type: Optional[str]
    #: Display name for the sender of the chat snippet.
    sender_name: Optional[str]
    #: Chat time for the chat snippet in ISO 8601 compliant format.
    chat_time: Optional[str]
    #: Information of the receivers of the chat snippet.
    target: Optional[str]
    #: The text of the chat snippet.
    text: Optional[str]


class MeetingRecordingArchiveUser(CoHosts):
    #: An internal ID that is associated with each join.
    correlation_id: Optional[int]


class Question8(ApiModel):
    #: The number of choices in the questions.
    choice_count: Optional[int]
    #: The type of the question.
    type: Optional[str]
    #: The text of the question.
    text: Optional[str]


class MeetingRecordingArchivePollAnswerSummary(ApiModel):
    #: The total number of people who selected this answer.
    total_respondents: Optional[int]
    #: Whether the answer is correct.
    is_correct: Optional[bool]
    #: The text of the answer.
    text: Optional[str]
    #: The voters among users.
    vote_users: Optional[list[MeetingRecordingArchiveUser]]


class MeetingRecordingArchivePollRespondent(Respondent):
    #: An internal ID that is associated with the respondent's each join.
    correlation_id: Optional[int]


class MeetingRecordingArchivePollQuestion(ApiModel):
    #: The voters among users.
    vote_users: Optional[list[MeetingRecordingArchiveUser]]
    #: The poll's question.
    question: Optional[Question8]
    #: The answer summary of the archive poll.
    answer_summary: Optional[list[MeetingRecordingArchivePollAnswerSummary]]
    #: The question's respondents.
    respondents: Optional[list[MeetingRecordingArchivePollRespondent]]


class Content(ApiModel):
    #: The total number of questions.
    question_count: Optional[int]
    #: The total number of users.
    user_count: Optional[int]
    #: The number of voters among users.
    voted_user_count: Optional[int]
    #: Poll's questions.
    questions: Optional[list[MeetingRecordingArchivePollQuestion]]


class MeetingRecordingArchivePoll(ApiModel):
    #: The type of the question.
    type: Optional[str]
    #: The date and time the poll started in ISO 8601 compliant format.
    start_time: Optional[str]
    #: The date and time the poll ended in ISO 8601 compliant format.
    end_time: Optional[str]
    #: The content of the meeting archive poll;
    content: Optional[Content]


class MeetingRecordingArchiveQAAnswer(MeetingRecordingArchiveUser):
    #: The answer's response mode.
    response_mode: Optional[str]
    #: The date and time the question answered in ISO 8601 compliant format.
    answer_time: Optional[str]
    #: The text of the answer.
    text: Optional[str]


class MeetingRecordingArchiveQA(ApiModel):
    #: The priority of the Q and A.
    priority: Optional[str]
    #: Whether the type of the Q and A is private, public, or group. Private Q and A is for the 1:1 chat. Public Q and
    #: A are for the message which is sent to all the people in the meeting. Group Q and A are for the message which is
    #: sent to a small group of people, like a Q and A to "host and presenter".
    type: Optional[str]
    #: The email of the user who asked the question.
    display_name: Optional[str]
    #: The date and time the question was created in ISO 8601 compliant format.
    question_time: Optional[str]
    #: Information of the user who asked the question.
    target: Optional[str]
    #: The question that was asked.
    question: Optional[str]
    #: Question's answers.
    answers: Optional[list[MeetingRecordingArchiveQAAnswer]]


class SystemInfoCatalog(ApiModel):
    #: System summary.
    system_summary: Optional[str]
    #: The browser user agent of the person who acted.
    browser: Optional[str]
    #: The type of hardware that the user used to attend the meeting.
    hardware: Optional[str]
    #: The software that the user used to attend the meeting.
    installed_software: Optional[str]
    #: The software the user used that is running.
    running_software: Optional[str]
    #: Startup Programs.
    startup_programs: Optional[str]
    #: The storage information of the user's device.
    storage: Optional[str]
    #: The video of the user's device.
    video: Optional[str]
    #: The network of the user's device.
    network: Optional[str]
    #: The operating system of the user's device.
    operating_system: Optional[str]
    #: The environment variables of the user's device.
    environment_variables: Optional[str]
    #: The processes of the user's device.
    processes: Optional[str]
    #: The logical drives of the user's device.
    logical_drives: Optional[str]
    #: The device of the user.
    devices: Optional[str]
    #: The service of the user's device.
    services: Optional[str]
    #: The system driver of the user's device.
    system_drivers: Optional[str]
    #: The sign driver system of the user's device.
    signed_drivers: Optional[str]
    #: The event viewer of the user's device.
    event_viewer: Optional[str]
    #: The basic input and output system.
    bios: Optional[str]


class MeetingRecordingArchiveSystemInfo(ApiModel):
    #: The name of the person who accessed the meeting archive.
    display_name: Optional[str]
    #: The catalogs of system information.
    catalogs: Optional[list[SystemInfoCatalog]]


class ListOfRecordingAuditReportSummariesResponse(ApiModel):
    #: An array of recording audit report summaries objects.
    items: Optional[list[RecordingReportSummaryObject]]


class GetRecordingAuditReportDetailsResponse(ApiModel):
    #: An array of recording audit report objects.
    items: Optional[list[RecordingReportObject]]


class ListMeetingArchiveSummariesResponse(ApiModel):
    #: An array of meeting archive summaries objects.
    items: Optional[list[RecordingAchriveSummaryObject]]


class GetMeetingArchiveDetailsResponse(ApiModel):
    #: A unique identifier for the meeting archive summary.
    archive_id: Optional[str]
    #: Recording achrive report's service-type.
    service_type: Optional[ServiceType]
    #: Meeting title.
    title: Optional[str]
    #: Start time for meeting in ISO 8601 compliant format.
    start: Optional[str]
    #: End time for a meeting in ISO 8601 compliant format.
    end: Optional[str]
    #: Display name for the meeting host.
    host_display_name: Optional[str]
    #: Email address for the meeting host.
    host_email: Optional[str]
    #: The participants of the meeting archive.
    participants: Optional[list[MeetingRecordingArchiveParticipant]]
    #: The chats of the meeting archive.
    chats: Optional[list[MeetingRecordingArchiveChat]]
    #: The polls of the meeting archive.
    polls: Optional[list[MeetingRecordingArchivePoll]]
    #: Meeting meeting archive's Q and A.
    qas: Optional[list[MeetingRecordingArchiveQA]]
    #: The system Information of the meeting archive, which can be only supported when serviceType is SupportCenter.
    system_infos: Optional[list[MeetingRecordingArchiveSystemInfo]]


class RecordingReportApi(ApiChild, base='recordingReport/'):
    """
    The recording report API is used to retrieve reports of recording.
    Refer to the Meetings API Scopes section of Meetings Overview for scopes required for each API.
    """

    def list_of_recording_audit_report_summaries(self, from_: str = None, to_: str = None, host_email: str = None, site_url: str = None, **params) -> Generator[RecordingReportSummaryObject, None, None]:
        """
        Lists of recording audit report summaries. You can specify a date range and the maximum number of recording
        audit report summaries to return.
        Only recording audit report summaries of meetings hosted by or shared with the authenticated user will be
        listed.
        The list returned is sorted in descending order by the date and time that the recordings were created.
        Long result sets are split into pages.

        :param from_: Starting date and time (inclusive) for recording audit report summaries to return, in any ISO
            8601 compliant format. from cannot be after to. Please note that the interval between to and from cannot
            exceed 90 days and the interval between the current time and from cannot exceed 365 days.
        :type from_: str
        :param to_: Ending date and time (exclusive) for recording audit report summaries to return, in any ISO 8601
            compliant format. to cannot be before from. Please note that the interval between to and from cannot exceed
            90 days and the interval between the current time and from cannot exceed 365 days.
        :type to_: str
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin on-behalf-of scopes. If set, the admin may specify the email of a user in a
            site they manage and the API will return recording audit report summaries of that user.
        :type host_email: str
        :param site_url: URL of the Webex site which the API lists recording audit report summaries from. If not
            specified, the API lists summary audit report for recordings from the user's preferred site. All available
            Webex sites and the preferred site of the user can be retrieved by Get Site List API.
        :type site_url: str

        documentation: https://developer.webex.com/docs/api/v1/recording-report/list-of-recording-audit-report-summaries
        """
        if from_ is not None:
            params['from'] = from_
        if to_ is not None:
            params['to'] = to_
        if host_email is not None:
            params['hostEmail'] = host_email
        if site_url is not None:
            params['siteUrl'] = site_url
        url = self.ep('accessSummary')
        return self.session.follow_pagination(url=url, model=RecordingReportSummaryObject, params=params)

    def recording_audit_report_details(self, recording_id: str, host_email: str = None, **params) -> Generator[RecordingReportObject, None, None]:
        """
        Retrieves details for a recording audit report with a specified recording ID.
        Only recording audit report details of meetings hosted by or shared with the authenticated user may be
        retrieved.

        :param recording_id: A unique identifier for the recording.
        :type recording_id: str
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin on-behalf-of scopes. If set, the admin may specify the email of a user in a
            site they manage and the API will return recording details of that user.
        :type host_email: str

        documentation: https://developer.webex.com/docs/api/v1/recording-report/get-recording-audit-report-details
        """
        params['recordingId'] = recording_id
        if host_email is not None:
            params['hostEmail'] = host_email
        url = self.ep('accessDetail')
        return self.session.follow_pagination(url=url, model=RecordingReportObject, params=params)

    def list_meeting_archive_summaries(self, from_: str = None, to_: str = None, site_url: str = None, **params) -> Generator[RecordingAchriveSummaryObject, None, None]:
        """
        Lists of meeting archive summaries. You can specify a date range and the maximum number of meeting archive
        summaries to return.
        Meeting archive summaries are only available to full administrators, not even the meeting host.
        The list returned is sorted in descending order by the date and time that the archives were created.
        Long result sets are split into pages.

        :param from_: Starting date and time (inclusive) for meeting archive summaries to return, in any ISO 8601
            compliant format. from cannot be after to. Please note that the interval between to and from cannot exceed
            30 days.
        :type from_: str
        :param to_: Ending date and time (exclusive) for meeting archive summaries to return, in any ISO 8601 compliant
            format. to cannot be before from. Please note that the interval between to and from cannot exceed 30 days.
        :type to_: str
        :param site_url: URL of the Webex site which the API lists meeting archive summaries from. If not specified,
            the API lists meeting archive summaries for recordings from the user's preferred site. All available Webex
            sites and the preferred site of the user can be retrieved by Get Site List API.
        :type site_url: str

        documentation: https://developer.webex.com/docs/api/v1/recording-report/list-meeting-archive-summaries
        """
        if from_ is not None:
            params['from'] = from_
        if to_ is not None:
            params['to'] = to_
        if site_url is not None:
            params['siteUrl'] = site_url
        url = self.ep('meetingArchiveSummaries')
        return self.session.follow_pagination(url=url, model=RecordingAchriveSummaryObject, params=params)

    def meeting_archive_details(self, archive_id: str) -> GetMeetingArchiveDetailsResponse:
        """
        Retrieves details for a meeting archive report with a specified archive ID, which contains recording metadata.
        Meeting archive details are only available to full administrators, not even the meeting host.

        :param archive_id: A unique identifier for the meeting archive summary.
        :type archive_id: str

        documentation: https://developer.webex.com/docs/api/v1/recording-report/get-meeting-archive-details
        """
        url = self.ep(f'meetingArchives/{archive_id}')
        data = super().get(url=url)
        return GetMeetingArchiveDetailsResponse.parse_obj(data)

class Format(str, Enum):
    #: Recording file format is MP4.
    mp4 = 'MP4'
    #: Recording file format is ARF, a private format of Webex recordings. This format requires the Cisco ARF recording
    #: player.
    arf = 'ARF'


class RecordingObject(ApiModel):
    #: A unique identifier for the recording.
    id: Optional[str]
    #: Unique identifier for the parent ended meeting instance which the recording belongs to.
    meeting_id: Optional[str]
    #: Unique identifier for the parent scheduled meeting which the recording belongs to.
    scheduled_meeting_id: Optional[str]
    #: Unique identifier for the parent meeting series which the recording belongs to.
    meeting_series_id: Optional[str]
    #: The recording's topic.
    topic: Optional[str]
    #: The date and time recording was created in ISO 8601 compliant format. Please note that it's not the time the
    #: record button was clicked in meeting but the time the recording file was generated offline.
    create_time: Optional[str]
    #: The date and time recording started in ISO 8601 compliant format. It indicates when the record button was
    #: clicked in the meeting.
    time_recorded: Optional[str]
    #: Site URL for the recording.
    site_url: Optional[str]
    #: The download link for recording. This attribute is not available if Prevent downloading has been turned on for
    #: the recording being requested. The Prevent downloading option can be viewed and set by a site admin on Control
    #: Hub.
    download_url: Optional[str]
    #: The playback link for recording.
    playback_url: Optional[str]
    #: The recording's password.
    password: Optional[str]
    format: Optional[Format]
    service_type: Optional[ServiceType]
    #: The duration of the recording, in seconds.
    duration_seconds: Optional[int]
    #: The size of the recording file, in bytes.
    size_bytes: Optional[int]
    #: Whether or not the recording has been shared to the current user.
    share_to_me: Optional[bool]
    #: External keys of the parent meeting created by an integration application. They could be Zendesk ticket IDs,
    #: Jira IDs, Salesforce Opportunity IDs, etc. The integration application queries recordings by a key in its own
    #: domain.
    integration_tags: Optional[list[str]]
    status: Optional[Status7]


class TemporaryDirectDownloadLinks(ApiModel):
    #: The download link for recording MP4 file without HTML page rendering in browser or HTTP redirect. Expires 3
    #: hours after the API request.
    recording_download_link: Optional[str]
    #: The download link for recording audio file without HTML page rendering in browser or HTTP redirect. This
    #: attribute is not available if Prevent Downloading has been turned on for the recording being requested. Expires
    #: 3 hours after the API request.
    audio_download_link: Optional[str]
    #: The download link for recording transcript file without HTML page rendering in browser or HTTP redirect. This
    #: attribute is not available if Prevent Downloading has been turned on for the recording being requested. Expires
    #: 3 hours after the API request.
    transcript_download_link: Optional[str]
    #: The date and time when recordingDownloadLink, audioDownloadLink, and transcriptDownloadLink expire in ISO 8601
    #: compliant format.
    expiration: Optional[str]


class MoveRecordingsIntoRecycleBinBody(ApiModel):
    #: Recording IDs for removing recordings into the recycle bin in batch. Please note that all the recording IDs
    #: should belong to the site of siteUrl or the user's preferred site if siteUrl is not specified.
    recording_ids: Optional[list[str]]
    #: URL of the Webex site from which the API deletes recordings. If not specified, the API deletes recordings from
    #: the user's preferred site. All available Webex sites and preferred sites of a user can be retrieved by the Get
    #: Site List API.
    site_url: Optional[str]


class ListRecordingsResponse(ApiModel):
    #: An array of recording objects.
    items: Optional[list[RecordingObject]]


class ListRecordingsForAdminOrComplianceOfficerResponse(ApiModel):
    #: An array of recording objects.
    items: Optional[list[RecordingObject]]


class GetRecordingDetailsResponse(RecordingObject):
    #: The download links for MP4, audio, and transcript of the recording without HTML page rendering in browser or
    #: HTTP redirect. This attribute is not available if the user is not a Compliance Officer and Prevent Downloading
    #: has been turned on for the recording being requested. The Prevent Downloading option can be viewed and set on
    #: page when editing a recording. Note that there are various products in Webex Suite such as "Webex Meetings",
    #: "Webex Training" and "Webex Events". Currently, this attribute is only available for Webex Meetings.
    temporary_direct_download_links: Optional[TemporaryDirectDownloadLinks]


class RestoreRecordingsFromRecycleBinBody(MoveRecordingsIntoRecycleBinBody):
    #: If not specified or false, restores the recordings specified by recordingIds. If true, restores all recordings
    #: from the recycle bin.
    restore_all: Optional[bool]


class PurgeRecordingsFromRecycleBinBody(MoveRecordingsIntoRecycleBinBody):
    #: If not specified or false, purges the recordings specified by recordingIds. If true, purges all recordings from
    #: the recycle bin.
    purge_all: Optional[bool]


class RecordingsApi(ApiChild, base=''):
    """
    Recordings are meeting content captured in a meeting or files uploaded via the upload page for your Webex site.
    This API manages recordings. Recordings may be retrieved via download or playback links defined by downloadUrl or
    playbackUrl in the response body.
    When the recording function is paused in the meeting the recording will not contain the pause. If the recording
    function is stopped and restarted in the meeting, several recordings will be created. These recordings will be
    consolidate and available all at once.
    Refer to the Meetings API Scopes for the specific scopes required for each API.
    """

    def list(self, from_: str = None, to_: str = None, meeting_id: str = None, host_email: str = None, site_url: str = None, integration_tag: str = None, topic: str = None, format: str = None, service_type: str = None, status: str = None, **params) -> Generator[RecordingObject, None, None]:
        """
        Lists recordings. You can specify a date range, a parent meeting ID, and the maximum number of recordings to
        return.
        Only recordings of meetings hosted by or shared with the authenticated user will be listed.
        The list returned is sorted in descending order by the date and time that the recordings were created.
        Long result sets are split into pages.

        :param from_: Starting date and time (inclusive) for recordings to return, in any ISO 8601 compliant format.
            from cannot be after to.
        :type from_: str
        :param to_: Ending date and time (exclusive) for List recordings to return, in any ISO 8601 compliant format.
            to cannot be before from.
        :type to_: str
        :param meeting_id: Unique identifier for the parent meeting series, scheduled meeting, or meeting instance for
            which recordings are being requested. If a meeting series ID is specified, the operation returns an array
            of recordings for the specified meeting series. If a scheduled meeting ID is specified, the operation
            returns an array of recordings for the specified scheduled meeting. If a meeting instance ID is specified,
            the operation returns an array of recordings for the specified meeting instance. If no ID is specified, the
            operation returns an array of recordings for all meetings of the current user. When meetingId is specified,
            the siteUrl parameter is ignored.
        :type meeting_id: str
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the required admin-level meeting scopes. If set, the admin may specify the email of a
            user in a site they manage and the API will return recordings of that user.
        :type host_email: str
        :param site_url: URL of the Webex site from which the API lists recordings. If not specified, the API lists
            recordings from all of a user's sites. All available Webex sites and the preferred site of the user can be
            retrieved by the Get Site List API.
        :type site_url: str
        :param integration_tag: External key of the parent meeting created by an integration application. This
            parameter is used by the integration application to query recordings by a key in its own domain, such as a
            Zendesk ticket ID, a Jira ID, a Salesforce Opportunity ID, etc.
        :type integration_tag: str
        :param topic: Recording's topic. If specified, the API filters recordings by topic in a case-insensitive
            manner.
        :type topic: str
        :param format: Recording's file format. If specified, the API filters recordings by format. Valid values are
            MP4 or ARF.
        :type format: str
        :param service_type: Recording's service-type. If this item is specified, the API filters recordings by
            service-type. Valid values: * MeetingCenter * EventCenter * SupportCenter * TrainingCenter
        :type service_type: str
        :param status: Recording's status. If not specified or available, retrieves recordings that are available.
            Otherwise, if specified as deleted, retrieves recordings that have been moved into the recycle bin.
            Possible values: available, deleted
        :type status: str

        documentation: https://developer.webex.com/docs/api/v1/recordings/list-recordings
        """
        if from_ is not None:
            params['from'] = from_
        if to_ is not None:
            params['to'] = to_
        if meeting_id is not None:
            params['meetingId'] = meeting_id
        if host_email is not None:
            params['hostEmail'] = host_email
        if site_url is not None:
            params['siteUrl'] = site_url
        if integration_tag is not None:
            params['integrationTag'] = integration_tag
        if topic is not None:
            params['topic'] = topic
        if format is not None:
            params['format'] = format
        if service_type is not None:
            params['serviceType'] = service_type
        if status is not None:
            params['status'] = status
        url = self.ep('recordings')
        return self.session.follow_pagination(url=url, model=RecordingObject, params=params)

    def list_for_admin_or_compliance_officer(self, from_: str = None, to_: str = None, meeting_id: str = None, site_url: str = None, integration_tag: str = None, topic: str = None, format: str = None, service_type: str = None, status: str = None, **params) -> Generator[RecordingObject, None, None]:
        """
        List recordings for an admin or compliance officer. You can specify a date range, a parent meeting ID, and the
        maximum number of recordings to return.
        The list returned is sorted in descending order by the date and time that the recordings were created.
        Long result sets are split into pages.

        :param from_: Starting date and time (inclusive) for recordings to return, in any ISO 8601 compliant format.
            from cannot be after to. The interval between from and to must be within 30 days.
        :type from_: str
        :param to_: Ending date and time (exclusive) for List recordings to return, in any ISO 8601 compliant format.
            to cannot be before from. The interval between from and to must be within 30 days.
        :type to_: str
        :param meeting_id: Unique identifier for the parent meeting series, scheduled meeting, or meeting instance for
            which recordings are being requested. If a meeting series ID is specified, the operation returns an array
            of recordings for the specified meeting series. If a scheduled meeting ID is specified, the operation
            returns an array of recordings for the specified scheduled meeting. If a meeting instance ID is specified,
            the operation returns an array of recordings for the specified meeting instance. If not specified, the
            operation returns an array of recordings for all the current user's meetings. When meetingId is specified,
            the siteUrl parameter is ignored.
        :type meeting_id: str
        :param site_url: URL of the Webex site which the API lists recordings from. If not specified, the API lists
            recordings from user's preferred site. All available Webex sites and preferred site of the user can be
            retrieved by Get Site List API.
        :type site_url: str
        :param integration_tag: External key of the parent meeting created by an integration application. This
            parameter is used by the integration application to query recordings by a key in its own domain such as a
            Zendesk ticket ID, a Jira ID, a Salesforce Opportunity ID, etc.
        :type integration_tag: str
        :param topic: Recording topic. If specified, the API filters recordings by topic in a case-insensitive manner.
        :type topic: str
        :param format: Recording's file format. If specified, the API filters recordings by format. Valid values: MP4
            or ARF.
        :type format: str
        :param service_type: Recording's service-type. If specified, the API filters recordings by service-type. Valid
            values: * MeetingCenter * EventCenter * SupportCenter * TrainingCenter
        :type service_type: str
        :param status: Recording's status. If not specified or available, retrieves recordings that are available.
            Otherwise, if specified as deleted, retrieves recordings that have been moved to the recycle bin. Possible
            values: available, deleted
        :type status: str

        documentation: https://developer.webex.com/docs/api/v1/recordings/list-recordings-for-an-admin-or-compliance-officer
        """
        if from_ is not None:
            params['from'] = from_
        if to_ is not None:
            params['to'] = to_
        if meeting_id is not None:
            params['meetingId'] = meeting_id
        if site_url is not None:
            params['siteUrl'] = site_url
        if integration_tag is not None:
            params['integrationTag'] = integration_tag
        if topic is not None:
            params['topic'] = topic
        if format is not None:
            params['format'] = format
        if service_type is not None:
            params['serviceType'] = service_type
        if status is not None:
            params['status'] = status
        url = self.ep('admin/recordings')
        return self.session.follow_pagination(url=url, model=RecordingObject, params=params)

    def recording_details(self, recording_id: str, host_email: str = None) -> GetRecordingDetailsResponse:
        """
        Retrieves details for a recording with a specified recording ID.
        Only recordings of meetings hosted by or shared with the authenticated user may be retrieved.

        :param recording_id: A unique identifier for the recording.
        :type recording_id: str
        :param host_email: Email address for the meeting host. Only used if the user or application calling the API has
            required admin-level meeting scopes. If set, the admin may specify the email of a user in a site they
            manage, and the API will return recording details of that user.
        :type host_email: str

        documentation: https://developer.webex.com/docs/api/v1/recordings/get-recording-details
        """
        params = {}
        if host_email is not None:
            params['hostEmail'] = host_email
        url = self.ep(f'recordings/{recording_id}')
        data = super().get(url=url, params=params)
        return GetRecordingDetailsResponse.parse_obj(data)

    def delete_recording(self, recording_id: str, host_email: str = None, reason: str = None, comment: str = None):
        """
        Removes a recording with a specified recording ID. The deleted recording cannot be recovered. If a Compliance
        Officer deletes another user's recording, the recording will be inaccessible to regular users (host, attendees
        and shared), but will be still available to the Compliance Officer.
        Only recordings of meetings hosted by the authenticated user can be deleted.

        :param recording_id: A unique identifier for the recording.
        :type recording_id: str
        :param host_email: Email address for the meeting host. Only used if the user or application calling the API has
            the required admin-level meeting scopes. If set, the admin may specify the email of a user in a site they
            manage and the API will delete a recording of that user.
        :type host_email: str
        :param reason: Reason for deleting a transcript. Only required when a Compliance Officer is operating on
            another user's transcript.
        :type reason: str
        :param comment: Explanation for deleting a transcript. The comment can be a maximum of 255 characters long.
        :type comment: str

        documentation: https://developer.webex.com/docs/api/v1/recordings/delete-a-recording
        """
        params = {}
        if host_email is not None:
            params['hostEmail'] = host_email
        body = DeleteTranscriptBody()
        if reason is not None:
            body.reason = reason
        if comment is not None:
            body.comment = comment
        url = self.ep(f'recordings/{recording_id}')
        super().delete(url=url, params=params, data=body.json())
        return

    def move_into_recycle_bin(self, recording_ids: List[str], host_email: str = None, site_url: str = None):
        """
        Move recordings into the recycle bin with recording IDs. Recordings in the recycle bin can be recovered by
        Restore Recordings from Recycle Bin API. If you'd like to empty recordings from the recycle bin, you can use
        Purge Recordings from Recycle Bin API to purge all or some of them.
        Only recordings of meetings hosted by the authenticated user can be moved into the recycle bin.

        :param recording_ids: Recording IDs for removing recordings into the recycle bin in batch. Please note that all
            the recording IDs should belong to the site of siteUrl or the user's preferred site if siteUrl is not
            specified.
        :type recording_ids: List[str]
        :param host_email: Email address for the meeting host. Only used if the user or application calling the API has
            the required admin-level meeting scopes. If set, the admin may specify the email of a user in a site they
            manage and the API will move recordings into recycle bin of that user
        :type host_email: str
        :param site_url: URL of the Webex site from which the API deletes recordings. If not specified, the API deletes
            recordings from the user's preferred site. All available Webex sites and preferred sites of a user can be
            retrieved by the Get Site List API.
        :type site_url: str

        documentation: https://developer.webex.com/docs/api/v1/recordings/move-recordings-into-the-recycle-bin
        """
        params = {}
        if host_email is not None:
            params['hostEmail'] = host_email
        body = MoveRecordingsIntoRecycleBinBody()
        if recording_ids is not None:
            body.recording_ids = recording_ids
        if site_url is not None:
            body.site_url = site_url
        url = self.ep('recordings/softDelete')
        super().post(url=url, params=params, data=body.json())
        return

    def restore_from_recycle_bin(self, recording_ids: List[str], host_email: str = None, site_url: str = None, restore_all: bool = None):
        """
        Restore all or some recordings from the recycle bin. Only recordings of meetings hosted by the authenticated
        user can be restored from recycle bin.

        :param recording_ids: Recording IDs for removing recordings into the recycle bin in batch. Please note that all
            the recording IDs should belong to the site of siteUrl or the user's preferred site if siteUrl is not
            specified.
        :type recording_ids: List[str]
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the required admin-level meeting scopes. If set, the admin may specify the email of a
            user in a site they manage and the API will restore recordings of that user.
        :type host_email: str
        :param site_url: URL of the Webex site from which the API deletes recordings. If not specified, the API deletes
            recordings from the user's preferred site. All available Webex sites and preferred sites of a user can be
            retrieved by the Get Site List API.
        :type site_url: str
        :param restore_all: If not specified or false, restores the recordings specified by recordingIds. If true,
            restores all recordings from the recycle bin.
        :type restore_all: bool

        documentation: https://developer.webex.com/docs/api/v1/recordings/restore-recordings-from-recycle-bin
        """
        params = {}
        if host_email is not None:
            params['hostEmail'] = host_email
        body = RestoreRecordingsFromRecycleBinBody()
        if recording_ids is not None:
            body.recording_ids = recording_ids
        if site_url is not None:
            body.site_url = site_url
        if restore_all is not None:
            body.restore_all = restore_all
        url = self.ep('recordings/restore')
        super().post(url=url, params=params, data=body.json())
        return

    def purge_from_recycle_bin(self, recording_ids: List[str], host_email: str = None, site_url: str = None, purge_all: bool = None):
        """
        Purge recordings from recycle bin with recording IDs or purge all the recordings that are in the recycle bin.
        Only recordings of meetings hosted by the authenticated user can be purged from recycle bin.

        :param recording_ids: Recording IDs for removing recordings into the recycle bin in batch. Please note that all
            the recording IDs should belong to the site of siteUrl or the user's preferred site if siteUrl is not
            specified.
        :type recording_ids: List[str]
        :param host_email: Email address for the meeting host. Only used if the user or application calling the API has
            the required admin-level meeting scopes. If set, the admin may specify the email of a user in a site they
            manage and the API will purge recordings from recycle bin of that user.
        :type host_email: str
        :param site_url: URL of the Webex site from which the API deletes recordings. If not specified, the API deletes
            recordings from the user's preferred site. All available Webex sites and preferred sites of a user can be
            retrieved by the Get Site List API.
        :type site_url: str
        :param purge_all: If not specified or false, purges the recordings specified by recordingIds. If true, purges
            all recordings from the recycle bin.
        :type purge_all: bool

        documentation: https://developer.webex.com/docs/api/v1/recordings/purge-recordings-from-recycle-bin
        """
        params = {}
        if host_email is not None:
            params['hostEmail'] = host_email
        body = PurgeRecordingsFromRecycleBinBody()
        if recording_ids is not None:
            body.recording_ids = recording_ids
        if site_url is not None:
            body.site_url = site_url
        if purge_all is not None:
            body.purge_all = purge_all
        url = self.ep('recordings/purge')
        super().post(url=url, params=params, data=body.json())
        return

class ValidationRules(ApiModel):
    #: Field on which validation rule is applied
    field: Optional[str]
    #: Whether the above field is required
    required: Optional[str]


class ValidationRulesCollection(ApiModel):
    #: An array of validation rules
    validations: Optional[list[ValidationRules]]


class Template(ApiModel):
    #: Unique identifier representing a report.
    id: Optional[str]
    #: Name of the template.
    title: Optional[str]
    #: The service to which the report belongs.
    service: Optional[str]
    #: Maximum date range for reports belonging to this template.
    max_days: Optional[int]
    #: Generated reports belong to which field.
    identifier: Optional[str]
    validations: Optional[ValidationRulesCollection]


class ListReportTemplatesResponse(ApiModel):
    #: An array of template object
    template_attributes: Optional[list[Template]] = Field(alias='Template Attributes')


class ReportTemplatesApi(ApiChild, base='report/templates'):
    """
    Report templates are available for use with the Reports API.
    To access this endpoint, you must use an administrator token with the analytics:read_all scope. The authenticated
    user must be a read-only or full administrator of the organization to which the report belongs.
    To use this endpoint the organization needs to be licensed for Pro Pack for Control Hub.
    For more information about Report Templates, see the Admin API guide.
    """

    def list_report_templates(self) -> list[Template]:
        """
        List all the available report templates that can be generated.
        CSV (comma separated value) reports for Webex services are only supported for organizations based in the North
        American region. Organizations based in other regions will return blank CSV files for any Webex reports.

        documentation: https://developer.webex.com/docs/api/v1/report-templates/list-report-templates
        """
        url = self.ep()
        data = super().get(url=url)
        return parse_obj_as(list[Template], data["Template Attributes"])

class Report(ApiModel):
    #: Unique identifier for the report.
    id: Optional[str]
    #: Name of the template to which this report belongs.
    title: Optional[str]
    #: The service to which the report belongs.
    service: Optional[str]
    #: The data in this report belongs to dates greater than or equal to this.
    start_date: Optional[str]
    #: The data in this report belongs to dates smaller than or equal to this.
    end_date: Optional[str]
    #: The site to which this report belongs to. This only exists if the report belongs to service Webex.
    site_list: Optional[str]
    #: Time of creation for this report.
    created: Optional[str]
    #: The person who created the report.
    created_by: Optional[str]
    #: Whether this report was scheduled from API or Control Hub.
    scheduled_from: Optional[str]
    #: Completion status of this report.
    status: Optional[str]
    #: The link from which the report can be downloaded.
    download_url: Optional[str]


class ListReportsResponse(ApiModel):
    #: An array of report objects.
    report_attributes: Optional[list[Report]] = Field(alias='Report Attributes')


class CreateReportBody(ApiModel):
    #: Unique ID representing valid report templates.
    template_id: Optional[int]
    #: Data in the report will be from this date onwards.
    start_date: Optional[str]
    #: Data in the report will be until this date.
    end_date: Optional[str]
    #: Sites belonging to user's organization. This attribute is needed for site-based templates.
    site_list: Optional[str]


class CreateReportResponse(ApiModel):
    #: The unique identifier for the report.
    id: Optional[str]


class ReportsApi(ApiChild, base='reports'):
    """
    To access these endpoints, you must use an administrator token with the analytics:read_all scope. The authenticated
    user must be a read-only or full administrator of the organization to which the report belongs.
    To use this endpoint the org needs to be licensed for the Pro Pack.
    Reports available via Webex Control Hub may be generated and downloaded via the Reports API. To access this API,
    the authenticated user must be a read-only or full administrator of the organization to which the report belongs.
    For more information about Reports, see the Admin API guide.
    """

    def list(self, report_id: str = None, service: str = None, template_id: int = None, from_: str = None, to_: str = None) -> list[Report]:
        """
        Lists all reports. Use query parameters to filter the response. The parameters are optional. However, from and
        to parameters should be provided together.
        CSV reports for Teams services are only supported for organizations based in the North American region.
        Organizations based in a different region will return blank CSV files for any Teams reports.

        :param report_id: List reports by ID.
        :type report_id: str
        :param service: List reports which use this service.
        :type service: str
        :param template_id: List reports with this report template ID.
        :type template_id: int
        :param from_: List reports that were created on or after this date.
        :type from_: str
        :param to_: List reports that were created before this date.
        :type to_: str

        documentation: https://developer.webex.com/docs/api/v1/reports/list-reports
        """
        params = {}
        if report_id is not None:
            params['reportId'] = report_id
        if service is not None:
            params['service'] = service
        if template_id is not None:
            params['templateId'] = template_id
        if from_ is not None:
            params['from'] = from_
        if to_ is not None:
            params['to'] = to_
        url = self.ep()
        data = super().get(url=url, params=params)
        return parse_obj_as(list[Report], data["Report Attributes"])

    def create(self, template_id: int, start_date: str = None, end_date: str = None, site_list: str = None) -> str:
        """
        Create a new report. For each templateId, there are a set of validation rules that need to be followed. For
        example, for templates belonging to Webex, the user needs to provide siteUrl. These validation rules can be
        retrieved via the Report Templates API.
        The 'templateId' parameter is a number. However, it is a limitation of developer.webex.com platform that it is
        passed as a string when you try to test the API from here.
        CSV reports for Teams services are only supported for organizations based in the North American region.
        Organizations based in a different region will return blank CSV files for any Teams reports.

        :param template_id: Unique ID representing valid report templates.
        :type template_id: int
        :param start_date: Data in the report will be from this date onwards.
        :type start_date: str
        :param end_date: Data in the report will be until this date.
        :type end_date: str
        :param site_list: Sites belonging to user's organization. This attribute is needed for site-based templates.
        :type site_list: str

        documentation: https://developer.webex.com/docs/api/v1/reports/create-a-report
        """
        body = CreateReportBody()
        if template_id is not None:
            body.template_id = template_id
        if start_date is not None:
            body.start_date = start_date
        if end_date is not None:
            body.end_date = end_date
        if site_list is not None:
            body.site_list = site_list
        url = self.ep()
        data = super().post(url=url, data=body.json())
        return data["id"]

    def details(self, report_id: str) -> Report:
        """
        Shows details for a report, by report ID.
        Specify the report ID in the reportId parameter in the URI.
        CSV reports for Teams services are only supported for organizations based in the North American region.
        Organizations based in a different region will return blank CSV files for any Teams reports.

        :param report_id: The unique identifier for the report.
        :type report_id: str

        documentation: https://developer.webex.com/docs/api/v1/reports/get-report-details
        """
        url = self.ep(f'{report_id}')
        data = super().get(url=url)
        return Report.parse_obj(data)

    def delete(self, report_id: str):
        """
        Remove a report from the system.
        Specify the report ID in the reportId parameter in the URI
        CSV reports for Teams services are only supported for organizations based in the North American region.
        Organizations based in a different region will return blank CSV files for any Teams reports.

        :param report_id: The unique identifier for the report.
        :type report_id: str

        documentation: https://developer.webex.com/docs/api/v1/reports/delete-a-report
        """
        url = self.ep(f'{report_id}')
        super().delete(url=url)
        return

class Status23(str, Enum):
    #: activation pending
    pending = 'pending'
    #: activated
    activated = 'activated'
    #: error present
    error = 'error'


class UpdateResourceGroupMembershipBody(ApiModel):
    #: The resource group ID.
    resource_group_id: Optional[str]
    #: The license ID.
    license_id: Optional[str]
    #: The person ID.
    person_id: Optional[str]
    #: The organization ID of the person.
    person_org_id: Optional[str]
    #: The activation status of the resource group membership.
    status: Optional[Status23]


class ResourceGroupMembership(UpdateResourceGroupMembershipBody):
    #: A unique identifier for the resource group membership.
    id: Optional[str]


class ListResourceGroupMembershipsResponse(ApiModel):
    items: Optional[list[ResourceGroupMembership]]


class ResourceGroupMembershipsApi(ApiChild, base='resourceGroup/memberships'):
    """
    Resource Group Memberships represent a person's relationship to a Resource Group for a particular Hybrid Services
    license. Users assigned a new license will be automatically placed in a "default" Resource Group. Use this API to
    list memberships for all people in an organization or update memberships to use a different Resource Group.
    Searching and viewing Resource Group Memberships requires an administrator auth token with the
    spark-admin:resource_group_memberships_read scope. Updating memberships requires an administrator auth token with
    the spark-admin:resource_group_memberships_write scope.
    To manage Resource Groups, see the Resource Groups API. For more information about Resource Groups, see the
    Managing Hybrid Services guide.
    """

    def list_group_memberships(self, license_id: str = None, person_id: str = None, person_org_id: str = None, status: enum = None, **params) -> Generator[ResourceGroupMembership, None, None]:
        """
        Lists all resource group memberships for an organization.
        Use query parameters to filter the response.

        :param license_id: List resource group memberships for a license, by ID.
        :type license_id: str
        :param person_id: List resource group memberships for a person, by ID.
        :type person_id: str
        :param person_org_id: List resource group memberships for an organization, by ID.
        :type person_org_id: str
        :param status: Limit resource group memberships to a specific status.
        :type status: enum

        documentation: https://developer.webex.com/docs/api/v1/resource-group-memberships/list-resource-group-memberships
        """
        if license_id is not None:
            params['licenseId'] = license_id
        if person_id is not None:
            params['personId'] = person_id
        if person_org_id is not None:
            params['personOrgId'] = person_org_id
        if status is not None:
            params['status'] = status
        url = self.ep()
        return self.session.follow_pagination(url=url, model=ResourceGroupMembership, params=params)

    def group_membership_details(self, resource_group_membership_id: str) -> ResourceGroupMembership:
        """
        Shows details for a resource group membership, by ID.
        Specify the resource group membership ID in the resourceGroupMembershipId URI parameter.

        :param resource_group_membership_id: The unique identifier for the resource group membership.
        :type resource_group_membership_id: str

        documentation: https://developer.webex.com/docs/api/v1/resource-group-memberships/get-resource-group-membership-details
        """
        url = self.ep(f'{resource_group_membership_id}')
        data = super().get(url=url)
        return ResourceGroupMembership.parse_obj(data)

    def update_group_membership(self, resource_group_membership_id: str, resource_group_id: str, license_id: str, person_id: str, person_org_id: str, status: Status23) -> ResourceGroupMembership:
        """
        Updates a resource group membership, by ID.
        Specify the resource group membership ID in the resourceGroupMembershipId URI parameter.
        Only the resourceGroupId can be changed with this action. Resource group memberships with a status of "pending"
        cannot be updated. For more information about resource group memberships, see the Managing Hybrid Services
        guide.

        :param resource_group_membership_id: The unique identifier for the resource group membership.
        :type resource_group_membership_id: str
        :param resource_group_id: The resource group ID.
        :type resource_group_id: str
        :param license_id: The license ID.
        :type license_id: str
        :param person_id: The person ID.
        :type person_id: str
        :param person_org_id: The organization ID of the person.
        :type person_org_id: str
        :param status: The activation status of the resource group membership.
        :type status: Status23

        documentation: https://developer.webex.com/docs/api/v1/resource-group-memberships/update-a-resource-group-membership
        """
        body = UpdateResourceGroupMembershipBody()
        if resource_group_id is not None:
            body.resource_group_id = resource_group_id
        if license_id is not None:
            body.license_id = license_id
        if person_id is not None:
            body.person_id = person_id
        if person_org_id is not None:
            body.person_org_id = person_org_id
        if status is not None:
            body.status = status
        url = self.ep(f'{resource_group_membership_id}')
        data = super().put(url=url, data=body.json())
        return ResourceGroupMembership.parse_obj(data)

class ResourceGroup(Role):
    #: The ID of the organization to which this resource group belongs.
    org_id: Optional[str]


class ListResourceGroupsResponse(ApiModel):
    items: Optional[list[ResourceGroup]]


class ResourceGroupsApi(ApiChild, base='resourceGroups'):
    """
    Resource Groups are collections of on-premise clusters which provide Hybrid Services to a particular subset of
    people in an organization. If a person has a Hybrid Services license associated with their account, they will be
    associated with a resource group to use specific on-premise clusters for that service.
    Searching and viewing Resource Groups requires an administrator auth token with a scope of
    spark-admin:resource_groups_read.
    To manage the people associated with Resource Groups, see the Resource Group Memberships API. For more information
    about Resource Groups, see the Managing Hybrid Services guide.
    """

    def list_groups(self, org_id: str = None) -> list[ResourceGroup]:
        """
        List resource groups.
        Use query parameters to filter the response.

        :param org_id: List resource groups in this organization. Only admin users of another organization (such as
            partners) may use this parameter.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/resource-groups/list-resource-groups
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep()
        data = super().get(url=url, params=params)
        return parse_obj_as(list[ResourceGroup], data["items"])

    def group_details(self, resource_group_id: str) -> ResourceGroup:
        """
        Shows details for a resource group, by ID.
        Specify the resource group ID in the resourceGroupId parameter in the URI.

        :param resource_group_id: The unique identifier for the resource group.
        :type resource_group_id: str

        documentation: https://developer.webex.com/docs/api/v1/resource-groups/get-resource-group-details
        """
        url = self.ep(f'{resource_group_id}')
        data = super().get(url=url)
        return ResourceGroup.parse_obj(data)

class ListRolesResponse(ApiModel):
    items: Optional[list[Role]]


class RolesApi(ApiChild, base='roles'):
    """
    A persona for an authenticated user, corresponding to a set of privileges within an organization. This roles
    resource can be accessed only by an admin and shows only roles relevant to an admin.
    """

    def list_roles(self) -> list[Role]:
        """
        List all roles.

        documentation: https://developer.webex.com/docs/api/v1/roles/list-roles
        """
        url = self.ep()
        data = super().get(url=url)
        return parse_obj_as(list[Role], data["items"])

    def role_details(self, role_id: str) -> Role:
        """
        Shows details for a role, by ID.
        Specify the role ID in the roleId parameter in the URI.

        :param role_id: The unique identifier for the role.
        :type role_id: str

        documentation: https://developer.webex.com/docs/api/v1/roles/get-role-details
        """
        url = self.ep(f'{role_id}')
        data = super().get(url=url)
        return Role.parse_obj(data)

class RoomTab(Organization):
    #: A unique identifier for the room containing the room tab.
    room_id: Optional[str]
    #: The room type.
    room_type: Optional[RoomType]
    #: Room Tab's content URL.
    content_url: Optional[str]
    #: The person ID of the person who created this Room Tab.
    creator_id: Optional[str]


class CreateRoomTabBody(ApiModel):
    #: A unique identifier for the room.
    room_id: Optional[str]
    #: URL of the Room Tab. Must use https protocol.
    content_url: Optional[str]
    #: User-friendly name for the room tab.
    display_name: Optional[str]


class ListRoomTabsResponse(ApiModel):
    items: Optional[list[RoomTab]]


class RoomTabsApi(ApiChild, base='room/tabs'):
    """
    A Room Tab represents a URL shortcut that is added as a persistent tab to a Webex room (space) tab row. Use this
    API to list tabs of any Webex room that you belong to. Room Tabs can also be updated to point to a different
    content URL, or deleted to remove the tab from the room.
    Just like in the Webex app, you must be a member of the room in order to list its Room Tabs.
    """

    def list_tabs(self, room_id: str) -> list[RoomTab]:
        """
        Lists all Room Tabs of a room specified by the roomId query parameter.

        :param room_id: ID of the room for which to list room tabs.
        :type room_id: str

        documentation: https://developer.webex.com/docs/api/v1/room-tabs/list-room-tabs
        """
        params = {}
        params['roomId'] = room_id
        url = self.ep()
        data = super().get(url=url, params=params)
        return parse_obj_as(list[RoomTab], data["items"])

    def create_tab(self, room_id: str, content_url: str, display_name: str) -> RoomTab:
        """
        Add a tab with a specified URL to a room.

        :param room_id: A unique identifier for the room.
        :type room_id: str
        :param content_url: URL of the Room Tab. Must use https protocol.
        :type content_url: str
        :param display_name: User-friendly name for the room tab.
        :type display_name: str

        documentation: https://developer.webex.com/docs/api/v1/room-tabs/create-a-room-tab
        """
        body = CreateRoomTabBody()
        if room_id is not None:
            body.room_id = room_id
        if content_url is not None:
            body.content_url = content_url
        if display_name is not None:
            body.display_name = display_name
        url = self.ep()
        data = super().post(url=url, data=body.json())
        return RoomTab.parse_obj(data)

    def tab_details(self, id: str) -> RoomTab:
        """
        Get details for a Room Tab with the specified room tab ID.

        :param id: The unique identifier for the Room Tab.
        :type id: str

        documentation: https://developer.webex.com/docs/api/v1/room-tabs/get-room-tab-details
        """
        url = self.ep(f'{id}')
        data = super().get(url=url)
        return RoomTab.parse_obj(data)

    def update_tab(self, id: str, room_id: str, content_url: str, display_name: str) -> RoomTab:
        """
        Updates the content URL of the specified Room Tab ID.

        :param id: The unique identifier for the Room Tab.
        :type id: str
        :param room_id: A unique identifier for the room.
        :type room_id: str
        :param content_url: URL of the Room Tab. Must use https protocol.
        :type content_url: str
        :param display_name: User-friendly name for the room tab.
        :type display_name: str

        documentation: https://developer.webex.com/docs/api/v1/room-tabs/update-a-room-tab
        """
        body = CreateRoomTabBody()
        if room_id is not None:
            body.room_id = room_id
        if content_url is not None:
            body.content_url = content_url
        if display_name is not None:
            body.display_name = display_name
        url = self.ep(f'{id}')
        data = super().put(url=url, data=body.json())
        return RoomTab.parse_obj(data)

    def delete_tab(self, id: str):
        """
        Deletes a Room Tab with the specified ID.

        :param id: The unique identifier for the Room Tab to delete.
        :type id: str

        documentation: https://developer.webex.com/docs/api/v1/room-tabs/delete-a-room-tab
        """
        url = self.ep(f'{id}')
        super().delete(url=url)
        return

class CreateRoomBody(ApiModel):
    #: A user-friendly name for the room.
    title: Optional[str]
    #: The ID for the team with which this room is associated.
    team_id: Optional[str]
    #: The classificationId for the room.
    classification_id: Optional[str]
    #: Set the space as locked/moderated and the creator becomes a moderator
    is_locked: Optional[bool]
    #: The room is public and therefore discoverable within the org. Anyone can find and join that room. When true the
    #: description must be filled in.
    is_public: Optional[bool]
    #: The description of the space.
    description: Optional[str]
    #: Sets the space into announcement Mode.
    is_announcement_only: Optional[bool]


class Room(CreateRoomBody):
    #: A unique identifier for the room.
    id: Optional[str]
    #: The room type.
    type: Optional[RoomType]
    #: The date and time of the room's last activity.
    last_activity: Optional[str]
    #: The ID of the person who created this room.
    creator_id: Optional[str]
    #: The date and time the room was created.
    created: Optional[str]
    #: The ID of the organization which owns this room. See Webex Data in the Compliance Guide for more information.
    owner_id: Optional[str]
    #: A compliance officer can set a direct room as read-only, which will disallow any new information exchanges in
    #: this space, while maintaing historical data.
    is_read_only: Optional[bool]
    #: Date and time when the room was made public.
    made_public: Optional[str]


class ListRoomsResponse(ApiModel):
    items: Optional[list[Room]]


class GetRoomMeetingDetailsResponse(ApiModel):
    #: A unique identifier for the room.
    room_id: Optional[str]
    #: The Webex meeting URL for the room.
    meeting_link: Optional[str]
    #: The SIP address for the room.
    sip_address: Optional[str]
    #: The Webex meeting number for the room.
    meeting_number: Optional[str]
    #: The Webex meeting ID for the room.
    meeting_id: Optional[str]
    #: The toll-free PSTN number for the room.
    call_in_toll_free_number: Optional[str]
    #: The toll (local) PSTN number for the room.
    call_in_toll_number: Optional[str]


class UpdateRoomBody(CreateRoomBody):
    #: A compliance officer can set a direct room as read-only, which will disallow any new information exchanges in
    #: this space, while maintaing historical data.
    is_read_only: Optional[bool]


class RoomsApi(ApiChild, base='rooms'):
    """
    Rooms are virtual meeting places where people post messages and collaborate to get work done. This API is used to
    manage the rooms themselves. Rooms are created and deleted with this API. You can also update a room to change its
    title or make it public, for example.
    To create a team room, specify the a teamId in the POST payload. Note that once a room is added to a team, it
    cannot be moved. To learn more about managing teams, see the Teams API.
    To manage people in a room see the Memberships API.
    To post content see the Messages API.
    """

    def list(self, team_id: str = None, type_: str = None, org_public_spaces: bool = None, from_: str = None, to_: str = None, sort_by: str = None, **params) -> Generator[Room, None, None]:
        """
        List rooms.
        The title of the room for 1:1 rooms will be the display name of the other person. When a Compliance Officer
        lists 1:1 rooms, the "other" person cannot be determined. This means that the room's title may not be filled
        in. Please use the memberships API to list the people in the space.
        By default, lists rooms to which the authenticated user belongs.
        Long result sets will be split into pages.
        Known Limitations:
        The underlying database does not support natural sorting by lastactivity and will only sort on limited set of
        results, which are pulled from the database in order of roomId. For users or bots in more than 3000 spaces this
        can result in anomalies such as spaces that have had recent activity not being returned in the results when
        sorting by lastacivity.

        :param team_id: List rooms associated with a team, by ID. Cannot be set in combination with orgPublicSpaces.
        :type team_id: str
        :param type_: List rooms by type. Cannot be set in combination with orgPublicSpaces. Possible values: direct,
            group
        :type type_: str
        :param org_public_spaces: Shows the org's public spaces joined and unjoined. When set the result list is sorted
            by the madePublic timestamp.
        :type org_public_spaces: bool
        :param from_: Filters rooms, that were made public after this time. See madePublic timestamp
        :type from_: str
        :param to_: Filters rooms, that were made public before this time. See maePublic timestamp
        :type to_: str
        :param sort_by: Sort results. Cannot be set in combination with orgPublicSpaces. Possible values: id,
            lastactivity, created
        :type sort_by: str

        documentation: https://developer.webex.com/docs/api/v1/rooms/list-rooms
        """
        if team_id is not None:
            params['teamId'] = team_id
        if type_ is not None:
            params['type'] = type_
        if org_public_spaces is not None:
            params['orgPublicSpaces'] = str(org_public_spaces).lower()
        if from_ is not None:
            params['from'] = from_
        if to_ is not None:
            params['to'] = to_
        if sort_by is not None:
            params['sortBy'] = sort_by
        url = self.ep()
        return self.session.follow_pagination(url=url, model=Room, params=params)

    def create(self, title: str, team_id: str = None, classification_id: str = None, is_locked: bool = None, is_public: bool = None, description: str = None, is_announcement_only: bool = None) -> Room:
        """
        Creates a room. The authenticated user is automatically added as a member of the room. See the Memberships API
        to learn how to add more people to the room.
        To create a 1:1 room, use the Create Messages endpoint to send a message directly to another person by using
        the toPersonId or toPersonEmail parameters.
        Bots are not able to create and simultaneously classify a room. A bot may update a space classification after a
        person of the same owning organization joined the space as the first human user.
        A space can only be put into announcement mode when it is locked.

        :param title: A user-friendly name for the room.
        :type title: str
        :param team_id: The ID for the team with which this room is associated.
        :type team_id: str
        :param classification_id: The classificationId for the room.
        :type classification_id: str
        :param is_locked: Set the space as locked/moderated and the creator becomes a moderator
        :type is_locked: bool
        :param is_public: The room is public and therefore discoverable within the org. Anyone can find and join that
            room. When true the description must be filled in.
        :type is_public: bool
        :param description: The description of the space.
        :type description: str
        :param is_announcement_only: Sets the space into announcement Mode.
        :type is_announcement_only: bool

        documentation: https://developer.webex.com/docs/api/v1/rooms/create-a-room
        """
        body = CreateRoomBody()
        if title is not None:
            body.title = title
        if team_id is not None:
            body.team_id = team_id
        if classification_id is not None:
            body.classification_id = classification_id
        if is_locked is not None:
            body.is_locked = is_locked
        if is_public is not None:
            body.is_public = is_public
        if description is not None:
            body.description = description
        if is_announcement_only is not None:
            body.is_announcement_only = is_announcement_only
        url = self.ep()
        data = super().post(url=url, data=body.json())
        return Room.parse_obj(data)

    def details(self, room_id: str) -> Room:
        """
        Shows details for a room, by ID.
        The title of the room for 1:1 rooms will be the display name of the other person.
        Specify the room ID in the roomId parameter in the URI.

        :param room_id: The unique identifier for the room.
        :type room_id: str

        documentation: https://developer.webex.com/docs/api/v1/rooms/get-room-details
        """
        url = self.ep(f'{room_id}')
        data = super().get(url=url)
        return Room.parse_obj(data)

    def meeting_details(self, room_id: str) -> GetRoomMeetingDetailsResponse:
        """
        Shows Webex meeting details for a room such as the SIP address, meeting URL, toll-free and toll dial-in
        numbers.
        Specify the room ID in the roomId parameter in the URI.

        :param room_id: The unique identifier for the room.
        :type room_id: str

        documentation: https://developer.webex.com/docs/api/v1/rooms/get-room-meeting-details
        """
        url = self.ep(f'{room_id}/meetingInfo')
        data = super().get(url=url)
        return GetRoomMeetingDetailsResponse.parse_obj(data)

    def update(self, room_id: str, title: str, team_id: str = None, classification_id: str = None, is_locked: bool = None, is_public: bool = None, description: str = None, is_announcement_only: bool = None, is_read_only: bool = None) -> Room:
        """
        Updates details for a room, by ID.
        Specify the room ID in the roomId parameter in the URI.
        A space can only be put into announcement mode when it is locked.
        Any space participant or compliance officer can convert a space from public to private. Only a compliance
        officer can convert a space from private to public and only if the space is classified with the lowest category
        (usually public), and the space has a description.
        To remove a description please use a space character by itself.

        :param room_id: The unique identifier for the room.
        :type room_id: str
        :param title: A user-friendly name for the room.
        :type title: str
        :param team_id: The ID for the team with which this room is associated.
        :type team_id: str
        :param classification_id: The classificationId for the room.
        :type classification_id: str
        :param is_locked: Set the space as locked/moderated and the creator becomes a moderator
        :type is_locked: bool
        :param is_public: The room is public and therefore discoverable within the org. Anyone can find and join that
            room. When true the description must be filled in.
        :type is_public: bool
        :param description: The description of the space.
        :type description: str
        :param is_announcement_only: Sets the space into announcement Mode.
        :type is_announcement_only: bool
        :param is_read_only: A compliance officer can set a direct room as read-only, which will disallow any new
            information exchanges in this space, while maintaing historical data.
        :type is_read_only: bool

        documentation: https://developer.webex.com/docs/api/v1/rooms/update-a-room
        """
        body = UpdateRoomBody()
        if title is not None:
            body.title = title
        if team_id is not None:
            body.team_id = team_id
        if classification_id is not None:
            body.classification_id = classification_id
        if is_locked is not None:
            body.is_locked = is_locked
        if is_public is not None:
            body.is_public = is_public
        if description is not None:
            body.description = description
        if is_announcement_only is not None:
            body.is_announcement_only = is_announcement_only
        if is_read_only is not None:
            body.is_read_only = is_read_only
        url = self.ep(f'{room_id}')
        data = super().put(url=url, data=body.json())
        return Room.parse_obj(data)

    def delete(self, room_id: str):
        """
        Deletes a room, by ID. Deleted rooms cannot be recovered.
        As a security measure to prevent accidental deletion, when a non moderator deletes the room they are removed
        from the room instead.
        Deleting a room that is part of a team will archive the room instead.
        Specify the room ID in the roomId parameter in the URI.

        :param room_id: The unique identifier for the room.
        :type room_id: str

        documentation: https://developer.webex.com/docs/api/v1/rooms/delete-a-room
        """
        url = self.ep(f'{room_id}')
        super().delete(url=url)
        return

class ListSecurityAuditEventsResponse(ApiModel):
    #: array of monitoring Audit events
    items: Optional[list[AuditEvent]]


class SecurityAuditEventsApi(ApiChild, base='admin/securityAudit/events'):
    """
    List Security Audit Events. This API currently returns user sign-in and sign-out data.
    To call this API the audit:events_read scope must be selected for the Integration or Service App and auhtorized by
    a Full Admin.
    Several query parameters are available to filter the response.
    Long result sets will be split into multiple pages
    NOTE: A maximum of one year of audit events can be returned per request.
    """

    def list_security_audit_events(self, org_id: str, start_time: , end_time: , actor_id: str = None, event_categories: list = None, **params) -> Generator[AuditEvent, None, None]:
        """
        List Security Audit Events. This API currently returns user sign-in and sign-out data.
        To call this API the audit:events_read scope must be selected for the Integration or Service App and auhtorized
        by a Full Admin.
        Several query parameters are available to filter the response.
        Long result sets will be split into multiple pages
        NOTE: A maximum of one year of audit events can be returned per request.

        :param org_id: List events in this organization, by ID.
        :type org_id: str
        :param start_time: List events which occurred after a specific date and time.
        :type start_time: 
        :param end_time: List events which occurred before a specific date and time.
        :type end_time: 
        :param actor_id: List events performed by this person, by ID.
        :type actor_id: str
        :param event_categories: List events, by event categories.
        :type event_categories: list

        documentation: https://developer.webex.com/docs/api/v1/security-audit-events/list-security-audit-events
        """
        params['orgId'] = org_id
        params['startTime'] = start_time
        params['endTime'] = end_time
        if actor_id is not None:
            params['actorId'] = actor_id
        if event_categories is not None:
            params['eventCategories'] = event_categories
        url = self.ep()
        return self.session.follow_pagination(url=url, model=AuditEvent, params=params)

class SiteSessionType(ApiModel):
    #: Site URL for the session type.
    site_url: Optional[str]


class Type24(Type7):
    #: Event Center.
    event_center = 'EventCenter'
    #: Support Center.
    support_center = 'SupportCenter'
    #: Training Center.
    train_center = 'TrainCenter'


class SessionType(Role):
    #: The short name of the session type.
    short_name: Optional[str]
    #: The meeting type of meeting that you can create with the session type.
    type: Optional[Type24]


class UserSessionTypes(ApiModel):
    #: A unique identifier for the user.
    person_id: Optional[str]
    #: The email of the user.
    email: Optional[str]
    #: Site URL for the user.
    site_url: Optional[str]
    #: All session types are supported by the user on the site.
    session_types: Optional[list[SessionType]]


class ListSiteSessionTypesResponse(ApiModel):
    #: An array of the site's session types.
    items: Optional[list[SiteSessionType]]


class ListUserSessionTypeResponse(ApiModel):
    #: An array of the user's session types.
    items: Optional[list[UserSessionTypes]]


class UpdateUserSessionTypesBody(ApiModel):
    #: Site URL for the session type.
    site_url: Optional[str]
    #: A unique identifier for the user.
    person_id: Optional[str]
    #: The email of the user.
    email: Optional[str]
    #: An array of the session type ID.
    #: Possible values: 3, 9
    session_type_ids: Optional[list[str]]


class SessionTypesApi(ApiChild, base='admin/meeting/'):
    """
    Session types define the features and options that are available to users for scheduled meetings.
    The API allows getting site-level session types and modifying user-level session types.
    Viewing the list of site session types and user session types requires an administrator auth token with
    meeting:admin_schedule_read or meeting:admin_config_read. Updating user session types requires an administrator
    auth token with the meeting:admin_schedule_write or meeting:admin_config_write scope.
    """

    def list_site_types(self, site_url: str = None) -> list[SiteSessionType]:
        """
        List session types for a specific site.

        :param site_url: URL of the Webex site to query. If siteUrl is not specified, the query will use the default
            site for the admin's authorization token used to make the call.
        :type site_url: str

        documentation: https://developer.webex.com/docs/api/v1/session-types/list-site-session-types
        """
        params = {}
        if site_url is not None:
            params['siteUrl'] = site_url
        url = self.ep('config/sessionTypes')
        data = super().get(url=url, params=params)
        return parse_obj_as(list[SiteSessionType], data["items"])

    def list_user_type(self, site_url: str = None, person_id: str = None) -> list[UserSessionTypes]:
        """
        List session types for a specific user.

        :param site_url: URL of the Webex site to query.
        :type site_url: str
        :param person_id: A unique identifier for the user.
        :type person_id: str

        documentation: https://developer.webex.com/docs/api/v1/session-types/list-user-session-type
        """
        params = {}
        if site_url is not None:
            params['siteUrl'] = site_url
        if person_id is not None:
            params['personId'] = person_id
        url = self.ep('userconfig/sessionTypes')
        data = super().get(url=url, params=params)
        return parse_obj_as(list[UserSessionTypes], data["items"])

    def update_user_types(self, site_url: str, session_type_ids: List[str], person_id: str = None, email: str = None) -> UserSessionTypes:
        """
        Assign session types to specific users.

        :param site_url: Site URL for the session type.
        :type site_url: str
        :param session_type_ids: An array of the session type ID. Possible values: 3, 9
        :type session_type_ids: List[str]
        :param person_id: A unique identifier for the user.
        :type person_id: str
        :param email: The email of the user.
        :type email: str

        documentation: https://developer.webex.com/docs/api/v1/session-types/update-user-session-types
        """
        body = UpdateUserSessionTypesBody()
        if site_url is not None:
            body.site_url = site_url
        if session_type_ids is not None:
            body.session_type_ids = session_type_ids
        if person_id is not None:
            body.person_id = person_id
        if email is not None:
            body.email = email
        url = self.ep('userconfig/sessionTypes')
        data = super().put(url=url, data=body.json())
        return UserSessionTypes.parse_obj(data)

class TelephonyConfig(ApiModel):
    #: Whether call-in teleconferencing for sessions was enabled.
    allow_call_in: Optional[bool]
    #: Whether call-back teleconferencing for sessions was enabled.
    allow_call_back: Optional[bool]
    #: Whether other teleconferencing for sessions was enabled.
    allow_other_teleconf: Optional[bool]
    #: Whether toll-free call-in teleconferencing was enabled.
    allow_toll_free_callin: Optional[bool]
    #: Whether international call-in teleconferencing was enabled.
    allow_international_callin: Optional[bool]
    #: Whether international call-back teleconferencing was enabled.
    allow_international_callback: Optional[bool]
    #: Whether Voice Over IP functionality using the attendee computer's speakers and microphones was enabled.
    vo_ip: Optional[bool]


class EntryAndExitTone10(str, Enum):
    #: No tone.
    no_tone = 'NoTone'
    #: Beep.
    beep = 'Beep'
    #: Announce name.
    announce_name = 'AnnounceName'


class TelephonySupport(str, Enum):
    #: None.
    none = 'None'
    #: Webex teleconferencing.
    webex_teleconferencing = 'WebexTeleconferencing'
    #: Other Teleconferencing.
    other = 'Other'


class DefaultSchedulerOptions(ApiModel):
    #: Determines if a sound is made when someone enters or exits.
    entry_and_exit_tone: Optional[EntryAndExitTone10]
    #: Specifies whether or not joining teleconference without pressing 1 is checked by default.
    join_teleconf_not_press1: Optional[bool]
    #: Specifies the type of teleconference support for meetings.
    telephony_support: Optional[TelephonySupport]
    #: Specifies whether toll-free call-in is available.
    toll_free: Optional[bool]
    #: Denotes if VoIP protocols are being used.
    vo_ip: Optional[bool]


class PasswordCriteria(ApiModel):
    #: Determines if a password requires mixed case.
    mixed_case: Optional[bool]
    #: Sets the minimum password length.
    min_length: Optional[int]
    #: Sets the minimum number of numeric characters in the password.
    min_numeric: Optional[int]
    #: Sets the minimum number of alphabetical characters in the password.
    min_alpha: Optional[int]
    #: Sets the minimum number of special characters in the password.
    min_special: Optional[int]
    #: Do not allow dynamic web page text for meeting passwords (like site name, host's name, username, meeting topic).
    disallow_dynamic_web_text: Optional[bool]
    #: Specifies if passwords from the disallowValues list are to be allowed.
    disallow_list: Optional[bool]
    #: Sets password values that are not allowed.
    disallow_values: Optional[list[str]]


class SecurityOptions(ApiModel):
    #: Allow attendees or panelists to join before the host.
    join_before_host: Optional[bool]
    #: Allows attendees or panelists to join the teleconference before the host.
    audio_before_host: Optional[bool]
    #: Allows first attendee or panelist as the presenter.
    first_attendee_as_presenter: Optional[bool]
    #: Specifies that all meetings must be unlisted.
    unlist_all_meetings: Optional[bool]
    #: Determines if a user must login before getting site access.
    require_login_before_access: Optional[bool]
    #: Allow screen capture (Android devices only).
    allow_mobile_screen_capture: Optional[bool]
    #: Determines if strict passwords are required for meetings.
    require_strong_password: Optional[bool]
    #: Criteria of a strong password.
    password_criteria: Optional[PasswordCriteria]


class UpdateMeetingCommonSettingsConfigurationBody(ApiModel):
    #: Site Options on Webex Administration.
    #: Allow hosts to change their Personal Room URLs.
    site_options: Optional[object]
    #: Default Scheduler Options on Webex Administration (These options are applied to the site as defaults, but
    #: individual users can change them).
    default_scheduler_options: Optional[DefaultSchedulerOptions]
    #: Schedule Meeting Options on Webex Administration.
    #: Determines if email reminders are to be sent out.
    schedule_meeting_options: Optional[object]
    #: Security Options on Webex Administration.
    security_options: Optional[SecurityOptions]


class GetMeetingCommonSettingsConfigurationResponse(UpdateMeetingCommonSettingsConfigurationBody):
    #: Telephony Configuration on WebEx Super Admin (These options are read-only, unable to update by Update Common
    #: Settings API).
    telephony_config: Optional[TelephonyConfig]


class SiteApi(ApiChild, base='admin/meeting/config/commonSettings'):
    """
    This chapter provides descriptions of the Webex RESTful APIs for the site service, which contains operations like
    querying and updating common meeting configuration settings.
    Samples are given for the outbound request messages and expected server response messages. The API calls available
    as part of the Site service are listed below.
    You can see the elements that constitute the respective RESTful schema in a separate section below.
    """

    def common_settings_configuration(self, site_url: str = None) -> GetMeetingCommonSettingsConfigurationResponse:
        """
        Site administrators can use this API to get a list of functions, options, and privileges that are configured
        for their Webex service sites.

        :param site_url: URL of the Webex site which the API queries common settings of the meeting's configuration
            from. If not specified, the API will query from the site administrator's preferred site. All available
            Webex sites and the preferred site of the user can be retrieved by the Get Site List API.
        :type site_url: str

        documentation: https://developer.webex.com/docs/api/v1/site/get-meeting-common-settings-configuration
        """
        params = {}
        if site_url is not None:
            params['siteUrl'] = site_url
        url = self.ep()
        data = super().get(url=url, params=params)
        return GetMeetingCommonSettingsConfigurationResponse.parse_obj(data)

    def update_common_settings_configuration(self, site_options: object = None, default_scheduler_options: DefaultSchedulerOptions = None, schedule_meeting_options: object = None, security_options: SecurityOptions = None) -> GetMeetingCommonSettingsConfigurationResponse:
        """
        Site administrators can use this API to update the option of features, options and privileges that are
        configured for their WebEx service sites.

        :param site_options: Site Options on Webex Administration. Allow hosts to change their Personal Room URLs.
        :type site_options: object
        :param default_scheduler_options: Default Scheduler Options on Webex Administration (These options are applied
            to the site as defaults, but individual users can change them).
        :type default_scheduler_options: DefaultSchedulerOptions
        :param schedule_meeting_options: Schedule Meeting Options on Webex Administration. Determines if email
            reminders are to be sent out.
        :type schedule_meeting_options: object
        :param security_options: Security Options on Webex Administration.
        :type security_options: SecurityOptions

        documentation: https://developer.webex.com/docs/api/v1/site/update-meeting-common-settings-configuration
        """
        body = UpdateMeetingCommonSettingsConfigurationBody()
        if site_options is not None:
            body.site_options = site_options
        if default_scheduler_options is not None:
            body.default_scheduler_options = default_scheduler_options
        if schedule_meeting_options is not None:
            body.schedule_meeting_options = schedule_meeting_options
        if security_options is not None:
            body.security_options = security_options
        url = self.ep()
        data = super().patch(url=url, data=body.json())
        return GetMeetingCommonSettingsConfigurationResponse.parse_obj(data)

class CallForwardRulesModifyObject(ApiModel):
    #: A unique identifier for the auto attendant call forward selective rule.
    id: Optional[str]
    #: Flag to indicate if always call forwarding selective rule criteria is active. If not set, flag will be set to
    #: false.
    enabled: Optional[bool]


class HydraClassification(CallForwardRulesModifyObject):
    #: Represents the rank of the classification. A number from 0 to 4, in which 0 usually refers to "public", and is
    #: the default whenever a rank cannot be determined.
    rank: Optional[int]
    #: Represents the classification title to be displayed in classified spaces for org users.
    title: Optional[str]
    #: Classification's description.
    description: Optional[str]
    #: The date and time the Space Classification was last changed.
    last_modified: Optional[str]
    #: A unique identifier for the Webex organization.
    org_id: Optional[str]


class ListClassificationsResponse(ApiModel):
    items: Optional[list[HydraClassification]]


class SpaceClassificationsApi(ApiChild, base='classifications'):
    """
    Each Webex organization has its own Space Classification object that contains exactly five (5) space
    classifications.
    """

    def list_classifications(self) -> list[HydraClassification]:
        """
        List all the space classifications configured in your org.

        documentation: https://developer.webex.com/docs/api/v1/space-classifications/list-classifications
        """
        url = self.ep()
        data = super().get(url=url)
        return parse_obj_as(list[HydraClassification], data["items"])

class CreateTeamMembershipBody(ApiModel):
    #: The team ID.
    team_id: Optional[str]
    #: The person ID.
    person_id: Optional[str]
    #: The email address of the person.
    person_email: Optional[str]
    #: Whether or not the participant is a team moderator.
    is_moderator: Optional[bool]


class TeamMembership(CreateTeamMembershipBody):
    #: A unique identifier for the team membership.
    id: Optional[str]
    #: The display name of the person.
    person_display_name: Optional[str]
    #: The organization ID of the person.
    person_org_id: Optional[str]
    #: The date and time when the team membership was created.
    created: Optional[str]


class ListTeamMembershipsResponse(ApiModel):
    items: Optional[list[TeamMembership]]


class UpdateTeamMembershipBody(ApiModel):
    #: Whether or not the participant is a team moderator.
    is_moderator: Optional[bool]


class TeamMembershipsApi(ApiChild, base='team/memberships'):
    """
    Team Memberships represent a person's relationship to a team. Use this API to list members of any team that you're
    in or create memberships to invite someone to a team. Team memberships can also be updated to make someone a
    moderator or deleted to remove them from the team.
    Just like in the Webex app, you must be a member of the team in order to list its memberships or invite people.
    """

    def list_memberships(self, team_id: str, **params) -> Generator[TeamMembership, None, None]:
        """
        Lists all team memberships for a given team, specified by the teamId query parameter.
        Use query parameters to filter the response.

        :param team_id: List memberships for a team, by ID.
        :type team_id: str

        documentation: https://developer.webex.com/docs/api/v1/team-memberships/list-team-memberships
        """
        params['teamId'] = team_id
        url = self.ep()
        return self.session.follow_pagination(url=url, model=TeamMembership, params=params)

    def create_membership(self, team_id: str, person_id: str = None, person_email: str = None, is_moderator: bool = None) -> TeamMembership:
        """
        Add someone to a team by Person ID or email address, optionally making them a moderator.

        :param team_id: The team ID.
        :type team_id: str
        :param person_id: The person ID.
        :type person_id: str
        :param person_email: The email address of the person.
        :type person_email: str
        :param is_moderator: Whether or not the participant is a team moderator.
        :type is_moderator: bool

        documentation: https://developer.webex.com/docs/api/v1/team-memberships/create-a-team-membership
        """
        body = CreateTeamMembershipBody()
        if team_id is not None:
            body.team_id = team_id
        if person_id is not None:
            body.person_id = person_id
        if person_email is not None:
            body.person_email = person_email
        if is_moderator is not None:
            body.is_moderator = is_moderator
        url = self.ep()
        data = super().post(url=url, data=body.json())
        return TeamMembership.parse_obj(data)

    def membership_details(self, membership_id: str) -> TeamMembership:
        """
        Shows details for a team membership, by ID.
        Specify the team membership ID in the membershipId URI parameter.

        :param membership_id: The unique identifier for the team membership.
        :type membership_id: str

        documentation: https://developer.webex.com/docs/api/v1/team-memberships/get-team-membership-details
        """
        url = self.ep(f'{membership_id}')
        data = super().get(url=url)
        return TeamMembership.parse_obj(data)

    def update_membership(self, membership_id: str, is_moderator: bool) -> TeamMembership:
        """
        Updates a team membership, by ID.
        Specify the team membership ID in the membershipId URI parameter.

        :param membership_id: The unique identifier for the team membership.
        :type membership_id: str
        :param is_moderator: Whether or not the participant is a team moderator.
        :type is_moderator: bool

        documentation: https://developer.webex.com/docs/api/v1/team-memberships/update-a-team-membership
        """
        body = UpdateTeamMembershipBody()
        if is_moderator is not None:
            body.is_moderator = is_moderator
        url = self.ep(f'{membership_id}')
        data = super().put(url=url, data=body.json())
        return TeamMembership.parse_obj(data)

    def delete_membership(self, membership_id: str):
        """
        Deletes a team membership, by ID.
        Specify the team membership ID in the membershipId URI parameter.
        The team membership for the last moderator of a team may not be deleted; promote another user to team moderator
        first.

        :param membership_id: The unique identifier for the team membership.
        :type membership_id: str

        documentation: https://developer.webex.com/docs/api/v1/team-memberships/delete-a-team-membership
        """
        url = self.ep(f'{membership_id}')
        super().delete(url=url)
        return

class Team(TagsObj):
    #: A unique identifier for the team.
    id: Optional[str]
    #: The date and time the team was created.
    created: Optional[str]


class ListTeamsResponse(ApiModel):
    items: Optional[list[Team]]


class TeamsApi(ApiChild, base='teams'):
    """
    Teams are groups of people with a set of rooms that are visible to all members of that team. This API is used to
    manage the teams themselves. Teams are created and deleted with this API. You can also update a team to change its
    name, for example.
    To manage people in a team see the Team Memberships API.
    To manage team rooms see the Rooms API.
    """

    def list(self, **params) -> Generator[Team, None, None]:
        """
        Lists teams to which the authenticated user belongs.

        documentation: https://developer.webex.com/docs/api/v1/teams/list-teams
        """
        url = self.ep()
        return self.session.follow_pagination(url=url, model=Team, params=params)

    def create(self, name: str, description: str = None) -> Team:
        """
        Creates a team.
        The authenticated user is automatically added as a member of the team. See the Team Memberships API to learn
        how to add more people to the team.

        :param name: Name of the tag.
        :type name: str
        :param description: Description of the tag
        :type description: str

        documentation: https://developer.webex.com/docs/api/v1/teams/create-a-team
        """
        body = TagsObj()
        if name is not None:
            body.name = name
        if description is not None:
            body.description = description
        url = self.ep()
        data = super().post(url=url, data=body.json())
        return Team.parse_obj(data)

    def details(self, team_id: str, description: str = None) -> Team:
        """
        Shows details for a team, by ID.
        Specify the team ID in the teamId parameter in the URI.

        :param team_id: The unique identifier for the team.
        :type team_id: str
        :param description: The teams description.
        :type description: str

        documentation: https://developer.webex.com/docs/api/v1/teams/get-team-details
        """
        params = {}
        if description is not None:
            params['description'] = description
        url = self.ep(f'{team_id}')
        data = super().get(url=url, params=params)
        return Team.parse_obj(data)

    def update(self, team_id: str, name: str, description: str = None) -> Team:
        """
        Updates details for a team, by ID.
        Specify the team ID in the teamId parameter in the URI.

        :param team_id: The unique identifier for the team.
        :type team_id: str
        :param name: Name of the tag.
        :type name: str
        :param description: Description of the tag
        :type description: str

        documentation: https://developer.webex.com/docs/api/v1/teams/update-a-team
        """
        body = TagsObj()
        if name is not None:
            body.name = name
        if description is not None:
            body.description = description
        url = self.ep(f'{team_id}')
        data = super().put(url=url, data=body.json())
        return Team.parse_obj(data)

    def delete(self, team_id: str):
        """
        Deletes a team, by ID.
        Specify the team ID in the teamId parameter in the URI.

        :param team_id: The unique identifier for the team.
        :type team_id: str

        documentation: https://developer.webex.com/docs/api/v1/teams/delete-a-team
        """
        url = self.ep(f'{team_id}')
        super().delete(url=url)
        return

class ScheduleStartCodeObject(ApiModel):
    #: Service for schedule or sign up pages
    service: Optional[Service]
    #: Type for meeting scheduler or meeting start pages.
    type: Optional[Type14]


class GetTrackingCodeObject(Role):
    #: Site URL for the tracking code.
    site_url: Optional[str]
    #: Tracking code option list.
    options: Optional[list[OptionsForTrackingCodeObject]]
    #: An option for how an admin user can provide a code value.
    input_mode: Optional[InputMode]
    #: Type for the host profile.
    host_profile_code: Optional[HostProfileCode]
    #: Specify how tracking codes are used for each service on the meeting scheduler or meeting start pages.
    schedule_start_codes: Optional[list[ScheduleStartCodeObject]]


class CreateTrackingCodeBody(ApiModel):
    #: Name for tracking code. The name cannot be empty and the maximum size is 120 characters.
    name: Optional[str]
    #: Site URL for the tracking code.
    site_url: Optional[str]
    #: Tracking code option list. The maximum size of options is 500.
    options: Optional[list[OptionsForTrackingCodeObject]]
    #: Select an option for how users can provide a code value. Please note that if users set inputMode as
    #: hostProfileSelect, scheduleStartCode should be null, which means hostProfileSelect only applies to "Host
    #: Profile".
    input_mode: Optional[InputMode]
    #: Type for the host profile.
    host_profile_code: Optional[HostProfileCode]
    #: Specify how tracking codes are used for each service on the meeting scheduler or meeting start pages. The
    #: maximum size of scheduleStartCodes is 5.
    schedule_start_codes: Optional[list[ScheduleStartCodeObject]]


class GetTrackingCodeItemForUserObject(TrackingCodeItemForCreateMeetingObject):
    #: Unique identifier for tracking code.
    id: Optional[str]


class GetUserTrackingCodesResponse(ApiModel):
    #: Site URL for the tracking code.
    site_url: Optional[str]
    #: Unique identifier for the user.
    person_id: Optional[str]
    #: Email address for the user.
    email: Optional[str]
    #: Tracking code information.
    tracking_codes: Optional[list[GetTrackingCodeItemForUserObject]]


class ListTrackingCodesResponse(ApiModel):
    #: Tracking codes information.
    items: Optional[list[GetTrackingCodeObject]]


class UpdateUserTrackingCodesBody(ApiModel):
    #: Site URL for the tracking code.
    site_url: Optional[str]
    #: Unique identifier for the user. At least one parameter of personId or email is required. personId must precede
    #: email if both are specified.
    person_id: Optional[str]
    #: Email address for the user. At least one parameter of personId or email is required. personId must precede email
    #: if both are specified.
    email: Optional[str]
    #: Tracking code information for updates.
    tracking_codes: Optional[list[TrackingCodeItemForCreateMeetingObject]]


class TrackingCodesApi(ApiChild, base=''):
    """
    Tracking codes are alphanumeric codes that identify categories of users on a Webex site. With tracking codes, you
    can analyze usage by various groups within an organization.
    The authenticated user calling this API must have an Administrator role with the meeting:admin_schedule_write and
    meeting:admin_schedule_read scopes.
    """

    def list_codes(self, site_url: str = None) -> list[GetTrackingCodeObject]:
        """
        Lists tracking codes on a site by an admin user.

        :param site_url: URL of the Webex site which the API retrieves the tracking code from. If not specified, the
            API retrieves the tracking code from the user's preferred site. All available Webex sites and preferred
            sites of a user can be retrieved by the Get Site List API.
        :type site_url: str

        documentation: https://developer.webex.com/docs/api/v1/tracking-codes/list-tracking-codes
        """
        params = {}
        if site_url is not None:
            params['siteUrl'] = site_url
        url = self.ep('https: //webexapis.com/v1/admin/meeting/config/trackingCodes')
        data = super().get(url=url, params=params)
        return parse_obj_as(list[GetTrackingCodeObject], data["items"])

    def code(self, tracking_code_id: str, site_url: str = None) -> GetTrackingCodeObject:
        """
        Retrieves details for a tracking code by an admin user.

        :param tracking_code_id: Unique identifier for the tracking code whose details are being requested.
        :type tracking_code_id: str
        :param site_url: URL of the Webex site which the API retrieves the tracking code from. If not specified, the
            API retrieves the tracking code from the user's preferred site. All available Webex sites and the preferred
            sites of a user can be retrieved by the Get Site List API.
        :type site_url: str

        documentation: https://developer.webex.com/docs/api/v1/tracking-codes/get-a-tracking-code
        """
        params = {}
        if site_url is not None:
            params['siteUrl'] = site_url
        url = self.ep(f'https: //webexapis.com/v1/admin/meeting/config/trackingCodes/{tracking_code_id}')
        data = super().get(url=url, params=params)
        return GetTrackingCodeObject.parse_obj(data)

    def create_code(self, name: str, site_url: str, options: OptionsForTrackingCodeObject, input_mode: InputMode, host_profile_code: HostProfileCode, schedule_start_codes: ScheduleStartCodeObject) -> GetTrackingCodeObject:
        """
        Create a new tracking code by an admin user.

        :param name: Name for tracking code. The name cannot be empty and the maximum size is 120 characters.
        :type name: str
        :param site_url: Site URL for the tracking code.
        :type site_url: str
        :param options: Tracking code option list. The maximum size of options is 500.
        :type options: OptionsForTrackingCodeObject
        :param input_mode: Select an option for how users can provide a code value. Please note that if users set
            inputMode as hostProfileSelect, scheduleStartCode should be null, which means hostProfileSelect only
            applies to "Host Profile".
        :type input_mode: InputMode
        :param host_profile_code: Type for the host profile.
        :type host_profile_code: HostProfileCode
        :param schedule_start_codes: Specify how tracking codes are used for each service on the meeting scheduler or
            meeting start pages. The maximum size of scheduleStartCodes is 5.
        :type schedule_start_codes: ScheduleStartCodeObject

        documentation: https://developer.webex.com/docs/api/v1/tracking-codes/create-a-tracking-code
        """
        body = CreateTrackingCodeBody()
        if name is not None:
            body.name = name
        if site_url is not None:
            body.site_url = site_url
        if options is not None:
            body.options = options
        if input_mode is not None:
            body.input_mode = input_mode
        if host_profile_code is not None:
            body.host_profile_code = host_profile_code
        if schedule_start_codes is not None:
            body.schedule_start_codes = schedule_start_codes
        url = self.ep('https: //webexapis.com/v1/admin/meeting/config/trackingCodes')
        data = super().post(url=url, data=body.json())
        return GetTrackingCodeObject.parse_obj(data)

    def update_code(self, name: str, site_url: str, options: OptionsForTrackingCodeObject, input_mode: InputMode, host_profile_code: HostProfileCode, schedule_start_codes: ScheduleStartCodeObject) -> GetTrackingCodeObject:
        """
        Updates details for a tracking code by an admin user.

        :param name: Name for tracking code. The name cannot be empty and the maximum size is 120 characters.
        :type name: str
        :param site_url: Site URL for the tracking code.
        :type site_url: str
        :param options: Tracking code option list. The maximum size of options is 500.
        :type options: OptionsForTrackingCodeObject
        :param input_mode: Select an option for how users can provide a code value. Please note that if users set
            inputMode as hostProfileSelect, scheduleStartCode should be null, which means hostProfileSelect only
            applies to "Host Profile".
        :type input_mode: InputMode
        :param host_profile_code: Type for the host profile.
        :type host_profile_code: HostProfileCode
        :param schedule_start_codes: Specify how tracking codes are used for each service on the meeting scheduler or
            meeting start pages. The maximum size of scheduleStartCodes is 5.
        :type schedule_start_codes: ScheduleStartCodeObject

        documentation: https://developer.webex.com/docs/api/v1/tracking-codes/update-a-tracking-code
        """
        body = CreateTrackingCodeBody()
        if name is not None:
            body.name = name
        if site_url is not None:
            body.site_url = site_url
        if options is not None:
            body.options = options
        if input_mode is not None:
            body.input_mode = input_mode
        if host_profile_code is not None:
            body.host_profile_code = host_profile_code
        if schedule_start_codes is not None:
            body.schedule_start_codes = schedule_start_codes
        url = self.ep('https: //webexapis.com/v1/admin/meeting/config/trackingCodes/{trackingCodeId}')
        data = super().put(url=url, data=body.json())
        return GetTrackingCodeObject.parse_obj(data)

    def delete_code(self, tracking_code_id: str, site_url: str):
        """
        Deletes a tracking code by an admin user.

        :param tracking_code_id: Unique identifier for the tracking code to be deleted.
        :type tracking_code_id: str
        :param site_url: URL of the Webex site from which the API deletes the tracking code. All available Webex sites
            and preferred sites of a user can be retrieved by the Get Site List API.
        :type site_url: str

        documentation: https://developer.webex.com/docs/api/v1/tracking-codes/delete-a-tracking-code
        """
        params = {}
        params['siteUrl'] = site_url
        url = self.ep(f'https: //webexapis.com/v1/admin/meeting/config/trackingCodes/{tracking_code_id}')
        super().delete(url=url, params=params)
        return

    def user_codes(self, site_url: str = None, person_id: str = None) -> GetUserTrackingCodesResponse:
        """
        Lists user's tracking codes by an admin user.

        :param site_url: URL of the Webex site from which the API retrieves the tracking code. If not specified, the
            API retrieves the tracking code from the user's preferred site. All available Webex sites and preferred
            sites of a user can be retrieved by the Get Site List API.
        :type site_url: str
        :param person_id: Unique identifier for the user whose tracking codes are being retrieved. The admin user can
            specify the personId of a user on a site they manage and the API returns details for the user's tracking
            codes. At least one parameter of personId or email is required.
        :type person_id: str

        documentation: https://developer.webex.com/docs/api/v1/tracking-codes/get-user-tracking-codes
        """
        params = {}
        if site_url is not None:
            params['siteUrl'] = site_url
        if person_id is not None:
            params['personId'] = person_id
        url = self.ep('https: //webexapis.com/v1/admin/meeting/userconfig/trackingCodes')
        data = super().get(url=url, params=params)
        return GetUserTrackingCodesResponse.parse_obj(data)

    def update_user_codes(self, site_url: str, person_id: str = None, email: str = None, tracking_codes: TrackingCodeItemForCreateMeetingObject = None) -> GetUserTrackingCodesResponse:
        """
        Updates tracking codes for a specified user by an admin user.

        :param site_url: Site URL for the tracking code.
        :type site_url: str
        :param person_id: Unique identifier for the user. At least one parameter of personId or email is required.
            personId must precede email if both are specified.
        :type person_id: str
        :param email: Email address for the user. At least one parameter of personId or email is required. personId
            must precede email if both are specified.
        :type email: str
        :param tracking_codes: Tracking code information for updates.
        :type tracking_codes: TrackingCodeItemForCreateMeetingObject

        documentation: https://developer.webex.com/docs/api/v1/tracking-codes/update-user-tracking-codes
        """
        body = UpdateUserTrackingCodesBody()
        if site_url is not None:
            body.site_url = site_url
        if person_id is not None:
            body.person_id = person_id
        if email is not None:
            body.email = email
        if tracking_codes is not None:
            body.tracking_codes = tracking_codes
        url = self.ep('https: //webexapis.com/v1/admin/meeting/userconfig/trackingCodes')
        data = super().put(url=url, data=body.json())
        return GetUserTrackingCodesResponse.parse_obj(data)

class ClusterAvailableTimeline(ApiModel):
    #: Start date and time of the segment of availability data.
    segment_start_time: Optional[str]
    #: End date and time of the segment of availability data.
    segment_end_time: Optional[str]
    #: Availability information of the Video Mesh cluster.
    availability: Optional[str]
    #: Number of nodes that are online.
    no_of_online_nodes: Optional[int]
    #: Number of nodes that are offline.
    no_of_offline_nodes: Optional[int]
    #: Total number of nodes in the Video Mesh cluster.
    total_nodes: Optional[int]


class ClusterAvailability(ApiModel):
    #: ID of the Video Mesh cluster.
    cluster_id: Optional[str]
    #: Name of the Video Mesh cluster.
    cluster_name: Optional[str]
    availability_segments: Optional[list[ClusterAvailableTimeline]]


class ClusterAvailabilityCollection(ApiModel):
    #: The unique ID for the organization.
    org_id: Optional[str]
    #: Availability details of the Video Mesh cluster.
    items: Optional[list[ClusterAvailability]]
    #: Start date and time (inclusive) of the availability data.
    from: Optional[str]
    #: End date and time (inclusive) of the availability data.
    to: Optional[str]


class NodeAvailableTimeline(ClusterAvailableTimeline):
    #: Reason for the Video Mesh node being unavailable (if any).
    un_availability_reason: Optional[str]


class NodeAvailability(ApiModel):
    #: ID of the Video Mesh cluster.
    cluster_id: Optional[str]
    #: Name of the Video Mesh cluster.
    cluster_name: Optional[str]
    #: Host Name or the IP of the Video Mesh node.
    host_name_or_ip: Optional[str]
    #: ID of the Video Mesh node.
    node_id: Optional[str]
    availability_segments: Optional[list[NodeAvailableTimeline]]


class NodeAvailabilityCollection(ApiModel):
    #: Unique ID for a Video Mesh organization.
    org_id: Optional[str]
    #: Availability details of the Video Mesh cluster.
    items: Optional[list[NodeAvailability]]
    #: Start date and time (inclusive) of the availability data.
    from: Optional[str]
    #: End date and time (inclusive) of the availability data.
    to: Optional[str]


class SingleNodeAvailableTimeline(ApiModel):
    #: Start date and time of the segment of availability data.
    segment_start_time: Optional[str]
    #: End date and time of the segment of availability data.
    segment_end_time: Optional[str]
    #: Availability information of the Video Mesh node.
    availability: Optional[str]
    #: Reason for the Video Mesh node being unavailable (if any).
    un_availability_reason: Optional[str]


class SingleNodeAvailability(ApiModel):
    #: ID of the Video Mesh cluster.
    cluster_id: Optional[str]
    #: Name of the Video Mesh cluster.
    cluster_name: Optional[str]
    #: Host Name or the IP of the Video Mesh node.
    host_name_or_ip: Optional[str]
    #: ID of the Video Mesh node.
    node_id: Optional[str]
    availability_segments: Optional[list[SingleNodeAvailableTimeline]]


class SingleNodeAvailabilityCollection(ApiModel):
    #: Unique ID for a Video Mesh organization.
    org_id: Optional[str]
    #: Availability details of the Video Mesh cluster.
    items: Optional[list[SingleNodeAvailability]]
    #: Start date and time (inclusive) of the availability data.
    from: Optional[str]
    #: End date and time (inclusive) of the availability data.
    to: Optional[str]


class MediaSignallingtestResultFailure(ApiModel):
    #: The name of the test.
    test_name: Optional[str]
    #: Test results(Success/Failed).
    test_result: Optional[str]
    #: Reason for test failure.
    failure_reason: Optional[str]


class MediaHealthMonitoringTestResultsFailure(ApiModel):
    #: The timestamp of the test run.
    timestamp: Optional[str]
    #: Unique ID of the test.
    id: Optional[str]
    #: Test results of Media Signalling, SIP Signalling, Media Cascade runs.
    test_results: Optional[list[MediaSignallingtestResultFailure]]


class MediaHealthMonitoringsecondnode(ApiModel):
    #: Unique ID of the Video Mesh node.
    node_id: Optional[str]
    #: Host name or the IP of the Video Mesh node.
    host_name_or_ip: Optional[str]
    #: The Media Health Monitoring Tool test results for a single Video Mesh node.
    mhm_test_results: Optional[list[MediaHealthMonitoringTestResultsFailure]]


class MediaHealthMonitoringforfirstcluster(ApiModel):
    #: Unique ID of the Video Mesh cluster.
    cluster_id: Optional[str]
    #: Name of the Video Mesh cluster.
    cluster_name: Optional[str]
    #: The Video Mesh nodes in the cluster.
    nodes: Optional[list[MediaHealthMonitoringsecondnode]]


class MediaHealthMonitoringclusters(ApiModel):
    #: The list of Video Mesh clusters.
    clusters: Optional[list[MediaHealthMonitoringforfirstcluster]]


class MediaHealthMonitoringResultsCollectionfororganization(ApiModel):
    #: Unique ID of the organization.
    org_id: Optional[str]
    #: Start date and time (inclusive) of the Media Health Monitoring Tool data.
    from: Optional[str]
    #: End date and time (inclusive) of the Media Health Monitoring Tool data.
    to: Optional[str]
    #: Media Health Monitoring Tool test results.
    items: Optional[list[MediaHealthMonitoringclusters]]


class PerclusterMediaHealthMonitoringclusters(ApiModel):
    #: List of Video Mesh clusters.
    clusters: Optional[list[MediaHealthMonitoringforfirstcluster]]


class MediaHealthMonitoringResultsCollectionforcluster(ApiModel):
    #: Unique ID of the organization.
    org_id: Optional[str]
    #: Start date and time (inclusive) of the Media Health Monitoring Tool data.
    from: Optional[str]
    #: End date and time (inclusive) of the Media Health Monitoring Tool data.
    to: Optional[str]
    #: Media Health Monitoring Tool test results.
    items: Optional[list[PerclusterMediaHealthMonitoringclusters]]


class PernodeMediaHealthMonitoringresult(ApiModel):
    #: Unique ID of the Video Mesh cluster.
    cluster_id: Optional[str]
    #: Name of the Video Mesh cluster.
    cluster_name: Optional[str]
    #: The Video Mesh nodes in the cluster.
    nodes: Optional[list[MediaHealthMonitoringsecondnode]]


class PernodeMediaHealthMonitoringclusters(ApiModel):
    #: The list of Video Mesh clusters.
    clusters: Optional[list[PernodeMediaHealthMonitoringresult]]


class MediaHealthMonitoringResultsCollectionfornode(ApiModel):
    #: Unique ID of the organization.
    org_id: Optional[str]
    #: Start date and time (inclusive) of the Media Health Monitoring Tool data.
    from: Optional[str]
    #: End date and time (inclusive) of the Media Health Monitoring Tool data.
    to: Optional[str]
    #: Media Health Monitoring Tool test results.
    items: Optional[list[PernodeMediaHealthMonitoringclusters]]


class OverflowDetails1(ApiModel):
    #: The reason for this overflow.
    overflow_reason: Optional[str]
    #: Number of overflows.
    overflow_count: Optional[int]
    #: Any possible remediations for this overflow.
    possible_remediation: Optional[str]


class CloudOverflowTrend1(ApiModel):
    #: Timestamp.
    timestamp: Optional[str]
    #: Overflow Details.
    overflow_details: Optional[list[OverflowDetails1]]


class OverflowtoCloudCollection(ApiModel):
    #: The unique ID for the organization.
    org_id: Optional[str]
    #: Start date and time (inclusive) for the Overflow to Cloud data.
    from: Optional[str]
    #: End date and time (inclusive) for the Overflow to Cloud data.
    to: Optional[str]
    #: The aggregation period of the trend data.
    aggregation_interval: Optional[str]
    #: Overflow data for the organization.
    items: Optional[list[CloudOverflowTrend1]]


class ClusterRedirectDetailsBlr1a(ApiModel):
    #: The reason for the redirect.
    redirect_reason: Optional[str]
    #: Number of Call Redirects.
    redirect_count: Optional[int]
    #: Any possible remediations for this overflow.
    possible_remediation: Optional[str]


class ClusterRedirectBlr1(ApiModel):
    #: ID of the Video Mesh cluster.
    cluster_id: Optional[str]
    #: Name of the Video Mesh cluster.
    cluster_name: Optional[str]
    #: Call Redirect Details.
    redirect_details: Optional[list[ClusterRedirectDetailsBlr1a]]


class RedirectTrend1(ApiModel):
    #: Timestamp.
    timestamp: Optional[str]
    clusters: Optional[list[ClusterRedirectBlr1]]


class RedirectCollectionForOrg(ApiModel):
    #: The unique ID for the organization.
    org_id: Optional[str]
    #: Start date and time (inclusive) for the Call Redirect details.
    from: Optional[str]
    #: End date and time (inclusive) of the Call Redirect details.
    to: Optional[str]
    #: The aggregation period of the trend data.
    aggregation_interval: Optional[str]
    #: Redirect details for the organization.
    items: Optional[list[RedirectTrend1]]


class RedirectCollectionForCluster(ApiModel):
    #: The unique ID for the organization.
    org_id: Optional[str]
    #: Start date and time (inclusive) for the Call Redirect details.
    from: Optional[str]
    #: End date and time (inclusive) of the Call Redirect details.
    to: Optional[str]
    #: The aggregation period of the trend data.
    aggregation_interval: Optional[str]
    #: Redirect details for the organization.
    items: Optional[list[RedirectTrend1]]


class UtilizationMetricsT1SJ(ApiModel):
    #: Peak CPU usage during the time interval.
    peak_cpu: Optional[int]
    #: Average CPU usage during the time interval.
    avg_cpu: Optional[int]
    #: Maximum active calls at a point in the time interval.
    active_calls: Optional[int]
    #: Maximum active private calls at a point in the time interval.
    active_private_calls: Optional[int]


class ClusterUtilizationT1SJ(ApiModel):
    #: ID of the Video Mesh cluster.
    cluster_id: Optional[str]
    #: Name of the Video Mesh cluster.
    cluster_name: Optional[str]
    #: Utilization details for the cluster in the time interval.
    utilization_metrics: Optional[UtilizationMetricsT1SJ]


class ClusterUtilizationTrend1(ApiModel):
    #: Timestamp.
    timestamp: Optional[str]
    clusters: Optional[list[ClusterUtilizationT1SJ]]


class ClusterUtilizationCollection(ApiModel):
    #: The unique ID for the organization.
    org_id: Optional[str]
    #: The aggregation period of the trend data.
    aggregation_interval: Optional[str]
    #: Start date and time (inclusive) of the utilization data.
    from: Optional[str]
    #: End date and time (inclusive) of the utilization data.
    to: Optional[str]
    #: Utilization details of the Video Mesh cluster
    items: Optional[list[ClusterUtilizationTrend1]]


class ClusterUtilizationT1Blr(ApiModel):
    #: ID of the Video Mesh cluster.
    cluster_id: Optional[str]
    #: Name of the Video Mesh cluster.
    cluster_name: Optional[str]
    #: Utilization details for the cluster in the time interval.
    utilization_metrics: Optional[UtilizationMetricsT1SJ]


class UtilizationForClusterTrend1(ApiModel):
    #: Timestamp.
    timestamp: Optional[str]
    clusters: Optional[list[ClusterUtilizationT1Blr]]


class UtilizationForClusterCollection(ApiModel):
    #: The unique ID for the organization.
    org_id: Optional[str]
    #: The aggregation period of the trend data.
    aggregation_interval: Optional[str]
    #: Start date and time (inclusive) of the utilization data.
    from: Optional[str]
    #: End date and time (inclusive) of the utilization data.
    to: Optional[str]
    #: Utilization details of the Video Mesh cluster.
    items: Optional[list[UtilizationForClusterTrend1]]


class ReachabilityTestresultsFailure(ApiModel):
    #: Destination IP address.
    ip_address: Optional[str]
    #: Port number.
    port: Optional[int]
    #: Port reachability information.
    reachable: Optional[bool]


class ReachabilityTestresultsStunresults1(ApiModel):
    #: The timestamp of the test run.
    timestamp: Optional[str]
    #: The type of the test being executed. Can be either OnDemand or Periodic.
    trigger_type: Optional[str]
    #: Unique ID of the test.
    id: Optional[str]
    #: List of UDP ports being checked in Reachability test.
    udp: Optional[list[ReachabilityTestresultsFailure]]
    #: List of TCP ports being checked in Reachability test.
    tcp: Optional[list[ReachabilityTestresultsFailure]]


class ReachabilityTestresultsdestinationcluster(ApiModel):
    #: Cloud Webex cluster against which Reachability test is being executed.
    destination_cluster: Optional[str]
    #: STUN test results for a Video Mesh cluster.
    stun_results: Optional[list[ReachabilityTestresultsStunresults1]]


class ReachabilityTestresultsfirstnode(ApiModel):
    #: Unique ID of the Video Mesh node.
    node_id: Optional[str]
    #: Host name or the IP of the Video Mesh node.
    host_name_or_ip: Optional[str]
    #: Reachability test results for a single Video Mesh node.
    test_results: Optional[list[ReachabilityTestresultsdestinationcluster]]


class ReachabilityTestResultsforfirstcluster(ApiModel):
    #: Unique ID of the Video Mesh cluster.
    cluster_id: Optional[str]
    #: Name of the Video Mesh cluster.
    cluster_name: Optional[str]
    #: The Video Mesh nodes in the cluster.
    nodes: Optional[list[ReachabilityTestresultsfirstnode]]


class ReachabilityTestResultsforcluster(ApiModel):
    #: List of Video Mesh clusters.
    clusters: Optional[list[ReachabilityTestResultsforfirstcluster]]


class ReachabilityTestresultsfororganization(ApiModel):
    #: Unique ID of the organization.
    org_id: Optional[str]
    #: Start date and time (inclusive) of the Reachability test results data.
    from: Optional[str]
    #: End date and time (inclusive) of the Reachability test results data.
    to: Optional[str]
    #: Reachability test results data.
    items: Optional[list[ReachabilityTestResultsforcluster]]


class ReachabilityTestResultsforsinglecluster(ApiModel):
    #: List of Video Mesh clusters.
    clusters: Optional[list[ReachabilityTestResultsforfirstcluster]]


class ReachabilityTestresultsforcluster(ApiModel):
    #: Unique ID of the organization.
    org_id: Optional[str]
    #: Start date and time (inclusive) of the Reachability test results data.
    from: Optional[str]
    #: End date and time (inclusive) of the Reachability test results data.
    to: Optional[str]
    #: Reachability test results data.
    items: Optional[list[ReachabilityTestResultsforsinglecluster]]


class ReachabilityTestResultsforoneclusteronenode(ApiModel):
    #: List of Video Mesh clusters.
    clusters: Optional[list[ReachabilityTestResultsforfirstcluster]]


class ReachabilityTestresultsfornode(ApiModel):
    #: Unique ID of the organization.
    org_id: Optional[str]
    #: Start date and time (inclusive) of the Reachability test results data.
    from: Optional[str]
    #: End date and time (inclusive) of the Reachability test results data.
    to: Optional[str]
    #: Reachability test results data.
    items: Optional[list[ReachabilityTestResultsforoneclusteronenode]]


class BlrNodeLocation(ApiModel):
    #: Country code of the Location where the Video Mesh node is deployed.
    country_code: Optional[str]
    #: City where Video Mesh node is deployed.
    city: Optional[str]
    #: Time zone in which the Video Mesh node is deployed.
    time_zone: Optional[str]


class BlrNode1(ApiModel):
    #: ID of the Video Mesh node.
    node_id: Optional[str]
    #: Host Name or the IP of the Video Mesh node.
    host_name_or_ip: Optional[str]
    #: Deployment Type of the Video Mesh node.
    deployment_type: Optional[str]
    #: Location details of the Video Mesh node.
    location: Optional[BlrNodeLocation]


class ClusterUpgradeScheduleBlr(ApiModel):
    #: Days of the week when scheduled upgrades will occur for the Video Mesh cluster.
    schedule_days: Optional[list[str]]
    #: Time when scheduled upgrade will occur for the Video Mesh cluster.
    schedule_time: Optional[str]
    #: Timezone of the scheduled upgrade of Video Mesh cluster.
    schedule_time_zone: Optional[str]
    #: Upgrade Pending information.
    upgrade_pending: Optional[bool]
    #: Time when the next upgrade is scheduled for the Video Mesh cluster.
    next_upgrade_time: Optional[str]


class BlrClusterDetails(ApiModel):
    #: ID of the Video Mesh cluster.
    cluster_id: Optional[str]
    #: Name of the Video Mesh cluster.
    cluster_name: Optional[str]
    #: The Video Mesh nodes in the cluster.
    nodes: Optional[list[BlrNode1]]
    #: Release Channel of the Video Mesh cluster.
    release_channel: Optional[str]
    #: Upgrade Schedule details of the Video Mesh cluster.
    upgrade_schedule: Optional[ClusterUpgradeScheduleBlr]


class ClusterDetailsCollection(ApiModel):
    #: The unique ID for the organization.
    org_id: Optional[str]
    #: Details of all the clusters of the organization.
    items: Optional[list[BlrClusterDetails]]


class Type32(str, Enum):
    #: Used to test whether the media ports within the Video Mesh node are open, and whether the Video Mesh node is
    #: able to reach the cloud clusters pertaining to the media containers via those ports.
    reachability_test = 'ReachabilityTest'
    #: Used to test the network environment of the Video Mesh node by running various connectivity, bandwidth, and DNS
    #: resolution tests against Webex Cloud and ThirdParty Cloud (Docker) services.
    network_test = 'NetworkTest'
    #: Used to test the meetings and call health of Video Mesh nodes using signaling and cascading methods.
    media_health_monitor_test = 'MediaHealthMonitorTest'


class Status27(str, Enum):
    dispatched = 'Dispatched'
    completed = 'Completed'
    errored = 'Errored'


class NodeStatusList1(ApiModel):
    #: Unique ID of the Video Mesh node.
    node_id: Optional[str]
    #: Status of the test triggered.
    status: Optional[Status27]


class TriggerOndemandTestForClusterResponse(ApiModel):
    #: Unique ID of the organization.
    org_id: Optional[str]
    #: The unique ID of the test being executed.
    command_id: Optional[str]
    #: Unique ID of the Video Mesh cluster.
    cluster_id: Optional[str]
    nodes: Optional[list[NodeStatusList1]]


class MHMTestResults(ApiModel):
    #: The timestamp of the test run.
    timestamp: Optional[str]
    id: Optional[str]
    test_results: Optional[list[MediaSignallingtestResultFailure]]


class NodesResult(ApiModel):
    #: Unique ID of the Video Mesh node.
    node_id: Optional[str]
    #: Host name or IP Address of the Video Mesh node.
    host_name_or_ip: Optional[str]
    mhm_test_results: Optional[list[MHMTestResults]]


class Results(ApiModel):
    #: Unique ID of the Video Mesh cluster.
    cluster_id: Optional[str]
    #: Name of the Video Mesh cluster.
    cluster_name: Optional[str]
    nodes: Optional[list[NodesResult]]


class TestClustersResult(ApiModel):
    clusters: Optional[list[Results]]


class FailureDetails1(ApiModel):
    #: Possible reasons for failure for the test.
    possible_failure_reason: Optional[list[str]]
    #: Possible fixes for the failures mentioned above.
    possible_remediation: Optional[list[str]]


class ServiceTypeResult1(ApiModel):
    #: Service for which the test was executed.
    service_type: Optional[str]
    #: Result of the test executed.
    test_result: Optional[str]
    failure_details: Optional[FailureDetails1]


class DNSResolutionTest(ApiModel):
    #: The type of test result.
    type: Optional[str]
    #: Test Results from different services.
    results: Optional[list[ServiceTypeResult1]]


class ConnectivityTestResultsForNode(ApiModel):
    #: The timestamp of the test run.
    timestamp: Optional[str]
    #: The type of the test being executed. Can be either OnDemand or Periodic.
    trigger_type: Optional[str]
    #: Unique ID of the test.
    id: Optional[str]
    result: Optional[list[DNSResolutionTest]]


class PerNodeConnectivityResult1(ApiModel):
    #: Unique ID of the Video Mesh node.
    node_id: Optional[str]
    #: Host name or IP Address of the Video Mesh node.
    host_name_or_ip: Optional[str]
    test_results: Optional[list[ConnectivityTestResultsForNode]]


class PerClusterConnectivityResult1(ApiModel):
    #: Unique ID of the Video Mesh cluster.
    cluster_id: Optional[str]
    #: Name of the Video Mesh cluster.
    cluster_name: Optional[str]
    nodes: Optional[list[PerNodeConnectivityResult1]]


class ConnectivityTestResultsClustersObject1(ApiModel):
    #: List of Video Mesh clusters.
    clusters: Optional[list[PerClusterConnectivityResult1]]


class PerClusterConnectivityResult2(ApiModel):
    #: Unique ID of the Video Mesh cluster.
    cluster_id: Optional[str]
    #: Name of the Video Mesh cluster.
    cluster_name: Optional[str]
    nodes: Optional[list[PerNodeConnectivityResult1]]


class ConnectivityTestResultsClustersObject2(ApiModel):
    #: List of Video Mesh clusters.
    clusters: Optional[list[PerClusterConnectivityResult2]]


class ConnectivityTestResultsClustersObject3(ApiModel):
    #: List of Video Mesh clusters.
    clusters: Optional[list[PerClusterConnectivityResult1]]


class ListClustersAvailabilityResponse(ApiModel):
    items: Optional[list[ClusterAvailabilityCollection]]


class GetClusterAvailabilityResponse(ApiModel):
    items: Optional[list[ClusterAvailabilityCollection]]


class ListNodeAvailabilityResponse(ApiModel):
    items: Optional[list[NodeAvailabilityCollection]]


class GetNodeAvailabilityResponse(ApiModel):
    items: Optional[list[SingleNodeAvailabilityCollection]]


class ListMediaHealthMonitoringToolResultsResponse(ApiModel):
    items: Optional[list[MediaHealthMonitoringResultsCollectionfororganization]]


class GetMediaHealthMonitoringToolClusterResultsResponse(ApiModel):
    items: Optional[list[MediaHealthMonitoringResultsCollectionforcluster]]


class GetMediaHealthMonitoringToolNodeResultsResponse(ApiModel):
    items: Optional[list[MediaHealthMonitoringResultsCollectionfornode]]


class ListOverflowToCloudDetailsResponse(ApiModel):
    items: Optional[list[OverflowtoCloudCollection]]


class ListClusterRedirectDetailsResponse(ApiModel):
    items: Optional[list[RedirectCollectionForOrg]]


class GetClusterRedirectDetailsResponse(ApiModel):
    items: Optional[list[RedirectCollectionForCluster]]


class ListClustersUtilizationResponse(ApiModel):
    items: Optional[list[ClusterUtilizationCollection]]


class GetClusterUtilizationDetailsResponse(ApiModel):
    items: Optional[list[UtilizationForClusterCollection]]


class ListReachabilityTestResultsResponse(ApiModel):
    items: Optional[list[ReachabilityTestresultsfororganization]]


class GetReachabilityTestResultsForClusterResponse(ApiModel):
    items: Optional[list[ReachabilityTestresultsforcluster]]


class GetReachabilityTestResultsForNodeResponse(ApiModel):
    items: Optional[list[ReachabilityTestresultsfornode]]


class ListClusterDetailsResponse(ApiModel):
    items: Optional[list[ClusterDetailsCollection]]


class GetClusterDetailsResponse(ApiModel):
    items: Optional[list[ClusterDetailsCollection]]


class TriggerOndemandTestForClusterBody(ApiModel):
    #: Test type to trigger on node.
    type: Optional[Type32]
    #: List of nodes to test.
    #: Possible values:
    #: Y2lzY29zcGFyazovL3VzL0hZQlJJRF9DT05ORUNUT1IvMmMzYzlmOWUtNzNkOS00NDYwLWE2NjgtMDQ3MTYyZmYxYmFjOjE1NmRmNzg5Yzg1NTRkNTVhMjc1ZGU5OTc4Zjk5MDJk,
    #: Y2lzY29zcGFyazovL3VzL0hZQlJJRF9DT05ORUNUT1IvMmMzYzlmOWUtNzNkOS00NDYwLWE2NjgtMDQ3MTYyZmYxYmFjOjE1NmRmNzg5Yzg1NTRhYmNhZGVmZ2U5OTc4Zjk5MDJk
    nodes: Optional[list[str]]


class TriggerOndemandTestForNodeBody(ApiModel):
    #: Test type to trigger on node.
    type: Optional[Type32]


class GetTriggeredTestResultsResponse(ApiModel):
    #: Test type of the command ID.
    type: Optional[str]
    #: The unique ID for the test being executed.
    command_id: Optional[str]
    #: Unique ID of the organization.
    org_id: Optional[str]
    results: Optional[list[TestClustersResult]]


class ListNetworkTestResultsResponse(ApiModel):
    #: Unique ID of the organization.
    org_id: Optional[str]
    #: Start date and time (inclusive) of the Network Test data.
    from: Optional[str]
    #: End date and time (inclusive) of the Network Test data.
    to: Optional[str]
    #: Network test results.
    items: Optional[list[ConnectivityTestResultsClustersObject1]]


class GetNetworkTestResultsForClusterResponse(ApiModel):
    #: Unique ID of the organization.
    org_id: Optional[str]
    #: Start date and time (inclusive) of the Network Test data.
    from: Optional[str]
    #: End date and time (inclusive) of the Network Test data.
    to: Optional[str]
    #: Network test results.
    items: Optional[list[ConnectivityTestResultsClustersObject2]]


class GetNetworkTestResultsForNodeResponse(ApiModel):
    #: Unique ID of the organization.
    org_id: Optional[str]
    #: Start date and time (inclusive) of the Network Test data.
    from: Optional[str]
    #: End date and time (inclusive) of the Network Test data.
    to: Optional[str]
    #: Network test results.
    items: Optional[list[ConnectivityTestResultsClustersObject3]]


class VideoMeshApi(ApiChild, base='videoMesh/'):
    """
    The Video Mesh Developer APIs provide the ability for organization admins to retrieve analytics and monitoring
    data, trigger on-demand troubleshooting tests (Media Health Monitoring Tool, Network, and Reachability) from the
    Developer Portal or their own monitoring application, which can help in quickly isolating and identifying root
    cause of issues which affect normal functioning of a customer's Video Mesh Deployment.
    NOTE: The Media Health Monitor Test and Reachability Test can be triggered only on clusters that are not reserved
    for private meetings.
    To obtain the Organization ID needed for these APIs, use the Organizations API
    """

    def list_clusters_availability(self, from_: str, to_: str, org_id: str) -> list[ClusterAvailabilityCollection]:
        """
        Returns the availability details for all Video Mesh clusters in an organization.

        :param from_: The starting date and time of the requested data in any ISO 8601 compliant format. from cannot be
            after to.
        :type from_: str
        :param to_: The ending date and time of the requested data in any ISO 8601 compliant format.
        :type to_: str
        :param org_id: The unique ID for the organization.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/video-mesh/list-clusters-availability
        """
        params = {}
        params['from'] = from_
        params['to'] = to_
        params['orgId'] = org_id
        url = self.ep('clusters/availability')
        data = super().get(url=url, params=params)
        return parse_obj_as(list[ClusterAvailabilityCollection], data["items"])

    def cluster_availability(self, cluster_id: str, from_: str, to_: str) -> list[ClusterAvailabilityCollection]:
        """
        Returns the availability details of a single Video Mesh cluster in an organization.

        :param cluster_id: The unique Video Mesh clusterID
        :type cluster_id: str
        :param from_: The starting date and time of the requested data in any ISO 8601 compliant format. from cannot be
            after to.
        :type from_: str
        :param to_: The ending date and time of the requested data in any ISO 8601 compliant format.
        :type to_: str

        documentation: https://developer.webex.com/docs/api/v1/video-mesh/get-cluster-availability
        """
        params = {}
        params['from'] = from_
        params['to'] = to_
        url = self.ep(f'clusters/availability/{cluster_id}')
        data = super().get(url=url, params=params)
        return parse_obj_as(list[ClusterAvailabilityCollection], data["items"])

    def list_node_availability(self, from_: str, to_: str, cluster_id: str) -> list[NodeAvailabilityCollection]:
        """
        Returns the availability details of all nodes in a Video Mesh cluster.

        :param from_: The starting date and time of the requested data in any ISO 8601 compliant format. from cannot be
            after to.
        :type from_: str
        :param to_: The ending date and time of the requested data in any ISO 8601 compliant format.
        :type to_: str
        :param cluster_id: The unique Video Mesh cluster ID.
        :type cluster_id: str

        documentation: https://developer.webex.com/docs/api/v1/video-mesh/list-node-availability
        """
        params = {}
        params['from'] = from_
        params['to'] = to_
        params['clusterId'] = cluster_id
        url = self.ep('nodes/availability')
        data = super().get(url=url, params=params)
        return parse_obj_as(list[NodeAvailabilityCollection], data["items"])

    def node_availability(self, node_id: str, from_: str, to_: str) -> list[SingleNodeAvailabilityCollection]:
        """
        Returns the availability details of a single node in a Video Mesh cluster.

        :param node_id: The unique Video Mesh node ID.
        :type node_id: str
        :param from_: The starting date and time of the requested data in any ISO 8601 compliant format. from cannot be
            after to.
        :type from_: str
        :param to_: The ending date and time of the requested data in any ISO 8601 compliant format.
        :type to_: str

        documentation: https://developer.webex.com/docs/api/v1/video-mesh/get-node-availability
        """
        params = {}
        params['from'] = from_
        params['to'] = to_
        url = self.ep(f'nodes/availability/{node_id}')
        data = super().get(url=url, params=params)
        return parse_obj_as(list[SingleNodeAvailabilityCollection], data["items"])

    def list_media_health_monitoring_tool_results(self, from_: str, to_: str, org_id: str) -> list[MediaHealthMonitoringResultsCollectionfororganization]:
        """
        Returns the test results of the Media Health Monitoring Tool tests for an organization.

        :param from_: The starting date and time of the requested data in any ISO 8601 compliant format. from cannot be
            after to. from must not be older than 1 week.
        :type from_: str
        :param to_: The ending date and time of the requested data in any ISO 8601 compliant format.
        :type to_: str
        :param org_id: The unique Video Mesh organization ID.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/video-mesh/list-media-health-monitoring-tool-results
        """
        params = {}
        params['from'] = from_
        params['to'] = to_
        params['orgId'] = org_id
        url = self.ep('mediaHealthMonitor')
        data = super().get(url=url, params=params)
        return parse_obj_as(list[MediaHealthMonitoringResultsCollectionfororganization], data["items"])

    def list_media_health_monitoring_tool_test_results_v2(self, org_id: str, from_: str, to_: str, trigger_type: str) -> MediaHealthMonitoringResultsCollectionfororganization:
        """
        Returns the test results of the Media Health Monitoring Tool tests for an organization.
        Changes in V2:
        On-demand test results can be obtained along with the periodic tests that are executed on Video Mesh nodes.

        :param org_id: Unique ID of the organization.
        :type org_id: str
        :param from_: The start date and time of the requested data in any ISO 8601 compliant format. The from
            parameter cannot have date and time values that exceed to.
        :type from_: str
        :param to_: The end date and time of the requested data in any ISO 8601 compliant format.
        :type to_: str
        :param trigger_type: Trigger type. Possible values: OnDemand, Periodic, All
        :type trigger_type: str

        documentation: https://developer.webex.com/docs/api/v1/video-mesh/list-media-health-monitoring-tool-test-results-v2
        """
        params = {}
        params['orgId'] = org_id
        params['from'] = from_
        params['to'] = to_
        params['triggerType'] = trigger_type
        url = self.ep('testResults/mediaHealthMonitorTest')
        data = super().get(url=url, params=params)
        return MediaHealthMonitoringResultsCollectionfororganization.parse_obj(data)

    def media_health_monitoring_tool_cluster_results(self, from_: str, to_: str, cluster_id: str) -> list[MediaHealthMonitoringResultsCollectionforcluster]:
        """
        Returns the test results of the Media Health Monitoring Tool tests for a single Video Mesh cluster.

        :param from_: The starting date and time of the requested data in any ISO 8601 compliant format. from cannot be
            after to. from must not be older than 1 week.
        :type from_: str
        :param to_: The ending date and time of the requested data in any ISO 8601 compliant format.
        :type to_: str
        :param cluster_id: The unique Video Mesh Cluster ID.
        :type cluster_id: str

        documentation: https://developer.webex.com/docs/api/v1/video-mesh/get-media-health-monitoring-tool-cluster-results
        """
        params = {}
        params['from'] = from_
        params['to'] = to_
        params['clusterId'] = cluster_id
        url = self.ep('mediaHealthMonitor/clusters')
        data = super().get(url=url, params=params)
        return parse_obj_as(list[MediaHealthMonitoringResultsCollectionforcluster], data["items"])

    def media_health_monitoring_tool_test_results_for_clusters_v2(self, cluster_id: str, from_: str, to_: str, trigger_type: str) -> MediaHealthMonitoringResultsCollectionforcluster:
        """
        Returns the test results of the Media Health Monitoring Tool tests for a single Video Mesh cluster.
        Changes in V2:
        On-demand test results can be obtained along with the periodic tests that are executed on Video Mesh nodes.

        :param cluster_id: Unique ID of the Video Mesh cluster.
        :type cluster_id: str
        :param from_: The start date and time of the requested data in any ISO 8601 compliant format. The from
            parameter cannot have date and time values that exceed to.
        :type from_: str
        :param to_: The end date and time of the requested data in any ISO 8601 compliant format.
        :type to_: str
        :param trigger_type: Trigger type. Possible values: OnDemand, Periodic, All
        :type trigger_type: str

        documentation: https://developer.webex.com/docs/api/v1/video-mesh/get-media-health-monitoring-tool-test-results-for-clusters-v2
        """
        params = {}
        params['clusterId'] = cluster_id
        params['from'] = from_
        params['to'] = to_
        params['triggerType'] = trigger_type
        url = self.ep('testResults/mediaHealthMonitorTest/clusters')
        data = super().get(url=url, params=params)
        return MediaHealthMonitoringResultsCollectionforcluster.parse_obj(data)

    def media_health_monitoring_tool_node_results(self, from_: str, to_: str, node_id: str) -> list[MediaHealthMonitoringResultsCollectionfornode]:
        """
        Returns the test results of the Media Health Monitoring Tool tests for a single Video Mesh node.

        :param from_: The starting date and time of the requested data in any ISO 8601 compliant format. from cannot be
            after to. from must not be older than 1 week.
        :type from_: str
        :param to_: The ending date and time of the requested data in any ISO 8601 compliant format.
        :type to_: str
        :param node_id: The unique Video Mesh Node ID.
        :type node_id: str

        documentation: https://developer.webex.com/docs/api/v1/video-mesh/get-media-health-monitoring-tool-node-results
        """
        params = {}
        params['from'] = from_
        params['to'] = to_
        params['nodeId'] = node_id
        url = self.ep('mediaHealthMonitor/nodes')
        data = super().get(url=url, params=params)
        return parse_obj_as(list[MediaHealthMonitoringResultsCollectionfornode], data["items"])

    def media_health_monitoring_tool_test_results_for_node_v2(self, node_id: str, from_: str, to_: str, trigger_type: str) -> MediaHealthMonitoringResultsCollectionfornode:
        """
        Returns the test results of the Media Health Monitoring Tool tests for a single Video Mesh node.
        Changes in V2:
        On-demand test results can be obtained along with the periodic tests that are executed on Video Mesh nodes.

        :param node_id: Unique ID of the Video Mesh node.
        :type node_id: str
        :param from_: The start date and time of the requested data in any ISO 8601 compliant format. The from
            parameter cannot have date and time values that exceed to.
        :type from_: str
        :param to_: The end date and time of the requested data in any ISO 8601 compliant format.
        :type to_: str
        :param trigger_type: Trigger type. Possible values: OnDemand, Periodic, All
        :type trigger_type: str

        documentation: https://developer.webex.com/docs/api/v1/video-mesh/get-media-health-monitoring-tool-test-results-for-node-v2
        """
        params = {}
        params['nodeId'] = node_id
        params['from'] = from_
        params['to'] = to_
        params['triggerType'] = trigger_type
        url = self.ep('testResults/mediaHealthMonitorTest/nodes')
        data = super().get(url=url, params=params)
        return MediaHealthMonitoringResultsCollectionfornode.parse_obj(data)

    def list_overflow_to_cloud_details(self, from_: str, to_: str, org_id: str) -> list[OverflowtoCloudCollection]:
        """
        Returns details of overflows to the cloud in an organization.

        :param from_: The starting date and time of the requested data in any ISO 8601 compliant format. from cannot be
            after to.
        :type from_: str
        :param to_: The ending date and time of the requested data in any ISO 8601 compliant format.
        :type to_: str
        :param org_id: The unique Video Mesh organization ID.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/video-mesh/list-overflow-to-cloud-details
        """
        params = {}
        params['from'] = from_
        params['to'] = to_
        params['orgId'] = org_id
        url = self.ep('cloudOverflow')
        data = super().get(url=url, params=params)
        return parse_obj_as(list[OverflowtoCloudCollection], data["items"])

    def list_cluster_redirect_details(self, from_: str, to_: str, org_id: str) -> list[RedirectCollectionForOrg]:
        """
        Returns the redirect details of all Video Mesh clusters in an organization.

        :param from_: The starting date and time of the requested data in any ISO 8601 compliant format. from cannot be
            after to.
        :type from_: str
        :param to_: The ending date and time of the requested data in any ISO 8601 compliant format.
        :type to_: str
        :param org_id: The unique Video Mesh organization ID.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/video-mesh/list-cluster-redirect-details
        """
        params = {}
        params['from'] = from_
        params['to'] = to_
        params['orgId'] = org_id
        url = self.ep('callRedirects')
        data = super().get(url=url, params=params)
        return parse_obj_as(list[RedirectCollectionForOrg], data["items"])

    def cluster_redirect_details(self, from_: str, to_: str, cluster_id: str) -> list[RedirectCollectionForCluster]:
        """
        Returns details of cluster redirects for a single Video Mesh cluster.

        :param from_: The starting date and time of the requested data in any ISO 8601 compliant format. from cannot be
            after to.
        :type from_: str
        :param to_: The ending date and time of the requested data in any ISO 8601 compliant format.
        :type to_: str
        :param cluster_id: The unique Video Mesh Cluster ID.
        :type cluster_id: str

        documentation: https://developer.webex.com/docs/api/v1/video-mesh/get-cluster-redirect-details
        """
        params = {}
        params['from'] = from_
        params['to'] = to_
        params['clusterId'] = cluster_id
        url = self.ep('clusters/callRedirects')
        data = super().get(url=url, params=params)
        return parse_obj_as(list[RedirectCollectionForCluster], data["items"])

    def list_clusters_utilization(self, from_: str, to_: str, org_id: str) -> list[ClusterUtilizationCollection]:
        """
        Returns the utilization details of all Video Mesh clusters in an organization.

        :param from_: The starting date and time of the requested data in any ISO 8601 compliant format. from cannot be
            after to.
        :type from_: str
        :param to_: The ending date and time of the requested data in any ISO 8601 compliant format.
        :type to_: str
        :param org_id: The unique ID for the organization.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/video-mesh/list-clusters-utilization
        """
        params = {}
        params['from'] = from_
        params['to'] = to_
        params['orgId'] = org_id
        url = self.ep('utilization')
        data = super().get(url=url, params=params)
        return parse_obj_as(list[ClusterUtilizationCollection], data["items"])

    def cluster_utilization_details(self, from_: str, to_: str, cluster_id: str) -> list[UtilizationForClusterCollection]:
        """
        Returns the utilization details for a single Video Mesh cluster.

        :param from_: The starting date and time of the requested data in any ISO 8601 compliant format. from cannot be
            after to.
        :type from_: str
        :param to_: The ending date and time of the requested data in any ISO 8601 compliant format.
        :type to_: str
        :param cluster_id: The unique Video Mesh Cluster ID.
        :type cluster_id: str

        documentation: https://developer.webex.com/docs/api/v1/video-mesh/get-cluster-utilization-details
        """
        params = {}
        params['from'] = from_
        params['to'] = to_
        params['clusterId'] = cluster_id
        url = self.ep('clusters/utilization')
        data = super().get(url=url, params=params)
        return parse_obj_as(list[UtilizationForClusterCollection], data["items"])

    def list_reachability_test_results(self, from_: str, to_: str, org_id: str) -> list[ReachabilityTestresultsfororganization]:
        """
        Returns the test results of the Reachability tests for an organization.

        :param from_: The starting date and time of the requested data in any ISO 8601 compliant format. from cannot be
            after to. from must not be older than 1 week.
        :type from_: str
        :param to_: The ending date and time of the requested data in any ISO 8601 compliant format.
        :type to_: str
        :param org_id: The unique ID for the organization.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/video-mesh/list-reachability-test-results
        """
        params = {}
        params['from'] = from_
        params['to'] = to_
        params['orgId'] = org_id
        url = self.ep('reachabilityTest')
        data = super().get(url=url, params=params)
        return parse_obj_as(list[ReachabilityTestresultsfororganization], data["items"])

    def list_reachability_test_results_v2(self, org_id: str, from_: str, to_: str, trigger_type: str) -> ReachabilityTestresultsfororganization:
        """
        Returns the test results of the Reachability tests for an organization.
        Changes in V2:

        :param org_id: Unique ID of the organization.
        :type org_id: str
        :param from_: The start date and time of the requested data in any ISO 8601 compliant format. The from
            parameter cannot have date and time values that exceed to.
        :type from_: str
        :param to_: The end date and time of the requested data in any ISO 8601 compliant format.
        :type to_: str
        :param trigger_type: Trigger type. Possible values: OnDemand, Periodic, All
        :type trigger_type: str

        documentation: https://developer.webex.com/docs/api/v1/video-mesh/list-reachability-test-results-v2
        """
        params = {}
        params['orgId'] = org_id
        params['from'] = from_
        params['to'] = to_
        params['triggerType'] = trigger_type
        url = self.ep('testResults/reachabilityTest')
        data = super().get(url=url, params=params)
        return ReachabilityTestresultsfororganization.parse_obj(data)

    def reachability_test_results_for_cluster(self, from_: str, to_: str, cluster_id: str) -> list[ReachabilityTestresultsforcluster]:
        """
        Returns the test results of the Reachability tests for a single Video Mesh cluster.

        :param from_: The starting date and time of the requested data in any ISO 8601 compliant format. from cannot be
            after to. from must not be older than 1 week.
        :type from_: str
        :param to_: The ending date and time of the requested data in any ISO 8601 compliant format.
        :type to_: str
        :param cluster_id: The unique Video Mesh Cluster ID.
        :type cluster_id: str

        documentation: https://developer.webex.com/docs/api/v1/video-mesh/get-reachability-test-results-for-cluster
        """
        params = {}
        params['from'] = from_
        params['to'] = to_
        params['clusterId'] = cluster_id
        url = self.ep('reachabilityTest/clusters')
        data = super().get(url=url, params=params)
        return parse_obj_as(list[ReachabilityTestresultsforcluster], data["items"])

    def reachability_test_results_for_cluster_v2(self, cluster_id: str, from_: str, to_: str, trigger_type: str) -> ReachabilityTestresultsforcluster:
        """
        Returns the test results of the Reachability tests for a single Video Mesh cluster.
        Changes in V2:

        :param cluster_id: Unique ID of the Video Mesh cluster.
        :type cluster_id: str
        :param from_: The start date and time of the requested data in any ISO 8601 compliant format. The from
            parameter cannot have date and time values that exceed to.
        :type from_: str
        :param to_: The end date and time of the requested data in any ISO 8601 compliant format.
        :type to_: str
        :param trigger_type: Trigger type. Possible values: OnDemand, Periodic, All
        :type trigger_type: str

        documentation: https://developer.webex.com/docs/api/v1/video-mesh/get-reachability-test-results-for-cluster-v2
        """
        params = {}
        params['clusterId'] = cluster_id
        params['from'] = from_
        params['to'] = to_
        params['triggerType'] = trigger_type
        url = self.ep('testResults/reachabilityTest/clusters')
        data = super().get(url=url, params=params)
        return ReachabilityTestresultsforcluster.parse_obj(data)

    def reachability_test_results_for_node(self, from_: str, to_: str, node_id: str) -> list[ReachabilityTestresultsfornode]:
        """
        Returns the test results of the Reachability tests for a single Video Mesh node.

        :param from_: The starting date and time of the requested data in any ISO 8601 compliant format. from cannot be
            after to. from must not be older than 1 week.
        :type from_: str
        :param to_: The ending date and time of the requested data in any ISO 8601 compliant format.
        :type to_: str
        :param node_id: The unique Video Mesh node ID.
        :type node_id: str

        documentation: https://developer.webex.com/docs/api/v1/video-mesh/get-reachability-test-results-for-node
        """
        params = {}
        params['from'] = from_
        params['to'] = to_
        params['nodeId'] = node_id
        url = self.ep('reachabilityTest/nodes')
        data = super().get(url=url, params=params)
        return parse_obj_as(list[ReachabilityTestresultsfornode], data["items"])

    def reachability_test_results_for_node_v2(self, node_id: str, from_: str, to_: str, trigger_type: str) -> ReachabilityTestresultsfornode:
        """
        Returns the test results of the Reachability tests for a single Video Mesh node.
        Changes in V2:

        :param node_id: Unique ID of the Video Mesh node.
        :type node_id: str
        :param from_: The start date and time of the requested data in any ISO 8601 compliant format. The from
            parameter cannot have date and time values that exceed to.
        :type from_: str
        :param to_: The end date and time of the requested data in any ISO 8601 compliant format.
        :type to_: str
        :param trigger_type: Trigger type. Possible values: OnDemand, Periodic, All
        :type trigger_type: str

        documentation: https://developer.webex.com/docs/api/v1/video-mesh/get-reachability-test-results-for-node-v2
        """
        params = {}
        params['nodeId'] = node_id
        params['from'] = from_
        params['to'] = to_
        params['triggerType'] = trigger_type
        url = self.ep('testResults/reachabilityTest/nodes')
        data = super().get(url=url, params=params)
        return ReachabilityTestresultsfornode.parse_obj(data)

    def list_cluster_details(self, org_id: str) -> list[ClusterDetailsCollection]:
        """
        Returns the cluster details of all Video Mesh clusters in an organization.

        :param org_id: The unique ID for the organization.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/video-mesh/list-cluster-details
        """
        params = {}
        params['orgId'] = org_id
        url = self.ep('clusters')
        data = super().get(url=url, params=params)
        return parse_obj_as(list[ClusterDetailsCollection], data["items"])

    def cluster_details(self, cluster_id: str) -> list[ClusterDetailsCollection]:
        """
        Returns the cluster details for a single Video Mesh cluster.

        :param cluster_id: The unique Video Mesh Cluster ID.
        :type cluster_id: str

        documentation: https://developer.webex.com/docs/api/v1/video-mesh/get-cluster-details
        """
        url = self.ep(f'clusters/{cluster_id}')
        data = super().get(url=url)
        return parse_obj_as(list[ClusterDetailsCollection], data["items"])

    def trigger_on_demand_test_for_cluster(self, cluster_id: str, type_: Type32 = None, nodes: List[str] = None) -> TriggerOndemandTestForClusterResponse:
        """
        Triggers an on-demand test for a cluster.
        The test is run on a maximum of 10 nodes present in the cluster, chosen at random, or based on input from the
        user.

        :param cluster_id: Unique ID of the Video Mesh cluster.
        :type cluster_id: str
        :param type_: Test type to trigger on node.
        :type type_: Type32
        :param nodes: List of nodes to test. Possible values:
            Y2lzY29zcGFyazovL3VzL0hZQlJJRF9DT05ORUNUT1IvMmMzYzlmOWUtNzNkOS00NDYwLWE2NjgtMDQ3MTYyZmYxYmFjOjE1NmRmNzg5Yzg1NTRkNTVhMjc1ZGU5OTc4Zjk5MDJk,
            Y2lzY29zcGFyazovL3VzL0hZQlJJRF9DT05ORUNUT1IvMmMzYzlmOWUtNzNkOS00NDYwLWE2NjgtMDQ3MTYyZmYxYmFjOjE1NmRmNzg5Yzg1NTRhYmNhZGVmZ2U5OTc4Zjk5MDJk
        :type nodes: List[str]

        documentation: https://developer.webex.com/docs/api/v1/video-mesh/trigger-on-demand-test-for-cluster
        """
        body = TriggerOndemandTestForClusterBody()
        if type_ is not None:
            body.type_ = type_
        if nodes is not None:
            body.nodes = nodes
        url = self.ep(f'triggerTest/clusters/{cluster_id}')
        data = super().post(url=url, data=body.json())
        return TriggerOndemandTestForClusterResponse.parse_obj(data)

    def trigger_on_demand_test_for_node(self, node_id: str, type_: Type32 = None) -> TriggerOndemandTestForClusterResponse:
        """
        Triggers an on-demand test for a node.

        :param node_id: Unique ID of the Video Mesh node.
        :type node_id: str
        :param type_: Test type to trigger on node.
        :type type_: Type32

        documentation: https://developer.webex.com/docs/api/v1/video-mesh/trigger-on-demand-test-for-node
        """
        body = TriggerOndemandTestForNodeBody()
        if type_ is not None:
            body.type_ = type_
        url = self.ep(f'triggerTest/nodes/{node_id}')
        data = super().post(url=url, data=body.json())
        return TriggerOndemandTestForClusterResponse.parse_obj(data)

    def triggered_test_status(self, command_id: str) -> TriggerOndemandTestForClusterResponse:
        """
        Returns the status of the test triggered using the Trigger on-demand test API.

        :param command_id: The unique command ID generated from Trigger on-demand test API.
        :type command_id: str

        documentation: https://developer.webex.com/docs/api/v1/video-mesh/get-triggered-test-status
        """
        params = {}
        params['commandId'] = command_id
        url = self.ep('testStatus')
        data = super().get(url=url, params=params)
        return TriggerOndemandTestForClusterResponse.parse_obj(data)

    def triggered_test_results(self, command_id: str) -> GetTriggeredTestResultsResponse:
        """
        Returns the results of the test triggered using the command ID.NOTE: The response format depends on the type of
        test triggered and it is the same as that of NetworkTest API, MediaHealthMonitorTest API, and ReachabilityTest
        API respectively.

        :param command_id: The unique command ID generated from Trigger on-demand test API.
        :type command_id: str

        documentation: https://developer.webex.com/docs/api/v1/video-mesh/get-triggered-test-results
        """
        params = {}
        params['commandId'] = command_id
        url = self.ep('testResults')
        data = super().get(url=url, params=params)
        return GetTriggeredTestResultsResponse.parse_obj(data)

    def list_network_test_results(self, org_id: str, from_: str, to_: str, trigger_type: str) -> ListNetworkTestResultsResponse:
        """
        Returns the test results of the Network tests triggered for an organization. The tests listed below are run as
        a part of the Network Test execution on the node.
        Bandwidth Test - Tests the bandwidth parameters of the Video Mesh node's network. The test is run between the
        Video Mesh node and cloud services.DNS Resolution Test - Tests the resolution of IP addresses related to cloud
        services, against the DNS servers configured on the Video Mesh node's network.HTTPS Connectivity Test - Tests
        whether the Video Mesh node is able to connect to cloud services via HTTPS protocol.Websocket Connectivity Test
        - Tests whether the Video Mesh node is able to connect to Webex cloud services via Websocket.

        :param org_id: Unique ID of the organization.
        :type org_id: str
        :param from_: The start date and time of the requested data in any ISO 8601 compliant format. The from
            parameter cannot have date and time values that exceed to.
        :type from_: str
        :param to_: The end date and time of the requested data in any ISO 8601 compliant format.
        :type to_: str
        :param trigger_type: Trigger type. Possible values: OnDemand, Periodic, All
        :type trigger_type: str

        documentation: https://developer.webex.com/docs/api/v1/video-mesh/list-network-test-results
        """
        params = {}
        params['orgId'] = org_id
        params['from'] = from_
        params['to'] = to_
        params['triggerType'] = trigger_type
        url = self.ep('testResults/networkTest')
        data = super().get(url=url, params=params)
        return ListNetworkTestResultsResponse.parse_obj(data)

    def network_test_results_for_cluster(self, cluster_id: str, from_: str, to_: str, trigger_type: str) -> GetNetworkTestResultsForClusterResponse:
        """
        Returns the test results of the Network tests triggered for a single Video Mesh cluster. The tests listed below
        are run as a part of the Network Test execution on the node.
        Bandwidth Test - Tests the bandwidth parameters of the Video Mesh node's network. The test is run between the
        Video Mesh node and cloud services.DNS Resolution Test - Tests the resolution of IP addresses related to cloud
        services, against the DNS servers configured on the Video Mesh node's network.HTTPS Connectivity Test - Tests
        whether the Video Mesh node is able to connect to cloud services via HTTPS protocol.Websocket Connectivity Test
        - Tests whether the Video Mesh node is able to connect to Webex cloud services via Websocket.

        :param cluster_id: Unique ID of the Video Mesh cluster.
        :type cluster_id: str
        :param from_: The start date and time of the requested data in any ISO 8601 compliant format. The from
            parameter cannot have date and time values that exceed to.
        :type from_: str
        :param to_: The end date and time of the requested data in any ISO 8601 compliant format.
        :type to_: str
        :param trigger_type: Trigger type. Possible values: OnDemand, Periodic, All
        :type trigger_type: str

        documentation: https://developer.webex.com/docs/api/v1/video-mesh/get-network-test-results-for-cluster
        """
        params = {}
        params['clusterId'] = cluster_id
        params['from'] = from_
        params['to'] = to_
        params['triggerType'] = trigger_type
        url = self.ep('testResults/networkTest/clusters')
        data = super().get(url=url, params=params)
        return GetNetworkTestResultsForClusterResponse.parse_obj(data)

    def network_test_results_for_node(self, node_id: str, from_: str, to_: str, trigger_type: str) -> GetNetworkTestResultsForNodeResponse:
        """
        Returns the test results of the Network tests triggered for a single Video Mesh node. The tests listed below
        are run as a part of the Network Test execution on the node.
        Bandwidth Test - Tests the bandwidth parameters of the Video Mesh node's network. The test is run between the
        Video Mesh node and cloud services.DNS Resolution Test - Tests the resolution of IP addresses related to cloud
        services, against the DNS servers configured on the Video Mesh node's network.HTTPS Connectivity Test - Tests
        whether the Video Mesh node is able to connect to cloud services via HTTPS protocol.Websocket Connectivity Test
        - Tests whether the Video Mesh node is able to connect to Webex cloud services via Websocket.

        :param node_id: Unique ID of the Video Mesh node.
        :type node_id: str
        :param from_: The start date and time of the requested data in any ISO 8601 compliant format. The from
            parameter cannot have date and time values that exceed to.
        :type from_: str
        :param to_: The end date and time of the requested data in any ISO 8601 compliant format.
        :type to_: str
        :param trigger_type: Trigger type. Possible values: OnDemand, Periodic, All
        :type trigger_type: str

        documentation: https://developer.webex.com/docs/api/v1/video-mesh/get-network-test-results-for-node
        """
        params = {}
        params['nodeId'] = node_id
        params['from'] = from_
        params['to'] = to_
        params['triggerType'] = trigger_type
        url = self.ep('testResults/networkTest/nodes')
        data = super().get(url=url, params=params)
        return GetNetworkTestResultsForNodeResponse.parse_obj(data)

class CDR(ApiModel):
    #: The time the call was answered. Time is in UTC.
    answer_time: Optional[str] = Field(alias='Answer time')
    #: Whether the call leg was answered. For example, in a hunt group case, some legs will be unanswered, and one will
    #: be answered.
    answered: Optional[str]
    #: The authorization code admin created for a location or site for users to use. Collected by the
    #: Account/Authorization Codes or Enhanced Outgoing Calling Plan services.
    authorization_code: Optional[str] = Field(alias='Authorization code')
    #: SIP Call ID used to identify the call. You can share the Call ID with Cisco TAC to help them pinpoint a call if
    #: necessary.
    call_id: Optional[str] = Field(alias='Call ID')
    #: Type of call. For example:
    #:   * SIP_MEETING
    #:   * SIP_INTERNATIONAL
    #:   * SIP_SHORTCODE
    #:   * SIP_INBOUND
    #:   * UNKNOWN
    #:   * SIP_EMERGENCY
    #:   * SIP_PREMIUM
    #:   * SIP_ENTERPRISE
    #:   * SIP_TOLLFREE
    #:   * SIP_NATIONAL
    #:   * SIP_MOBILE
    call_type: Optional[str] = Field(alias='Call type')
    #: For incoming calls, the calling line ID of the user. For outgoing calls, it's the calling line ID of the called
    #: party.
    called_line_id: Optional[str] = Field(alias='Called line ID')
    #: For incoming calls, the telephone number of the user. For outgoing calls, it's the telephone number of the
    #: called party.
    called_number: Optional[str] = Field(alias='Called number')
    #: For incoming calls, the calling line ID of the calling party. For outgoing calls, it's the calling line ID of
    #: the user.
    calling_line_id: Optional[str] = Field(alias='Calling line ID')
    #: For incoming calls, the telephone number of the calling party. For outgoing calls, it's the telephone number of
    #: the user.
    calling_number: Optional[str] = Field(alias='Calling number')
    #: The type of client that the user (creating this record) is using to make or receive the call. For example:
    #:   * SIP
    #:   * WXC_CLIENT
    #:   * WXC_THIRD_PARTY
    #:   * TEAMS_WXC_CLIENT
    #:   * WXC_DEVICE
    #:   * WXC_SIP_GW
    client_type: Optional[str] = Field(alias='Client type')
    #: The version of the client that the user (creating this record) is using to make or receive the call.
    client_version: Optional[str] = Field(alias='Client version')
    #: Correlation ID to tie together multiple call legs of the same call session.
    correlation_id: Optional[str] = Field(alias='Correlation ID')
    #: A unique identifier for the user's department name.
    department_id: Optional[str] = Field(alias='Department ID')
    #: The MAC address of the device, if known.
    device_mac: Optional[str] = Field(alias='Device MAC')
    #: The keypad digits as dialed by the user, before pre-translations.
    #: This field reports multiple call dial possibilities:
    #:   * Feature access codes (FAC) used for invoking features such as Last Number Redial or a Call Return.
    #:   * An extension that got dialed and a mis-dialed keypad digit from a device/app.
    #:   * When a user must dial an outside access code (for example, 9+) before dialing a number, this access code is
    #:     also reported, as well as the digits dialed thereafter.
    #: Note that when pre-translations have no effect, the dialed digits field contains the same data as the called
    #: number field.
    #: This field is only used for originating (outgoing) Calls and is not available for terminating (incoming) Calls.
    dialed_digits: Optional[str] = Field(alias='Dialed digits')
    #: Whether the call was inbound or outbound. The possible values are:
    #:   * ORIGINATING
    #:   * TERMINATING
    direction: Optional[str]
    #: The length of the call in seconds.
    duration: Optional[int]
    #: Inbound trunk may be presented in Originating and Terminating records.
    inbound_trunk: Optional[str] = Field(alias='Inbound trunk')
    #: The country code of the dialed number. This is only populated for international calls.
    international_country: Optional[str] = Field(alias='International country')
    #: The Session ID comprises a Universally Unique Identifier (UUID) for each user-agent participating in a call. It
    #: can be used for end-to-end tracking of a SIP session in IP-based multimedia communication. Each call consists of
    #: two UUIDs known as Local Session ID and Remote Session ID.
    #:   * The Local SessionID is generated from the Originating user agent.
    local_session_id: Optional[str] = Field(alias='Local SessionID')
    #: Location of the report.
    location: Optional[str]
    #: The device model type the user is using to make or receive the call.
    model: Optional[str]
    #: A unique identifier for the organization that made the call. This is a unique identifier across Cisco.
    org_uuid: Optional[str] = Field(alias='Org UUID')
    #: Call redirection reason for the original called number. For example:
    #:   * Unconditional: Call Forward Always (CFA) service, Group night forwarding.
    #:   * NoAnswer: The party was not available to take the call. CF/busy or Voicemail/busy.
    #:   * Deflection: Indicates that a call was redirected. Possible causes could be auto attendant transfer, transfer
    #:     out of a call-center, user’s app/device redirection, direct VM transfer etc..
    #:   * TimeOfDay: Call scheduled period of automated redirection. CF/selective, group night forwarding.
    #:   * UserBusy: DND enabled or the user willingly declined the call. CF/busy or voicemail/busy.
    #:   * FollowMe: Automated redirection to a personal redirecting service.
    #:   * CallQueue: A call center call to an agent or a user (a member of the call queue).
    #:   * HuntGroup: A hunt-group-based call to an agent or a user (denotes a member of the hunt group).
    #:   * Unavailable: To voicemail, when the user has no app or device.
    #:   * Unrecognized: Unable to determine the reason.
    #:   * Unknown: Call forward by phone with no reason.
    original_reason: Optional[str] = Field(alias='Original reason')
    #: The operating system that the app was running on, if available.
    os_type: Optional[str] = Field(alias='OS type')
    #: Outbound trunk may be presented in Originating and Terminating records.
    outbound_trunk: Optional[str] = Field(alias='Outbound trunk')
    #: Call Redirection Reason for the redirecting number. For example:
    #:   * Unconditional: Call Forward Always (CFA) service.
    #:   * NoAnswer: The party was not available to take the call. CF/busy or Voicemail/busy.
    #:   * Deflection: Indicates that a call was redirected. Possible causes could be auto attendant transfer, transfer
    #:     out of a call-center, user’s app/device redirection, direct VM transfer etc..
    #:   * TimeOfDay: Call scheduled period of automated redirection. CF/Selective.
    #:   * UserBusy: DND enabled or user willingly declined the call. CF/busy or Voicemail/busy.
    #:   * FollowMe: Automated redirection to a personal redirecting service.
    #:   * CallQueue: A call center call to an agent or a user (denotes a member of the call queue).
    #:   * HuntGroup: A hunt-group-based call to an agent or a user (denotes a member of the hunt group).
    #:   * Unavailable: To voicemail, when the user has no app or device.
    #:   * Unrecognized: Unable to determine the reason.
    #:   * Unknown: Call forward by phone with no reason.
    redirect_reason: Optional[str] = Field(alias='Redirect reason')
    #: When the call has been redirected one or more times, this field reports the last redirecting number. Identifies
    #: who last redirected the call. Only applies to call scenarios such as transfer, call forwarded calls,
    #: simultaneous rings, etc.
    redirecting_number: Optional[str] = Field(alias='Redirecting number')
    #: Indicates a trigger that led to a change in the call presence. The trigger could be for this particular call or
    #: redirected via a different call. For example:
    #:   * ConsultativeTransfer: While on a call, the call was transferred to another user by announcing it first.
    #:     meaning the person was given a heads up or asked if they're interested in taking the call and then
    #:     transferred.
    #:   * CallForwardSelective: Call Forward as per the defined schedule. Might be based on factors like a specific
    #:     time, specific callers or to a VM. It always takes precedence over Call Forwarding.
    #:   * CallForwardAlways: Calls are unconditionally forwarded to a defined phone number or to VM.
    #:   * CallForwardNoAnswer: The party was not available to take the call.
    #:   * CallQueue: A call center call to an agent or a user (denotes a member of the call queue).
    #:   * HuntGroup: A hunt group based call to an agent or a user (denotes a member of the hunt group).
    #:   * CallPickup: The user part of a pickup group or pickup attempted by this user against a ringing call for a
    #:     different user or extension.
    #:   * CalllPark: An ongoing call was parked, assigned with a parked number (not the user’s phone number).
    #:   * CallParkRetrieve: Call park retrieval attempt by the user, either for a different extension or against the
    #:     user’s own extension.
    #:   * Deflection: Indicates that a call was redirected. Possible causes include an auto attendant transfer,
    #:     transfer out of a call-center, user’s app/device redirection etc..
    #:   * FaxDeposit: Indicates a FAX was transmitted to the FAX service.
    #:   * PushNotificationRetrieval: Push notification feature usage indication. Means that a push notification was
    #:     sent to wake up the client and get ready to receive a call.
    #:   * BargeIn: Indicates the user barged-in to someone else’s call.
    #:   * VoiceXMLScriptTermination: Route Point feature usage indication.
    #:   * AnywhereLocation: Indicates call origination towards the single number reach location.
    #:   * AnywherePortal: Indicates call origination towards the “user” identified by the single number reach portal.
    #:   * Unrecognized: Unable to determine the reason.
    related_reason: Optional[str] = Field(alias='Related reason')
    #: Indicates which party released the call first. The possible values are:
    #:   * Local: Used when the local user has released the call first.
    #:   * Remote: Used when the far-end party releases the call first.
    #:   * Unknown: Used when the call has partial information or is unable to gather enough information about the
    #:     party who released the call. It could be because of situations like force lock or because of a session audit
    #:     failure.
    releasing_party: Optional[str] = Field(alias='Releasing party')
    #: The Session ID comprises a Universally Unique Identifier (UUID) for each user-agent participating in a call. It
    #: can be used for end-to-end tracking of a SIP session in IP-based multimedia communication. Each call consists of
    #: two UUIDs known as Local Session ID and Remote Session ID.
    #:   * The Remote SessionID is generated from the Terminating user agent.
    remote_session_id: Optional[str] = Field(alias='Remote SessionID')
    #: A unique ID for this particular record. This can be used when processing records to aid in deduplication.
    report_id: Optional[str] = Field(alias='Report ID')
    #: The time this report was created. Time is in UTC.
    report_time: Optional[str] = Field(alias='Report time')
    #: If present, this field's only reported in Originating records. Route group identifies the route group used for
    #: outbound calls routed via a route group to Premises-based PSTN or an on-prem deployment integrated with Webex
    #: Calling (dial plan or unknown extension).
    route_group: Optional[str] = Field(alias='Route group')
    #: The main number for the user's site where the call was made or received.
    site_main_number: Optional[str] = Field(alias='Site main number')
    #: Site timezone is the offset in minutes from UTC time of the user's timezone.
    site_timezone: Optional[str] = Field(alias='Site timezone')
    #: A unique identifier for the site associated with the call. Unique across Cisco products.
    site_uuid: Optional[str] = Field(alias='Site UUID')
    #: This is the start time of the call, the answer time may be slightly after this. Time is in UTC.
    start_time: Optional[str] = Field(alias='Start time')
    #: If the call is TO or FROM a mobile phone using Webex Go, the Client type will show SIP, and Sub client type will
    #: show MOBILE_NETWORK.
    sub_client_type: Optional[str] = Field(alias='Sub client type')
    #: Transfer related call ID is used as a call identifier of the other call involved in the transfer. You can share
    #: this ID with Cisco TAC to help them pinpoint parties who are involved during a call transfer.
    transfer_related_call_id: Optional[str] = Field(alias='Transfer related call ID')
    #: The user who made or received the call.
    user: Optional[str]
    #: The type of user (user or workspace) that made or received the call. For example:
    #:   * AutomatedAttendantVideo
    #:   * Anchor
    #:   * BroadworksAnywhere
    #:   * VoiceMailRetrieval
    #:   * LocalGateway
    #:   * HuntGroup
    #:   * GroupPaging
    #:   * User
    #:   * VoiceMailGroup
    #:   * CallCenterStandard
    #:   * VoiceXML
    #:   * RoutePoint
    user_type: Optional[str] = Field(alias='User type')
    #: A unique identifier for the user associated with the call. This is a unique identifier across Cisco products.
    user_uuid: Optional[str] = Field(alias='User UUID')


class GetDetailedCallHistoryResponse(ApiModel):
    items: Optional[list[CDR]]


class WebexCallingDetailedCallHistoryApi(ApiChild, base=''):
    """
    The base URL for these APIs is analytics.webexapis.com (or analytics-f.webex.com for Government), which does not
    work with the API reference's Try It feature. If you have any questions or need help please contact the Webex
    Developer Support team at devsupport@webex.com.
    To retrieve Detailed Call History information, you must use a token with the spark-admin:calling_cdr_read scope.
    The authenticating user must be a read-only-admin or full-admin of the organization and have the administrator role
    "Webex Calling Detailed Call History API access" enabled.
    Detailed Call History information is available 5 minutes after a call has ended and may be retrieved for up to 48
    hours. For example, if a call ends at 9:46 am, the record for that call can be collected using the API from 9:51
    am, and is available until 9:46 am two days later.
    This API is rate-limited to one call every 5 minutes for a given organization ID.
    Details on the fields returned from this API and their potential values are available at
    https://help.webex.com/en-us/article/nmug598/Reports-for-Your-Cloud-Collaboration-Portfolio. Select the Report
    templates tab, and then in the Webex Calling reports section see Calling Detailed Call History Report.
    """

    def detailed_call_history(self, start_time: str, end_time: str, locations: str = None, **params) -> Generator[CDR, None, None]:
        """
        Provides Webex Calling Detailed Call History data for your organization.
        Results can be filtered with the startTime, endTime and locations request parameters. The startTime and endTime
        parameters specify the start and end of the time period for the Detailed Call History reports you wish to
        collect. The API will return all reports that were created between startTime and endTime.
        Response entries may be added as more information is made available for the reports.
        Values in response items may be extended as more capabilities are added to Webex Calling.

        :param start_time: Time of the first report you wish to collect. (Report time is the time the call finished).
            Note: The specified time must be between 5 minutes ago and 48 hours ago, and be formatted as
            YYYY-MM-DDTHH:MM:SS.mmmZ.
        :type start_time: str
        :param end_time: Time of the last report you wish to collect. (Report time is the time the call finished).
            Note: The specified time should be later than startTime but no later than 48 hours, and be formatted as
            YYYY-MM-DDTHH:MM:SS.mmmZ.
        :type end_time: str
        :param locations: Name of the location (as shown in Control Hub). Up to 10 comma-separated locations can be
            provided. Allows you to query reports by location.
        :type locations: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-detailed-call-history/get-detailed-call-history
        """
        params['startTime'] = start_time
        params['endTime'] = end_time
        if locations is not None:
            params['locations'] = locations
        url = self.ep('https://analytics.webexapis.com/v1/cdr_feed')
        return self.session.follow_pagination(url=url, model=CDR, params=params)

class MemberType(ApiModel):
    #: Indicates the associated member is a person.
    people: Optional[str]
    #: Indicates the associated member is a workspace.
    place: Optional[str]


class LineType(ApiModel):
    #: Indicates a Primary line for the member.
    primary: Optional[str]
    #: Indicates a Shared line for the member. Shared line appearance allows users to receive and place calls to and
    #: from another user's extension, using their device.
    shared_call_appearance: Optional[str]


class PutMemberObject(ApiModel):
    #: Person's assigned port number.
    port: Optional[int]
    #: Unique identifier for the member.
    id: Optional[str]
    #: T.38 Fax Compression setting and is available only for ATA Devices. Choose T.38 fax compression if the device
    #: requires this option. This will override user level compression options.
    t38_fax_compression_enabled: Optional[bool]
    #: Whether the user is the owner of the device or not, and points to a primary Line/Port of device.
    primary_owner: Optional[bool]
    #: Line type is used to differentiate Primary and SCA, at which endpoint it is assigned.
    line_type: Optional[LineType]
    #: Number of lines that have been configured for the person on the device.
    line_weight: Optional[int]
    #: Enable Hotline. Configure this line to automatically call a predefined number whenever taken off-hook. Once
    #: enabled, the line can only make calls to the predefined number set in hotlineDestination.
    hotline_enabled: Optional[bool]
    #: The preconfigured number for Hotline. Required only if hotlineEnabled is set to true.
    hotline_destination: Optional[str]
    #: Set how a person's device behaves when a call is declined. When set to true, a call decline request is extended
    #: to all the endpoints on the device. When set to false, a call decline request only declines the current
    #: endpoint.
    allow_call_decline_enabled: Optional[bool]
    #: Device line label.
    line_label: Optional[str]


class MemberObject(PutMemberObject):
    #: First name of a person or workspace.
    first_name: Optional[str]
    #: Last name of a person or workspace.
    last_name: Optional[str]
    #: Phone Number of a person or workspace. In some regions phone numbers are not returned in E.164 format. This will
    #: be supported in a future update.
    phone_number: Optional[str]
    #: Extension of a person or workspace.
    extension: Optional[str]
    #: Registration Host IP address for the line port.
    host_ip: Optional[str]
    #: Registration Remote IP address for the line port.
    remote_ip: Optional[str]
    #: Indicates if the member is of type PEOPLE or PLACE.
    member_type: Optional[MemberType]
    #: Location object having a unique identifier for the location and its name.
    location: Optional[Role]


class SearchMemberObject(ApiModel):
    #: Unique identifier for the member.
    id: Optional[str]
    #: First name of a person or workspace.
    first_name: Optional[str]
    #: Last name of a person or workspace.
    last_name: Optional[str]
    #: Phone Number of a person or workspace.
    phone_number: Optional[str]
    #: T.38 Fax Compression setting and available only for ATA Devices. Choose T.38 fax compression if the device
    #: requires this option. this will override user level compression options.
    t38_fax_compression_enabled: Optional[bool]
    #: Line type is used to differentiate Primary and SCA, at which endpoint it is assigned.
    line_type: Optional[LineType]
    #: Set how a person's device behaves when a call is declined. When set to true, a call decline request is extended
    #: to all the endpoints on the device. When set to false, a call decline request only declines the current
    #: endpoint.
    allow_call_decline_enabled: Optional[bool]
    #: Indicates if member is of type PEOPLE or PLACE.
    member_type: Optional[MemberType]
    #: Location object having a unique identifier for the location and its name.
    location: Optional[Role]


class SelectionType(ApiModel):
    #: Indicates the regional selection type for audio codec priority.
    regional: Optional[str]
    #: Indicates the custom selection type for audio codec priority.
    custom: Optional[str]


class AudioCodecPriorityObject(ApiModel):
    #: Indicates the selection of an Audio Codec Priority Object.
    selection: Optional[SelectionType]
    #: Indicates the primary Audio Codec.
    primary: Optional[str]
    #: Indicates the secondary Audio Codec.
    secondary: Optional[str]
    #: Indicates the tertiary Audio Codec.
    tertiary: Optional[str]


class AtaDtmfModeObject(ApiModel):
    #: A DTMF digit requires an extra hold time after detection and the DTMF level threshold is raised to -20 dBm.
    strict: Optional[str]
    #: Normal threshold mode.
    normal: Optional[str]


class AtaDtmfMethodObject(ApiModel):
    #: Sends DTMF by using the audio path.
    inband: Optional[str]
    #: Audio video transport. Sends DTMF as AVT events.
    avt: Optional[str]
    #: Uses InBand or AVT based on the outcome of codec negotiation.
    auto: Optional[str]


class VlanObject(ApiModel):
    #: Denotes whether the VLAN object of an ATA is enabled.
    enabled: Optional[bool]
    #: The value of the VLAN Object of DECT.
    value: Optional[int]


class AtaObject(ApiModel):
    #: Choose up to three predefined codec priority options available for your region.
    audio_codec_priority: Optional[AudioCodecPriorityObject]
    #: DTMF Detection Tx Mode selection for Cisco ATA devices.
    ata_dtmf_mode: Optional[AtaDtmfModeObject]
    #: Method for transmitting DTMF signals to the far end.
    ata_dtmf_method: Optional[AtaDtmfMethodObject]
    #: Enable/disable Cisco Discovery Protocol for local devices.
    cdp_enabled: Optional[bool]
    #: Enable/disable Link Layer Discovery Protocol for local devices.
    lldp_enabled: Optional[bool]
    #: Enable/disable quality of service tagging of packets from the local device to the Webex Calling platform.
    qos_enabled: Optional[bool]
    #: Specify a numeric Virtual LAN ID for devices.
    vlan: Optional[VlanObject]


class MppAudioCodecPriorityObject(ApiModel):
    #: Indicates the selection of the Audio Codec Priority Object for an MPP object.
    selection: Optional[str]
    #: Indicates the primary Audio Codec for an MPP object.
    primary: Optional[str]
    #: Indicates the secondary Audio Codec for an MPP object.
    secondary: Optional[str]
    #: Indicates the tertiary Audio Codec for an MPP object.
    tertiary: Optional[str]


class BacklightTimerObject(ApiModel):
    one_m: Optional[str]
    five_m: Optional[str]
    thirty_m: Optional[str]
    always_on: Optional[str]
    off: Optional[str]
    ten_s: Optional[str]
    twenty_s: Optional[str]
    thirty_s: Optional[str]


class BackgroundImage(ApiModel):
    #: Indicates that there will be no background image set for the devices.
    none: Optional[str]
    #: Indicates that dark blue background image will be set for the devices.
    dark_blue: Optional[str]
    #: Indicates that Cisco themed dark blue background image will be set for the devices.
    cisco_dark_blue: Optional[str]
    #: Indicates that Cisco Webex dark blue background image will be set for the devices.
    webex_dark_blue: Optional[str]
    #: Indicates that a custom background image will be set for the devices.
    custom_background: Optional[str]
    #: When this option is selected, a field 'Custom Background URL' needs to be added with the image url. URLs
    #: provided must link directly to an image file and be in HTTP, HTTPS, or filepath format.
    custom_url: Optional[str]


class DisplayNameSelection(ApiModel):
    #: Indicates that devices will display the person's phone number, or if a person doesn't have a phone number, the
    #: location number will be displayed.
    person_number: Optional[str]
    #: Indicates that devices will display the name in first name then last name format.
    person_first_then_last_name: Optional[str]
    #: Indicates that devices will display the name in last name then first name format.
    person_last_then_first_name: Optional[str]


class DefaultLoggingLevelObject(ApiModel):
    #: Enables standard logging.
    standard: Optional[str]
    #: Enables detailed debugging logging.
    debugging: Optional[str]


class DisplayCallqueueAgentSoftkeysObject(ApiModel):
    front_page: Optional[str]
    last_page: Optional[str]


class AcdObject(ApiModel):
    #: Indicates whether the ACD object is enabled.
    enabled: Optional[bool]
    #: Indicates the call queue agent soft key value of an ACD object.
    display_callqueue_agent_softkeys: Optional[str]


class LineKeyLabelSelection(ApiModel):
    #: This will display the person extension, or if a person doesn't have an extension, the person's first name will
    #: be displayed.
    person_extension: Optional[str]
    #: Indicates that devices will display the name in first name then last name format.
    person_first_then_last_name: Optional[str]
    #: Indicates that devices will display the name in last name then first name format.
    person_last_then_first_name: Optional[str]


class LineKeyLEDPattern(ApiModel):
    default: Optional[str]
    preset_1: Optional[str]


class PhoneLanguage(ApiModel):
    #: Indicates a person's announcement language.
    person_language: Optional[str]
    arabic: Optional[str]
    bulgarian: Optional[str]
    catalan: Optional[str]
    chinese_simplified: Optional[str]
    chinese_traditional: Optional[str]
    croatian: Optional[str]
    czech: Optional[str]
    danish: Optional[str]
    dutch: Optional[str]
    english_united_states: Optional[str]
    english_united_kingdom: Optional[str]
    finnish: Optional[str]
    french_canada: Optional[str]
    french_france: Optional[str]
    german: Optional[str]
    greek: Optional[str]
    hebrew: Optional[str]
    hungarian: Optional[str]
    italian: Optional[str]
    japanese: Optional[str]
    korean: Optional[str]
    norwegian: Optional[str]
    polish: Optional[str]
    portuguese_portugal: Optional[str]
    russian: Optional[str]
    spanish_colombia: Optional[str]
    spanish_spain: Optional[str]
    slovak: Optional[str]
    swedish: Optional[str]
    slovenian: Optional[str]
    turkish: Optional[str]
    ukraine: Optional[str]


class MppVlanObject(VlanObject):
    #: Indicates the PC port value of a VLAN object for an MPP object.
    pc_port: Optional[int]


class WifiNetworkObject(ApiModel):
    #: Indicates whether the wifi network is enabled.
    enabled: Optional[bool]
    #: Authentication method of wifi network.
    authentication_method: Optional[str]
    #: SSID name of the wifi network.
    ssid_name: Optional[str]
    #: User Id of the wifi network.
    user_id: Optional[str]


class MppObject(ApiModel):
    #: Indicates whether the PNAC of MPP object is enabled or not.
    pnac_enabled: Optional[bool]
    #: Choose up to three predefined codec priority options available for your region.
    audio_codec_priority: Optional[MppAudioCodecPriorityObject]
    #: Choose the length of time (in minutes) for the phone's backlight to remain on.
    backlight_timer: Optional[BacklightTimerObject]
    #: Holds the background object of MPP Object.
    background: Optional[BackgroundImage]
    #: The display name that appears on the phone screen.
    display_name_format: Optional[DisplayNameSelection]
    #: Allows you to enable/disable CDP for local devices.
    cdp_enabled: Optional[bool]
    #: Choose the desired logging level for an MPP devices.
    default_logging_level: Optional[DefaultLoggingLevelObject]
    #: Enable/disable Do-Not-Disturb capabilities for Multi-Platform Phones.
    dnd_services_enabled: Optional[bool]
    #: Chooses the location of the Call Queue Agent Login/Logout softkey on Multi-Platform Phones.
    display_callqueue_agent_softkeys: Optional[DisplayCallqueueAgentSoftkeysObject]
    #: Choose the duration (in hours) of Hoteling guest login.
    hoteling_guest_association_timer: Optional[int]
    #: Holds the Acd object value.
    acd: Optional[AcdObject]
    #: Indicates the short inter digit timer value.
    short_interdigit_timer: Optional[int]
    #: Indicates the long inter digit timer value..
    long_interdigit_timer: Optional[int]
    #: Line key labels define the format of what's shown next to line keys.
    line_key_label_format: Optional[LineKeyLabelSelection]
    #: LED patterns define lighting schemes for the line keys on the MPP devices. Note that this parameter is not
    #: supported on the MPP 8875
    line_key_led_pattern: Optional[LineKeyLEDPattern]
    #: Enable/disable Link Layer Discovery Protocol for local devices.
    lldp_enabled: Optional[bool]
    #: Enable/disable user-level access to the web interface of Multi-Platform Phones.
    mpp_user_web_access_enabled: Optional[bool]
    #: Select up to 10 Multicast Group URLs (each with a unique Listening Port).
    multicast: Optional[list[str]]
    #: Specify the amount of time (in seconds) that a phone can remain off-hook.
    off_hook_timer: Optional[int]
    #: Select the language for your MPP phone. Setting this overrides the default language setting in place for your
    #: provisioned location.
    phone_language: Optional[PhoneLanguage]
    #: Enable/disable the Power-Over-Ethernet mode for Multi-Platform Phones.
    poe_mode: Optional[str]
    #: Allows you to enable/disable tagging of packets from the local device to the Webex Calling platform.
    qos_enabled: Optional[bool]
    #: Specify the amount of inactive time needed (in seconds) before the phone's screen saver activates.
    screen_timeout: Optional[VlanObject]
    #: Enable/disable the use of the USB ports on Multi-Platform phones.
    usb_ports_enabled: Optional[bool]
    #: Specify a numeric Virtual LAN ID for devices.
    vlan: Optional[MppVlanObject]
    #: Specify the Wi-Fi SSID and password for wireless-enabled MPP phones.
    wifi_network: Optional[WifiNetworkObject]


class CustomizationDeviceLevelObject(ApiModel):
    #: Applicable device settings for an ATA device.
    ata: Optional[AtaObject]
    #: Applicable device settings for an MPP device.
    mpp: Optional[MppObject]


class UpdateDeviceSettingsBody(ApiModel):
    #: Indicates the customization object of the device settings.
    customizations: Optional[CustomizationDeviceLevelObject]
    #: Indicates if customization is allowed at a device level. If true, customized at a device level. If false, not
    #: customized; uses customer-level configuration.
    custom_enabled: Optional[bool]


class GetDeviceMembersResponse(ApiModel):
    #: Model type of the device.
    model: Optional[str]
    #: List of members that appear on the device.
    members: Optional[list[MemberObject]]
    #: Maximum number of lines available for the device.
    max_line_count: Optional[int]


class UpdateMembersOndeviceBody(ApiModel):
    #: If the member's list is missing then all the users are removed except the primary user.
    members: Optional[list[PutMemberObject]]


class SearchMembersResponse(ApiModel):
    #: List of members available for the device.
    members: Optional[list[SearchMemberObject]]


class GetDeviceSettingsResponse(UpdateDeviceSettingsBody):
    #: Customer devices setting update status. If true, an update is in progress (no further changes are allowed). If
    #: false, no update in progress (changes are allowed).
    update_in_progress: Optional[bool]
    #: Number of devices that will be updated.
    device_count: Optional[int]
    #: Indicates the last updated time.
    last_update_time: Optional[int]


class WebexCallingDeviceSettingsApi(ApiChild, base='telephony/config/devices/'):
    """
    These APIs manages Webex Calling settings for devices with are of the Webex Calling type.
    Viewing these read-only device settings requires a full, device, or
    read-only administrator auth token with a scope of
    spark-admin:telephony_config_read, as the current set of APIs is
    designed to provide supplemental information for administrators
    utilizing People Webex Calling APIs.
    Modifying these device settings requires a full or device
    administrator auth token with a scope of
    spark-admin:telephony_config_write.
    """

    def members(self, device_id: str, org_id: str = None) -> GetDeviceMembersResponse:
        """
        Get the list of all the members of the device including primary and secondary users.
        A device member can be either a person or a workspace. An admin can access the list of member details, modify
        member details and
        search for available members on a device.
        Retrieving this list requires a full or read-only administrator auth token with a scope of
        spark-admin:telephony_config_read.

        :param device_id: Unique identifier for the device.
        :type device_id: str
        :param org_id: Retrieves the list of all members of the device in this organization.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-device-settings/get-device-members
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'{device_id}/members')
        data = super().get(url=url, params=params)
        return GetDeviceMembersResponse.parse_obj(data)

    def update_members_ondevice(self, device_id: str, org_id: str = None, members: PutMemberObject = None):
        """
        Modify member details on the device.
        A device member can be either a person or a workspace. An admin can access the list of member details, modify
        member details and
        search for available members on a device.
        Modifying members on the device requires a full administrator auth token with a scope of
        spark-admin:telephony_config_write.

        :param device_id: Unique identifier for the device.
        :type device_id: str
        :param org_id: Modify members on the device in this organization.
        :type org_id: str
        :param members: If the member's list is missing then all the users are removed except the primary user.
        :type members: PutMemberObject

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-device-settings/update-members-on-the-device
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = UpdateMembersOndeviceBody()
        if members is not None:
            body.members = members
        url = self.ep(f'{device_id}/members')
        super().put(url=url, params=params, data=body.json())
        return

    def search_members(self, device_id: str, location_id: str, org_id: str = None, member_name: str = None, phone_number: str = None, extension: str = None, **params) -> Generator[SearchMemberObject, None, None]:
        """
        Search members that can be assigned to the device.
        A device member can be either a person or a workspace. A admin can access the list of member details, modify
        member details and
        search for available members on a device.
        This requires a full or read-only administrator auth token with a scope of spark-admin:telephony_config_read.

        :param device_id: Unique identifier for the device.
        :type device_id: str
        :param location_id: Unique identifier for the location.
        :type location_id: str
        :param org_id: Retrieves the list of available members on the device in this organization.
        :type org_id: str
        :param member_name: Search (Contains) numbers based on member name.
        :type member_name: str
        :param phone_number: Search (Contains) based on number.
        :type phone_number: str
        :param extension: Search (Contains) based on extension.
        :type extension: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-device-settings/search-members
        """
        params['locationId'] = location_id
        if org_id is not None:
            params['orgId'] = org_id
        if member_name is not None:
            params['memberName'] = member_name
        if phone_number is not None:
            params['phoneNumber'] = phone_number
        if extension is not None:
            params['extension'] = extension
        url = self.ep(f'{device_id}/availableMembers')
        return self.session.follow_pagination(url=url, model=SearchMemberObject, item_key='members', params=params)

    def apply_changes_forspecific(self, device_id: str, org_id: str = None):
        """
        Issues request to the device to download and apply changes to the configuration.
        Applying changes for a specific device requires a full administrator auth token with a scope of
        spark-admin:telephony_config_write.

        :param device_id: Unique identifier for the device.
        :type device_id: str
        :param org_id: Apply changes for a device in this organization.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-device-settings/apply-changes-for-a-specific-device
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'{device_id}/actions/applyChanges/invoke')
        super().post(url=url, params=params)
        return

    def settings(self, device_id: str, device_model: str, org_id: str = None) -> GetDeviceSettingsResponse:
        """
        Get override settings for a device.
        Device settings lists all the applicable settings for an MPP and an ATA devices at the device level. An admin
        can also modify the settings. DECT devices do not support settings at the device level.
        This requires a full or read-only administrator auth token with a scope of spark-admin:telephony_config_read.

        :param device_id: Unique identifier for the device.
        :type device_id: str
        :param device_model: Model type of the device.
        :type device_model: str
        :param org_id: Settings on the device in this organization.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-device-settings/get-device-settings
        """
        params = {}
        params['deviceModel'] = device_model
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'{device_id}/settings')
        data = super().get(url=url, params=params)
        return GetDeviceSettingsResponse.parse_obj(data)

    def update_settings(self, device_id: str, customizations: CustomizationDeviceLevelObject, custom_enabled: bool, org_id: str = None, device_model: str = None):
        """
        Modify override settings for a device.
        Device settings list all the applicable settings for an MPP and an ATA devices at the device level. Admins can
        also modify the settings. NOTE: DECT devices do not support settings at the device level.
        Updating settings on the device requires a full administrator auth token with a scope of
        spark-admin:telephony_config_write.

        :param device_id: Unique identifier for the device.
        :type device_id: str
        :param customizations: Indicates the customization object of the device settings.
        :type customizations: CustomizationDeviceLevelObject
        :param custom_enabled: Indicates if customization is allowed at a device level. If true, customized at a device
            level. If false, not customized; uses customer-level configuration.
        :type custom_enabled: bool
        :param org_id: Organization in which the device resides..
        :type org_id: str
        :param device_model: Device model name.
        :type device_model: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-device-settings/update-device-settings
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        if device_model is not None:
            params['deviceModel'] = device_model
        body = UpdateDeviceSettingsBody()
        if customizations is not None:
            body.customizations = customizations
        if custom_enabled is not None:
            body.custom_enabled = custom_enabled
        url = self.ep(f'{device_id}/settings')
        super().put(url=url, params=params, data=body.json())
        return

class ListAutoAttendantObject(Role):
    #: Name of location for auto attendant.
    location_name: Optional[str]
    #: ID of location for auto attendant.
    location_id: Optional[str]
    #: Auto attendant phone number. Either phoneNumber or extension is mandatory.
    phone_number: Optional[str]
    #: Auto attendant extension. Either phoneNumber or extension is mandatory.
    extension: Optional[str]
    #: Flag to indicate if auto attendant number is toll-free number.
    toll_free_number: Optional[bool]


class RingPattern(str, Enum):
    normal = 'NORMAL'
    long_long = 'LONG_LONG'
    short_short_long = 'SHORT_SHORT_LONG'
    short_long_short = 'SHORT_LONG_SHORT'


class AlternateNumbersWithPattern1(ApiModel):
    #: Alternate phone number for the hunt group.
    phone_number: Optional[str]
    #: Ring pattern for when this alternate number is called. Only available when distinctiveRing is enabled for the
    #: hunt group.
    ring_pattern: Optional[RingPattern]


class AlternateNumbersObject(AlternateNumbersWithPattern1):
    #: Flag to indicate if auto attendant number is toll-free number.
    toll_free_number: Optional[bool]


class ExtensionDialing(str, Enum):
    enterprise = 'ENTERPRISE'
    group = 'GROUP'


class MediaType(str, Enum):
    #: WMA File Extension.
    wma = 'WMA'
    #: WAV File Extension.
    wav = 'WAV'
    #: 3GP File Extension.
    three_gp = '3GP'


class AudioFileObject(ApiModel):
    #: Announcement audio file name.
    name: Optional[str]
    #: Announcement audio file media type.
    media_type: Optional[MediaType]


class Greeting(str, Enum):
    default = 'DEFAULT'
    custom = 'CUSTOM'


class Key(str, Enum):
    digit_0 = 'digit_0'
    digit_1 = 'digit_1'
    digit_2 = 'digit_2'
    digit_3 = 'digit_3'
    digit_4 = 'digit_4'
    digit_5 = 'digit_5'
    digit_6 = 'digit_6'
    digit_7 = 'digit_7'
    digit_8 = 'digit_8'
    digit_9 = 'digit_9'
    hash = 'hash'


class Action(str, Enum):
    transfer_without_prompt = 'TRANSFER_WITHOUT_PROMPT'
    transfer_with_prompt = 'TRANSFER_WITH_PROMPT'
    transfer_to_operator = 'TRANSFER_TO_OPERATOR'
    name_dialing = 'NAME_DIALING'
    extension_dialing = 'EXTENSION_DIALING'
    repeat_menu = 'REPEAT_MENU'
    exit = 'EXIT'
    transfer_to_mailbox = 'TRANSFER_TO_MAILBOX'
    return_to_previous_menu = 'RETURN_TO_PREVIOUS_MENU'


class KeyConfigurationsObject(ApiModel):
    #: Key assigned to specific menu configuration.
    key: Optional[Key]
    #: Action assigned to specific menu key configuration.
    action: Optional[Action]
    #: The description of each menu key.
    description: Optional[str]
    #: Value based on actions.
    value: Optional[str]


class PostHoursMenuObject(ApiModel):
    #: Greeting type defined for the auto attendant.
    greeting: Optional[Greeting]
    #: Flag to indicate if auto attendant extension is enabled or not.
    extension_enabled: Optional[bool]
    #: Key configurations defined for the auto attendant.
    key_configurations: Optional[KeyConfigurationsObject]


class HoursMenuObject(PostHoursMenuObject):
    #: Announcement Audio File details.
    audio_file: Optional[AudioFileObject]


class FaxMessage(ApiModel):
    #: Enable/disable fax messaging.
    enabled: Optional[bool]
    #: Phone number to receive fax messages.
    phone_number: Optional[str]
    #: Extension to receive fax messages.
    extension: Optional[int]


class GetDetailsForCallParkExtensionResponse(ApiModel):
    #: The extension for the call park extension.
    extension: Optional[str]
    #: Unique name for the call park extension.
    name: Optional[str]


class NewNumber(ApiModel):
    #: Enable/disable to play new number announcement.
    enabled: Optional[bool]
    #: Incoming destination phone number to be announced.
    destination: Optional[str]


class GetCallForwardAlwaysSettingObject(NewNumber):
    #: If true, a brief tone will be played on the person's phone when a call has been forwarded.
    ring_reminder_enabled: Optional[bool]
    #: Indicates enabled or disabled state of sending incoming calls to voicemail when the destination is an internal
    #: phone number and that number has the voicemail service enabled.
    send_to_voicemail_enabled: Optional[bool]


class CallForwardRulesObject(Role):
    #: Comma-separated list of incoming call numbers that, when matched, will not be forwarded. A Limit of 12 numbers
    #: is allowed. Use Any private Number in the comma-separated value to indicate rules that match incoming calls from
    #: a private number. Use Any unavailable number in the comma-separated value to match incoming calls from an
    #: unavailable number.
    calls_from: Optional[str]
    #: Comma-separated list of the types of numbers being matched for incoming call destination.
    calls_to: Optional[str]
    #: Number to which calls will be forwarded if the rule is of type "Forward To" and the incoming call is matched.
    forward_to: Optional[str]
    #: Reflects if rule is enabled.
    enabled: Optional[bool]


class AutoAttendantCallForwardSettingsDetailsObject(ApiModel):
    #: Settings for forwarding all incoming calls to the destination you choose.
    always: Optional[GetCallForwardAlwaysSettingObject]
    #: Selectively forward calls to a designated number, depending on criteria rules. You'll need to have at least one
    #: rule for forwarding applied for call forwarding to be active.
    selective: Optional[GetCallForwardAlwaysSettingObject]
    #: Rules for selectively forwarding calls.
    rules: Optional[list[CallForwardRulesObject]]


class AutoAttendantCallForwardSettingsModifyDetailsObject(ApiModel):
    #: Settings for forwarding all incoming calls to the destination you choose.
    always: Optional[GetCallForwardAlwaysSettingObject]
    #: Selectively forward calls to a designated number, depending on criteria rules. You'll need to have at least one
    #: rule for forwarding applied for call forwarding to be active.
    selective: Optional[GetCallForwardAlwaysSettingObject]
    #: Rules for selectively forwarding calls. (Rules which are omitted in the list will not be deleted.)
    rules: Optional[list[CallForwardRulesModifyObject]]


class Selection1(str, Enum):
    #: When the rule matches, forward to the destination for the auto attendant.
    forward_to_default_number = 'FORWARD_TO_DEFAULT_NUMBER'
    #: When the rule matches, forward to the destination for this rule.
    forward_to_specified_number = 'FORWARD_TO_SPECIFIED_NUMBER'
    #: When the rule matches, do not forward to another number.
    do_not_forward = 'DO_NOT_FORWARD'


class CallForwardSelectiveForwardToObject(ApiModel):
    #: Phone number used if selection is FORWARD_TO_SPECIFIED_NUMBER.
    phone_number: Optional[str]
    #: Controls what happens when the rule matches.
    selection: Optional[Selection1]


class Selection2(str, Enum):
    #: Rule matches for calls from any number.
    any = 'ANY'
    #: Rule matches based on the numbers and options in customNumbers.
    custom = 'CUSTOM'


class CallForwardSelectiveCallsFromCustomNumbersObject(ApiModel):
    #: Match if caller ID indicates the call is from a private number.
    private_number_enabled: Optional[bool]
    #: Match if callerID is unavailable.
    unavailable_number_enabled: Optional[bool]
    #: Array of number strings to be matched against incoming caller ID.
    numbers: Optional[list[str]]


class CallForwardSelectiveCallsFromObject(ApiModel):
    #: If CUSTOM, use customNumbers to specify which incoming caller ID values cause this rule to match. ANY means any
    #: incoming call matches assuming the rule is in effect based on the associated schedules.
    selection: Optional[Selection2]
    #: Custom rules for matching incoming caller ID information. Mandatory if the selection option is set to CUSTOM.
    custom_numbers: Optional[CallForwardSelectiveCallsFromCustomNumbersObject]


class Type34(str, Enum):
    #: Indicates that the given phoneNumber or extension associated with this rule's containing object is a primary
    #: number or extension.
    primary = 'PRIMARY'
    #: Indicates that the given phoneNumber or extension associated with this rule's containing object is an alternate
    #: number or extension.
    alternate = 'ALTERNATE'


class CallForwardSelectiveCallsToNumbersObject(ApiModel):
    #: AutoCalls To phone number. Either phone number or extension should be present as mandatory.
    phone_number: Optional[str]
    #: Calls To extension. Either phoneNumber or extension is mandatory.
    extension: Optional[str]
    #: Calls to type options.
    type: Optional[Type34]


class CallForwardSelectiveCallsToObject(ApiModel):
    #: Array of numbers to be matched against the calling destination number.
    numbers: Optional[list[CallForwardSelectiveCallsToNumbersObject]]


class CreateSelectiveCallForwardingRuleForAutoAttendantBody(ApiModel):
    #: Unique name for the selective rule in the auto attendant.
    name: Optional[str]
    #: Reflects if rule is enabled.
    enabled: Optional[bool]
    #: Name of the location's business schedule which determines when this selective call forwarding rule is in effect.
    business_schedule: Optional[str]
    #: Name of the location's holiday schedule which determines when this selective call forwarding rule is in effect.
    holiday_schedule: Optional[str]
    #: Controls what happens when the rule matches including the destination number for the call forwarding.
    forward_to: Optional[CallForwardSelectiveForwardToObject]
    #: Settings related to the rule matching based on incoming caller ID.
    calls_from: Optional[CallForwardSelectiveCallsFromObject]
    #: Settings related to the rule matching based on the destination number.
    calls_to: Optional[CallForwardSelectiveCallsToObject]


class ListCallParkObject(Role):
    #: Name of the location for the call park.
    location_name: Optional[str]
    #: ID of the location for the call park.
    location_id: Optional[str]


class Option1(str, Enum):
    #: Alert parking user only.
    alert_parking_user_only = 'ALERT_PARKING_USER_ONLY'
    #: Alert parking user first, then hunt group.
    alert_parking_user_first_then_hunt_group = 'ALERT_PARKING_USER_FIRST_THEN_HUNT_GROUP'
    #: Alert hunt group only.
    alert_hunt_group_only = 'ALERT_HUNT_GROUP_ONLY'


class PutRecallHuntGroupObject(ApiModel):
    #: Alternate user which is a hunt group ID for call park recall alternate destination.
    hunt_group_id: Optional[str]
    #: Call park recall options.
    option: Optional[Option1]


class CreateCallPickupBody(ApiModel):
    #: Unique name for the call pickup. The maximum length is 80.
    name: Optional[str]
    #: An Array of ID strings of people, workspaces and virtual lines that are added to call pickup.
    agents: Optional[list[str]]


class GetRecallHuntGroupObject(PutRecallHuntGroupObject):
    #: Unique name for the hunt group.
    hunt_group_name: Optional[str]


class Type37(MemberType):
    #: Indicates that this object is a virtual line.
    virtual_line = 'VIRTUAL_LINE'


class GetUserNumberItemObject(ApiModel):
    #: Phone number of a person or workspace.
    external: Optional[str]
    #: Extension of a person or workspace.
    extension: Optional[str]
    #: Flag to indicate a primary phone.
    primary: Optional[bool]


class GetPersonPlaceVirtualLineCallParksObject(CoHosts):
    #: ID of a person, workspace or virtual line.
    id: Optional[str]
    #: First name of a person, workspace or virtual line.
    first_name: Optional[str]
    #: Last name of a person, workspace or virtual line.
    last_name: Optional[str]
    #: Type of the person, workspace or virtual line.
    type: Optional[Type37]
    #: List of phone numbers of a person, workspace or virtual line.
    numbers: Optional[list[GetUserNumberItemObject]]


class ListCPCallParkExtensionObject(Role):
    #: The extension for the call park.
    extension: Optional[str]


class CreateCallParkBody(CreateCallPickupBody):
    #: Recall options that are added to the call park.
    recall: Optional[PutRecallHuntGroupObject]


class CallParkSettingsObject(ApiModel):
    #: Ring pattern for when this callpark is called.
    ring_pattern: Optional[RingPattern]
    #: Amount of time within 30 and 600 seconds the Call Park will be parked. If the call isn't picked up within the
    #: set time, then the call will be recalled based on the Call Park Recall setting.
    recall_time: Optional[int]
    #: Amount of time within 30 and 600 seconds the Call Park will be parked. If the call isn't picked up, the call
    #: will revert back to the hunt group (after the person who parked the call is alerted).
    hunt_wait_time: Optional[int]


class ListCallParkExtensionObject(ListCallParkObject):
    #: The extension for the call park extension.
    extension: Optional[str]


class GetPersonPlaceVirtualLineCallPickupObject(CoHosts):
    #: ID of a person, workspace or virtual line.
    id: Optional[str]
    #: First name of a person, workspace or virtual line.
    first_name: Optional[str]
    #: Last name of a person, workspace or virtual line.
    last_name: Optional[str]
    #: Type of the person, workspace or virtual line.
    type: Optional[Type37]
    #: List of phone numbers of a person, workspace or virtual line.
    phone_number: Optional[list[GetUserNumberItemObject]]


class ListCallQueueObject(ListCallParkExtensionObject):
    #: Primary phone number of the call queue.
    phone_number: Optional[str]
    #: Whether or not the call queue is enabled.
    enabled: Optional[bool]


class HuntRoutingTypeSelection(ApiModel):
    #: Default routing type which directly uses the routing policy to dispatch calls to the agents.
    priority_based: Optional[str]
    #: This option uses skill level as the criteria to route calls to agents. When there is more than one agent with
    #: the same skill level, the selected policy helps dispatch the calls to the agents.
    skill_based: Optional[str]


class HuntPolicySelection(ApiModel):
    #: This option cycles through all agents after the last agent that took a call. It sends calls to the next
    #: available agent. This is supported for SKILL_BASED.
    circular: Optional[str]
    #: Send the call through the queue of agents in order, starting from the top each time. This is supported for
    #: SKILL_BASED.
    regular: Optional[str]
    #: Sends calls to all agents at once
    simultaneous: Optional[str]
    #: Sends calls to the agent that has been idle the longest. If they don't answer, proceed to the next agent who has
    #: been idle the second longest, and so on until the call is answered. This is supported for SKILL_BASED.
    uniform: Optional[str]
    #: Sends calls to idle agents based on percentages you assign to each agent (up to 100%).
    weighted: Optional[str]


class CallBounce(ApiModel):
    #: If enabled, bounce calls after the set number of rings.
    call_bounce_enabled: Optional[bool]
    #: Number of rings after which to bounce call, if callBounce is enabled.
    call_bounce_max_rings: Optional[int]
    #: Bounce if agent becomes unavailable.
    agent_unavailable_enabled: Optional[bool]
    #: Alert agent if call on hold more than alertAgentMaxSeconds.
    alert_agent_enabled: Optional[bool]
    #: Number of second after which to alert agent if alertAgentEnabled.
    alert_agent_max_seconds: Optional[int]
    #: Bounce if call on hold more than callBounceMaxSeconds.
    call_bounce_on_hold_enabled: Optional[bool]
    #: Number of second after which to bounce if callBounceEnabled.
    call_bounce_on_hold_max_seconds: Optional[int]


class DistinctiveRing(ApiModel):
    #: Whether or not the distinctiveRing is enabled.
    enabled: Optional[bool]
    #: Ring pattern for when this call queue is called. Only available when distinctiveRing is enabled for the call
    #: queue.
    ring_pattern: Optional[RingPattern]


class PostCallQueueCallPolicyObject(ApiModel):
    #: Call routing type to use to dispatch calls to agents. The routing type should be SKILL_BASED if you want to
    #: assign skill level to agents. Only certain policy are allowed in SKILL_BASED type.
    routing_type: Optional[HuntRoutingTypeSelection]
    #: Call routing policy to use to dispatch calls to agents.
    policy: Optional[HuntPolicySelection]
    #: Settings for when the call into the hunt group is not answered.
    call_bounce: Optional[CallBounce]
    #: Whether or not the call queue has the distinctiveRing option enabled.
    distinctive_ring: Optional[DistinctiveRing]


class Action6(str, Enum):
    #: The caller hears a fast-busy tone.
    perform_busy_treatment = 'PERFORM_BUSY_TREATMENT'
    #: The caller hears ringing until they disconnect.
    play_ringing_until_caller_hangs_up = 'PLAY_RINGING_UNTIL_CALLER_HANGS_UP'
    #: Number where you want to transfer overflow calls.
    transfer_to_phone_number = 'TRANSFER_TO_PHONE_NUMBER'


class Overflow(ApiModel):
    #: Indicates how to handle new calls when the queue is full.
    action: Optional[Action6]
    #: When true, forwards all calls to a voicemail service of an internal number. This option is ignored when an
    #: external transferNumber is entered.
    send_to_voicemail: Optional[bool]
    #: Destination number for overflow calls when action is set to TRANSFER_TO_PHONE_NUMBER.
    transfer_number: Optional[str]
    #: After calls wait for the configured number of seconds and no agent is available, the overflow treatment is
    #: triggered.
    overflow_after_wait_enabled: Optional[bool]
    #: Number of seconds to wait before the overflow treatment is triggered when no agent is available. The minimum
    #: value 0, The maximum value is 7200 seconds.
    overflow_after_wait_time: Optional[int]
    #: Indicate overflow audio to be played, otherwise, callers will hear the hold music until the call is answered by
    #: a user.
    play_overflow_greeting_enabled: Optional[bool]
    #: Indicates how to handle new calls when the queue is full.
    greeting: Optional[Greeting]
    #: Array of announcement fileName strings to be played as overflow greetings. These files are from the list of
    #: announcement files associated with this call queue. For CUSTOM announcement, a minimum of 1 fileName is
    #: mandatory, and the maximum is 4.
    audio_files: Optional[list[str]]


class SendBusyCalls1(ApiModel):
    #: Calls will be sent to voicemail when busy.
    enabled: Optional[bool]
    #: DEFAULT indicates the default greeting will be played. CUSTOM indicates a custom .wav file will be played.
    greeting: Optional[Greeting]


class WelcomeMessage(SendBusyCalls1):
    #: Mandatory entrance message. The default value is false.
    always_enabled: Optional[bool]
    #: Array of announcement fileName strings to be played as welcomeMessage greetings. These files are from the list
    #: of announcement files associated with this call queue. For CUSTOM announcement, a minimum of 1 fileName is
    #: mandatory, and the maximum is 4.
    audio_files: Optional[list[str]]


class WaitMode(str, Enum):
    #: Announce the waiting time.
    time = 'TIME'
    #: Announce queue position.
    position = 'POSITION'


class WaitMessage(ApiModel):
    #: If enabled play Wait Message.
    enabled: Optional[bool]
    #: Estimated wait message operating mode. Supported values TIME and POSITION.
    wait_mode: Optional[WaitMode]
    #: The number of minutes for which the estimated wait is played. The minimum time is 10 minutes. The maximum time
    #: is 100 minutes.
    handling_time: Optional[int]
    #: The default number of call handling minutes. The minimum time is 1 minutes, The maximum time is 100 minutes.
    default_handling_time: Optional[int]
    #: The number of the position for which the estimated wait is played. The minimum positions are 10, The maximum
    #: positions are 100.
    queue_position: Optional[int]
    #: Play time / Play position High Volume.
    high_volume_message_enabled: Optional[bool]
    #: The number of estimated waiting times in seconds. The minimum time is 10 seconds. The maximum time is 600
    #: seconds.
    estimated_waiting_time: Optional[int]
    #: Callback options enabled/disabled. Default value is false.
    callback_option_enabled: Optional[bool]
    #: The minimum estimated callback times in minutes. The default value is 30.
    minimum_estimated_callback_time: Optional[int]
    #: The international numbers for callback is enabled/disabled. The default value is false.
    international_callback_enabled: Optional[bool]
    #: Play updated estimated wait message.
    play_updated_estimated_wait_message: Optional[str]


class ComfortMessage(SendBusyCalls1):
    #: The interval in seconds between each repetition of the comfort message played to queued users. The minimum time
    #: is 10 seconds.The maximum time is 600 seconds.
    time_between_messages: Optional[int]
    #: Array of announcement fileName strings to be played as comfortMessage greetings. These files are from the list
    #: of announcement files associated with this call queue. These files are from the list of announcements files
    #: associated with this call queue. For CUSTOM announcement, a minimum of 1 fileName is mandatory, and the maximum
    #: is 4.
    audio_files: Optional[list[str]]


class ComfortMessageBypass(SendBusyCalls1):
    #: The interval in seconds between each repetition of the comfort bypass message played to queued users. The
    #: minimum time is 1 seconds. The maximum time is 120 seconds.
    call_waiting_age_threshold: Optional[int]
    #: Array of announcement fileName strings to be played as comfortMessageBypass greetings. These files are from the
    #: list of announcements files associated with this call queue. For CUSTOM announcement, a minimum of 1 fileName is
    #: mandatory, and the maximum is 4.
    audio_files: Optional[list[str]]


class NormalSource(SendBusyCalls1):
    #: Array of announcement fileName strings to be played as mohMessage greetings. These files are from the list of
    #: announcement files associated with this call queue. For CUSTOM announcement, a minimum of 1 fileName is
    #: mandatory, and the maximum is 4.
    audio_files: Optional[list[str]]


class MohMessage(ApiModel):
    normal_source: Optional[NormalSource]
    alternate_source: Optional[NormalSource]


class CallQueueQueueSettingsObject(ApiModel):
    #: The maximum number of calls for this call queue. Once this number is reached, the overflow settings are
    #: triggered.
    queue_size: Optional[int]
    #: Play ringing tone to callers when their call is set to an available agent.
    call_offer_tone_enabled: Optional[bool]
    #: Reset caller statistics upon queue entry.
    reset_call_statistics_enabled: Optional[bool]
    #: Settings for incoming calls exceed queueSize.
    overflow: Optional[Overflow]
    #: Play a message when callers first reach the queue. For example, “Thank you for calling. An agent will be with
    #: you shortly.” It can be set as mandatory. If the mandatory option is not selected and a caller reaches the call
    #: queue while there is an available agent, the caller will not hear this announcement and is transferred to an
    #: agent. The welcome message feature is enabled by default.
    welcome_message: Optional[WelcomeMessage]
    #: Notify the caller with either their estimated wait time or position in the queue. If this option is enabled, it
    #: plays after the welcome message and before the comfort message. By default, it is not enabled.
    wait_message: Optional[WaitMessage]
    #: Play a message after the welcome message and before hold music. This is typically a CUSTOM announcement that
    #: plays information, such as current promotions or information about products and services.
    comfort_message: Optional[ComfortMessage]
    #: Play a shorter comfort message instead of the usual Comfort or Music On Hold announcement to all the calls that
    #: should be answered quickly. This feature prevents a caller from hearing a short portion of the standard comfort
    #: message that abruptly ends when they are connected to an agent.
    comfort_message_bypass: Optional[ComfortMessageBypass]
    #: Play music after the comforting message in a repetitive loop.
    moh_message: Optional[MohMessage]
    #: Play a message to the agent immediately before the incoming call is connected. The message typically announces
    #: the identity of the call queue from which the call is coming.
    whisper_message: Optional[NormalSource]


class PostPersonPlaceVirtualLineHuntGroupObject(ApiModel):
    #: ID of person, workspace or virtual line.
    id: Optional[str]
    #: Weight of person, workspace or virtual line. Only applied when call policy is WEIGHTED.
    weight: Optional[str]


class PostPersonPlaceVirtualLineCallQueueObject(PostPersonPlaceVirtualLineHuntGroupObject):
    #: Skill level of person, workspace or virtual line. Only applied when call routing type is SKILL_BASED.
    skill_level: Optional[int]


class AlternateNumbersWithPattern(ApiModel):
    #: Alternate phone number for the hunt group.
    phone_number: Optional[str]
    #: Ring pattern for when this alternate number is called. Only available when distinctiveRing is enabled for the
    #: hunt group.
    ring_pattern: Optional[RingPattern]


class AlternateNumberSettings(ApiModel):
    #: Distinctive Ringing selected for the alternate numbers in the call queue overrides the normal ringing patterns
    #: set for the Alternate Numbers.
    distinctive_ring_enabled: Optional[bool]
    #: Specifies up to 10 numbers which can each have an overriden distinctive ring setting.
    alternate_numbers: Optional[list[AlternateNumbersWithPattern]]


class GetPersonPlaceVirtualLineCallQueueObject(CallForwardSelectiveCallsToNumbersObject):
    #: ID of person, workspace or virtual line.
    id: Optional[str]
    #: First name of person, workspace or virtual line.
    first_name: Optional[str]
    #: First name of person, workspace or virtual line.
    last_name: Optional[str]
    #: Weight of person, workspace or virtual line. Only applied when call policy is WEIGHTED.
    weight: Optional[str]
    #: Skill level of person, workspace or virtual line. Only applied when the call routingType is SKILL_BASED.
    skill_level: Optional[int]
    #: Indicates the join status of the agent for this queue. The default value while creating call queue is true.
    join_enabled: Optional[bool]


class ModifyPersonPlaceVirtualLineCallQueueObject(PostPersonPlaceVirtualLineCallQueueObject):
    #: Indicates the join status of the agent for this queue. The default value for newly added agents is true.
    join_enabled: Optional[bool]


class GetAnnouncementFileInfo(ApiModel):
    #: Name of greeting file.
    file_name: Optional[str]
    #: Size of greeting file in bytes.
    file_size: Optional[str]


class Always(NewNumber):
    #: If true, a brief tone will be played on the person's phone when a call has been forwarded.
    ring_reminder_enabled: Optional[bool]
    #: Indicates enabled or disabled state of sending incoming calls to voicemail when the destination is an internal
    #: phone number and that number has the voicemail service enabled.
    destination_voicemail_enabled: Optional[bool]


class CallForwardRulesGet(Role):
    #: Comma-separated list of incoming call numbers that, when matched, will not be forwarded. A Limit of 12 numbers
    #: is allowed. Use Any private Number in the comma-separated value to indicate rules that match incoming calls from
    #: a private number. Use Any unavailable number in the comma-separated value to match incoming calls from an
    #: unavailable number.
    call_from: Optional[str]
    #: Comma-separated list of the types of numbers being matched for incoming call destination.
    calls_to: Optional[str]
    #: Number to which calls will be forwarded if the rule is of type "Forward To" and the incoming call is matched.
    forward_to: Optional[str]
    #: Reflects if rule is enabled.
    enabled: Optional[bool]


class CallForwarding(ApiModel):
    #: Settings for forwarding all incoming calls to the destination you choose.
    always: Optional[Always]
    #: Selectively forward calls to a designated number, depending on criteria rules. You'll need to have at least one
    #: rule for forwarding applied for call forwarding to be active.
    selective: Optional[Always]
    #: Rules for selectively forwarding calls.
    rules: Optional[list[CallForwardRulesGet]]


class CallForwarding1(ApiModel):
    #: Settings for forwarding all incoming calls to the destination you choose.
    always: Optional[Always]
    #: Selectively forward calls to a designated number, depending on criteria rules. You'll need to have at least one
    #: rule for forwarding applied for call forwarding to be active.
    selective: Optional[Always]
    #: Rules for selectively forwarding calls.
    rules: Optional[list[CallForwardRulesModifyObject]]


class CallsFrom(ApiModel):
    #: If CUSTOM, use customNumbers to specify which incoming caller ID values cause this rule to match. ANY means any
    #: incoming call matches assuming the rule is in effect based on the associated schedules.
    selection: Optional[Selection2]
    #: Custom rules for matching incoming caller ID information.
    custom_numbers: Optional[CallForwardSelectiveCallsFromCustomNumbersObject]


class CallsTo(ApiModel):
    #: Array of numbers to be matched against the calling destination number.
    numbers: Optional[list[CallForwardSelectiveCallsToNumbersObject]]


class CreateSelectiveCallForwardingRuleForCallQueueBody(ApiModel):
    #: Unique name for the selective rule in the hunt group.
    name: Optional[str]
    #: Reflects if rule is enabled.
    enabled: Optional[bool]
    #: Name of the location's holiday schedule which determines when this selective call forwarding rule is in effect.
    holiday_schedule: Optional[str]
    #: Name of the location's business schedule which determines when this selective call forwarding rule is in effect.
    business_schedule: Optional[str]
    #: Controls what happens when the rule matches including the destination number for the call forwarding.
    forward_to: Optional[CallForwardSelectiveForwardToObject]
    #: Settings related to the rule matching based on incoming caller ID.
    calls_from: Optional[CallsFrom]
    #: Settings related to the rule matching based on the destination number.
    calls_to: Optional[CallsTo]


class OriginatorType(ApiModel):
    #: User
    user: Optional[str]
    #: Connection between Webex Calling and the premises
    trunk: Optional[str]


class CallSourceType(ApiModel):
    #: Indicates that the call source is a route list.
    route_list: Optional[str]
    #: Indicates that the call source is a dial pattern.
    dial_pattern: Optional[str]
    #: Indicates that the call source extension is unknown.
    unkown_extension: Optional[str]
    #: Indicates that the call source phone number is unknown.
    unkown_number: Optional[str]


class CallSourceInfo(ApiModel):
    #: The type of call source.
    call_source_type: Optional[CallSourceType]
    #: When originatorType is trunk, originatorId is a valid trunk, this trunk belongs to a route group which is
    #: assigned to a route list with the name routeListA and originatorNumber is a number assigned to routeListA.
    #: routeListA is returned here. This element is returned when callSourceType is ROUTE_LIST.
    route_list_name: Optional[str]
    #: Foute list ID.
    route_list_id: Optional[str]
    #: When originatorType is trunk, originatorId is a valid trunk with name trunkA, trunkA belongs to a route group
    #: which is assigned to a route list with name routeListA, trunkA is also assigned to dialPlanA as routing choice,
    #: dialPlanA has dialPattern xxxx assigned. If the originatorNumber matches the dialPattern xxxx, dialPlanA is
    #: returned. This element is returned when callSourceType is DIAL_PATTERN.
    dial_plan_name: Optional[str]
    #: When originatorType is trunk, originatorId is a valid trunk with the name trunkA, trunkA belongs to a route
    #: group which is assigned to a route list with the name routeListA, trunkA is also assigned to dialPlanA as
    #: routing choice, dialPlanA has dialPattern xxxx assigned. If the originatorNumber matches the dialPattern xxxx,
    #: dialPattern xxxx is returned. This element is returned when callSourceType is DIAL_PATTERN.
    dial_pattern: Optional[str]
    #: Dial plan ID.
    dial_plan_id: Optional[str]


class DestinationType(ApiModel):
    #: Matching destination is a person or workspace with details in the hostedAgent field.
    hosted_agent: Optional[str]
    #: Matching destination is a calling feature like auto-attendant or hunt group with details in the hostedFeature
    #: field.
    hosted_feature: Optional[str]
    #: Matching destination routes into a separate PBX with details in the pbxUser field.
    pbx_user: Optional[str]
    #: Matching destination routes into a PSTN phone number with details in the pstnNumber field.
    pstn_number: Optional[str]
    #: Matching destination routes into a virtual extension with details in the virtualExtension field.
    virtual_extension: Optional[str]
    #: Matching destination routes into a virtual extension range with details in the virtualExtensionRange field.
    virtual_extension_range: Optional[str]
    #: Matching destination routes into a route list with details in the routeList field.
    route_list: Optional[str]
    #: Matching destination routes into a feature access code (FAC) with details in the featureAccessCode field.
    fac: Optional[str]
    #: Matching destination routes into an emergency service like Red Sky, with details in the emergency field.
    emergency: Optional[str]
    #: The route is in a repair state with routing choice details in the repair field.
    repair: Optional[str]
    #: Target extension is unknown with routing choice details in the unknownExtension field.
    unknown_extension: Optional[str]
    #: The target phone number is unknown with routing choice details in the unknownNumber field.
    unknown_number: Optional[str]


class HostedAgent(ApiModel):
    #: Person or workspace's ID.
    id: Optional[str]
    #: Type of agent for call destination.
    type: Optional[MemberType]
    #: Person or workspace's first name.
    first_name: Optional[str]
    #: Person or workspace's last name.
    last_name: Optional[str]
    #: Name of location for a person or workspace.
    location_name: Optional[str]
    #: Location ID for a person or workspace.
    location_id: Optional[str]
    #: Person or workspace's phone number.
    phone_number: Optional[str]
    #: Person or workspace's extension.
    extension: Optional[str]


class ServiceType5(ApiModel):
    #: Destination is an auto attendant.
    auto_attendant: Optional[str]
    #: Indicates that this destination is the Office (Broadworks) Anywhere feature.
    broadworks_anywhere: Optional[str]
    #: Indicates that this destination is the Call Center feature.
    call_center: Optional[str]
    #: Indicates that this destination is the Contact Center Link feature.
    contact_center_link: Optional[str]
    #: Indicates that this destination is the Group Paging feature.
    group_paging: Optional[str]
    #: Indicates that this destination is the Hunt Group feature.
    hunt_group: Optional[str]
    #: Indicates that this destination is the Voice Messaging feature.
    voice_messaging: Optional[str]
    #: Indicates that this destination is the Voice Mail Group feature.
    voice_mail_group: Optional[str]


class HostedFeature(ListCallParkExtensionObject):
    #: Service instance type.
    type: Optional[ServiceType5]
    #: User or place's phone number.
    phone_number: Optional[str]


class PstnNumber(ApiModel):
    #: Trunk name.
    trunk_name: Optional[str]
    #: Trunk ID.
    trunk_id: Optional[str]
    #: Route group name.
    route_group_name: Optional[str]
    #: Route group ID.
    route_group_id: Optional[str]
    #: Location of the trunk; required if trunkName is returned.
    trunk_location_name: Optional[str]
    #: Location ID of the trunk; required if trunkName is returned.
    trunk_location_id: Optional[str]


class PbxUser(PstnNumber):
    #: Dial plan name that the called string matches.
    dial_plan_name: Optional[str]
    #: Dial plan ID.
    dial_plan_id: Optional[str]
    #: Dial pattern that the called string matches.
    dial_pattern: Optional[str]


class VirtualExtension(PstnNumber):
    #: Virtual extension ID.
    id: Optional[str]
    #: Virtual extension display first name.
    first_name: Optional[str]
    #: Virtual extension display last name.
    last_name: Optional[str]
    #: Virtual extension display name.
    display_name: Optional[str]
    #: Extension that the virtual extension is associated with.
    extension: Optional[str]
    #: Phone number that the virtual extension is associated with.
    phone_number: Optional[str]
    #: Location name if the virtual extension is at the location level, empty if it is at customer level.
    location_name: Optional[str]
    #: Location ID if the virtual extension is at the location level, empty if it is at customer level.
    location_id: Optional[str]


class VirtualExtensionRange(PstnNumber):
    #: Virtual extension range ID.
    id: Optional[str]
    #: Virtual extension range name.
    name: Optional[str]
    #: Prefix that the virtual extension range is associated with (Note: Standard mode must have leading '+' in prefix;
    #: BCD/Enhanced mode can have any valid prefix).
    prefix: Optional[str]
    #: Pattern associated with the virtual extension range.
    pattern: Optional[str]
    #: Location name if the virtual extension range is at the location level, empty if it is at customer level.
    location_name: Optional[str]
    #: Location ID if the virtual extension range is at the location level, empty if it is at customer level.
    location_id: Optional[str]


class RouteList(ListCallParkObject):
    #: Name of the route group the route list is associated with.
    route_group_name: Optional[str]
    #: ID of the route group the route list is associated with.
    route_group_id: Optional[str]


class FeatureAccessCode(ApiModel):
    #: FAC code.
    code: Optional[str]
    #: FAC name.
    name: Optional[str]


class Emergency(PstnNumber):
    #: Indicates if RedSky is in use.
    is_red_sky: Optional[bool]


class Status30(str, Enum):
    #: Indicates that all extensions were validated.
    ok = 'OK'
    #: Indicates that not all extensions were validated.
    errors = 'ERRORS'


class DialPatternStatus(ApiModel):
    #: Invalid pattern
    invalid: Optional[str]
    #: Duplicate pattern
    duplicate: Optional[str]
    #: Duplicate in input
    duplicate_in_list: Optional[str]


class State10(DialPatternStatus):
    #: Extension is valid.
    valid = 'VALID'


class ExtensionStatusObject(ApiModel):
    #: Unique extension which will be validated at the location level.
    extension: Optional[str]
    #: State of the extension after it was validated.
    state: Optional[State10]
    #: Error code of the state in case extension is not valid.
    error_code: Optional[int]
    #: Message assigned to the error code.
    message: Optional[str]


class NoAnswer(ApiModel):
    #: If enabled, advance to next agent after the nextAgentRings has occurred.
    next_agent_enabled: Optional[bool]
    #: Number of rings before call will be forwarded if unanswered and nextAgentEnabled is true.
    next_agent_rings: Optional[int]
    #: If true, forwards unanswered calls to the destination after the number of rings occurs.
    forward_enabled: Optional[bool]
    #: Number of rings before forwarding calls if forwardEnabled is true.
    number_of_rings: Optional[int]
    #: Destination if forwardEnabled is True.
    destination: Optional[str]
    #: If forwardEnabled is true, enables and disables sending incoming to destination number's voicemail if the
    #: destination is an internal phone number and that number has the voicemail service enabled.
    destination_voicemail_enabled: Optional[bool]


class BusinessContinuity(NewNumber):
    #: Indicates enabled or disabled state of sending diverted incoming calls to the destination number's voicemail if
    #: the destination is an internal phone number and that number has the voicemail service enabled.
    destination_voicemail_enabled: Optional[bool]


class PostHuntGroupCallPolicyObject(ApiModel):
    #: Call routing policy to use to dispatch calls to agents.
    policy: Optional[HuntPolicySelection]
    #: If false, then the option is treated as "Advance when busy": the hunt group won't ring agents when they're on a
    #: call and will advance to the next agent. If a hunt group agent has call waiting enabled and the call is advanced
    #: to them, then the call will wait until that hunt group agent isn't busy.
    waiting_enabled: Optional[bool]
    #: Settings for when the call into the hunt group is not answered.
    no_answer: Optional[NoAnswer]
    #: Settings for sending calls to a destination of your choice if your phone is not connected to the network for any
    #: reason, such as power outage, failed Internet connection, or wiring problem.
    business_continuity: Optional[BusinessContinuity]


class GetPersonPlaceVirtualLineHuntGroupObject(PostPersonPlaceVirtualLineHuntGroupObject):
    #: First name of person, workspace or virtual line.
    first_name: Optional[str]
    #: Last name of person, workspace or virtual line.
    last_name: Optional[str]
    #: Phone number of person, workspace or virtual line.
    phone_number: Optional[str]
    #: Extension of person, workspace or virtual line.
    extension: Optional[str]


class GetSelectiveCallForwardingRuleForCallQueueResponse(CreateSelectiveCallForwardingRuleForCallQueueBody):
    #: Unique ID for the rule.
    id: Optional[str]


class Type48(str, Enum):
    #: Intercept all inbound calls.
    intercept_all = 'INTERCEPT_ALL'
    #: Allow all inbound calls.
    allow_all = 'ALLOW_ALL'


class Announcements3(ApiModel):
    #: DEFAULT indicates that a system default message will be placed when incoming calls are intercepted.
    greeting: Optional[Greeting]
    #: Information about the new number announcement.
    new_number: Optional[NewNumber]
    #: Information about how call will be handled if zero (0) is pressed.
    zero_transfer: Optional[NewNumber]


class Announcements(Announcements3):
    #: If set to CUSTOM for greeting, filename of previously uploaded file.
    file_name: Optional[str]


class Incoming(ApiModel):
    #: Select inbound call options.
    type: Optional[Type48]
    #: Enable/disable to route voice mail.
    voicemail_enabled: Optional[bool]
    #: Announcements details.
    announcements: Optional[Announcements]


class Type49(str, Enum):
    #: Intercept all outbound calls.
    intercept_all = 'INTERCEPT_ALL'
    #: Allow local outbound calls.
    allow_local_only = 'ALLOW_LOCAL_ONLY'


class Outgoing(ApiModel):
    #: Outbound call modes
    type: Optional[Type49]
    #: Enable/disable to route all outbound calls to phone number.
    transfer_enabled: Optional[bool]
    #: If enabled, set outgoing destination phone number.
    destination: Optional[str]


class GetLocationInterceptResponse(ApiModel):
    #: Enable/disable location intercept. Enable this feature to override any Location's Call Intercept settings that
    #: person configures.
    enabled: Optional[bool]
    #: Inbound call details.
    incoming: Optional[Incoming]
    #: Outbound Call details
    outgoing: Optional[Outgoing]


class RouteType(ApiModel):
    #: Route group must include at least one trunk with a maximum of 10 trunks per route group.
    route_group: Optional[str]
    #: Connection between Webex Calling and the premises.
    trunk: Optional[str]


class RouteIdentity(Role):
    #: Type associated with the identity.
    type: Optional[RouteType]


class UnknownExtensionRouteIdentity(ApiModel):
    #: ID of the route type.
    id: Optional[str]
    #: Type associated with the identity.
    type: Optional[RouteType]


class CallingLineId(ApiModel):
    #: Group calling line ID name. By default the Org name.
    name: Optional[str]
    #: Directory Number / Main number in E.164 Format.
    phone_number: Optional[str]


class UpdateLocationWebexCallingDetailsBody(ApiModel):
    #: Location's phone announcement language.
    announcement_language: Optional[str]
    #: Location calling line information.
    calling_line_id: Optional[CallingLineId]
    #: Connection details can only be modified to and from local PSTN types of TRUNK and ROUTE_GROUP.
    connection: Optional[UnknownExtensionRouteIdentity]
    #: Denve' (string) - External Caller ID Name value. Unicode characters.
    external_caller_id_name: Optional[str]
    #: Location Identifier.
    p_access_network_info: Optional[str]
    #: Must dial to reach an outside line. Default is None.
    outside_dial_digit: Optional[str]
    #: Must dial a prefix when calling between locations having same extension within same location; should be numeric.
    routing_prefix: Optional[str]
    #: Chargeable number for the line placing the call. When this is set, all calls placed from this location will
    #: include a P-Charge-Info header with the selected number in the SIP INVITE.
    charge_number: Optional[str]


class ListLocationObject(Role):
    #: Must dial to reach an outside line, default is None.
    outside_dial_digit: Optional[str]
    #: Must dial a prefix when calling between locations having the same extension within the same location.
    routing_prefix: Optional[str]
    #: Location calling line information.
    calling_line_id: Optional[CallingLineId]
    #: True if E911 setup is required.
    e911_setup_required: Optional[bool]


class CallType3(str, Enum):
    #: Controls calls within your own company.
    internal_call = 'INTERNAL_CALL'
    #: Controls calls to a telephone number that is billed for all arriving calls instead of incurring charges to the
    #: originating caller, usually free of charge from a landline.
    toll_free = 'TOLL_FREE'
    #: Controls calls to locations outside of the Long Distance areas that require an international calling code before
    #: the number is dialed.
    international = 'INTERNATIONAL'
    #: Controls calls requiring Operator Assistance.
    operator_assisted = 'OPERATOR_ASSISTED'
    #: Controls calls to Directory Assistant companies that require a charge to connect the call.
    chargeable_directory_assisted = 'CHARGEABLE_DIRECTORY_ASSISTED'
    #: Controls calls to carrier-specific number assignments to special services or destinations.
    special_services_i = 'SPECIAL_SERVICES_I'
    #: Controls calls to carrier-specific number assignments to special services or destinations.
    special_services_ii = 'SPECIAL_SERVICES_II'
    #: Controls calls used to provide information or entertainment for a fee charged directly to the caller.
    premium_services_i = 'PREMIUM_SERVICES_I'
    #: Controls calls used to provide information or entertainment for a fee charged directly to the caller.
    premium_services_ii = 'PREMIUM_SERVICES_II'
    #: Controls calls that are National.
    national = 'NATIONAL'


class Action9(str, Enum):
    #: Callers at this location can make these types of calls.
    allow = 'ALLOW'
    #: Callers at this location can't make these types of calls.
    block = 'BLOCK'
    #: Callers must enter the authorization code that you set before placing an outgoing call.
    auth_code = 'AUTH_CODE'
    #: If you select this, then these types of calls are transferred automatically to the configured auto transfer
    #: number autoTransferNumber1.
    transfer_number_1 = 'TRANSFER_NUMBER_1'
    #: If you select this, then these types of calls are transferred automatically to the configured auto transfer
    #: number autoTransferNumber2.
    transfer_number_2 = 'TRANSFER_NUMBER_2'
    #: If you select this, then these types of calls are transferred automatically to the configured auto transfer
    #: number autoTransferNumber3.
    transfer_number_3 = 'TRANSFER_NUMBER_3'


class CallingPermissionObject(ApiModel):
    #: Below are the call type values.
    call_type: Optional[CallType3]
    #: Allows to configure settings for each call type.
    action: Optional[Action9]
    #: If enabled, allow the person to transfer or forward internal calls.
    transfer_enabled: Optional[bool]


class GetOutgoingPermissionAutoTransferNumberResponse(ApiModel):
    #: Calls placed meeting the criteria in an outbound rule whose action is TRANSFER_NUMBER_1 will be transferred to
    #: this number.
    auto_transfer_number1: Optional[str]
    #: Calls placed meeting the criteria in an outbound rule whose action is TRANSFER_NUMBER_2 will be transferred to
    #: this number.
    auto_transfer_number2: Optional[str]
    #: Calls placed meeting the criteria in an outbound rule whose action is TRANSFER_NUMBER_3 will be transferred to
    #: this number.
    auto_transfer_number3: Optional[str]


class GetPagingGroupAgentObject(CallForwardSelectiveCallsToNumbersObject):
    #: Agents ID.
    id: Optional[str]
    #: Agents first name. Minimum length is 1. Maximum length is 30.
    first_name: Optional[str]
    #: Agents last name. Minimum length is 1. Maximum length is 30.
    last_name: Optional[str]


class CreatenewPagingGroupBody(GetDetailsForCallParkExtensionResponse):
    #: Paging group phone number. Minimum length is 1. Maximum length is 23. Either phoneNumber or extension is
    #: mandatory.
    phone_number: Optional[str]
    #: Language code.
    language_code: Optional[str]
    #: First name that displays when a group page is performed. Minimum length is 1. Maximum length is 30.
    first_name: Optional[str]
    #: Last name that displays when a group page is performed. Minimum length is 1. Maximum length is 30.
    last_name: Optional[str]
    #: Determines what is shown on target users caller ID when a group page is performed. If true shows page originator
    #: ID.
    originator_caller_id_enabled: Optional[bool]
    #: An array of people, workspace, and virtual lines IDs who can originate pages to this paging group.
    originators: Optional[list[str]]
    #: An array of people, workspaces and virtual lines IDs will add to a paging group as paging call targets.
    targets: Optional[list[str]]


class State11(str, Enum):
    #: Active state.
    active = 'ACTIVE'
    #: Inactive state
    inactive = 'INACTIVE'


class AddPhoneNumbersTolocationBody(ApiModel):
    #: List of phone numbers that need to be added.
    phone_numbers: Optional[list[str]]
    #: State of the phone numbers.
    state: Optional[State11]


class Owner(ApiModel):
    #: ID of the owner to which PSTN Phone number is assigned.
    id: Optional[str]
    #: Type of the PSTN phone number's owner
    type: Optional[str]
    #: First name of the PSTN phone number's owner
    first_name: Optional[str]
    #: Last name of the PSTN phone number's owner
    last_name: Optional[str]


class NumberListGetObject(ApiModel):
    #: A unique identifier for the PSTN phone number.
    phone_number: Optional[str]
    #: Extension for a PSTN phone number.
    extension: Optional[str]
    #: Phone number's state.
    state: Optional[str]
    #: Type of phone number.
    phone_number_type: Optional[str]
    #: Indicates if the phone number is used as location clid.
    main_number: Optional[bool]
    #: Indicates if a phone number is a toll free number.
    toll_free_number: Optional[bool]
    location: Optional[Role]
    owner: Optional[Owner]


class JobExecutionStatusObject1(ApiModel):
    #: Unique identifier that identifies each instance of the job.
    id: Optional[int]
    #: Last updated time (in UTC format) post one of the step execution completion.
    last_updated: Optional[str]
    #: Displays status for overall steps that are part of the job.
    status_message: Optional[str]
    #: Exit Code for a job.
    exit_code: Optional[str]
    #: Job creation time in UTC format.
    created_time: Optional[str]
    #: Time lapsed since the job execution started.
    time_elapsed: Optional[str]


class CountObject(ApiModel):
    #: Indicates the total number of phone numbers requested to be moved.
    total_numbers: Optional[int]
    #: Indicates the total number of phone numbers successfully deleted.
    numbers_deleted: Optional[int]
    #: Indicates the total number of phone numbers successfully moved.
    numbers_moved: Optional[int]
    #: Indicates the total number of phone numbers failed.
    numbers_failed: Optional[int]


class StartJobResponse(Role):
    #: Job type.
    job_type: Optional[str]
    #: Unique identifier to track the flow of HTTP requests.
    tracking_id: Optional[str]
    #: Unique identifier to identify which user has run the job.
    source_user_id: Optional[str]
    #: Unique identifier to identify the customer who has run the job.
    source_customer_id: Optional[str]
    #: Unique identifier to identify the customer for which the job was run.
    target_customer_id: Optional[str]
    #: Unique identifier to identify the instance of the job.
    instance_id: Optional[int]
    #: Displays the most recent step's execution status. Contains execution statuses of all the steps involved in the
    #: execution of the job.
    job_execution_status: Optional[list[JobExecutionStatusObject1]]
    #: Indicates the most recent status (STARTING, STARTED, COMPLETED, FAILED) of the job at the time of invocation.
    latest_execution_status: Optional[str]
    #: Indicates operation type that was carried out.
    operation_type: Optional[str]
    #: Unique location identifier for which the job was run.
    source_location_id: Optional[str]
    #: Unique location identifier for which the numbers have been moved.
    target_location_id: Optional[str]
    #: Job statistics.
    counts: Optional[CountObject]


class NumberItem(ApiModel):
    #: The source location of the numbers to be moved.
    location_id: Optional[str]
    #: Indicates the numbers to be moved from one location to another location.
    numbers: Optional[list[str]]


class StepExecutionStatusesObject(Role):
    #: Step execution start time in UTC format.
    start_time: Optional[str]
    #: Step execution end time in UTC format.
    end_time: Optional[str]
    #: Last updated time for a step in UTC format.
    last_updated: Optional[str]
    #: Displays status for a step.
    status_message: Optional[str]
    #: Exit Code for a step.
    exit_code: Optional[str]
    #: Time lapsed since the step execution started.
    time_elapsed: Optional[str]


class JobExecutionStatusObject(JobExecutionStatusObject1):
    #: Status of each step within a job.
    step_execution_statuses: Optional[list[StepExecutionStatusesObject]]


class ErrorMessageObject(ReportError):
    #: Error messages describing the location id in which the error occurs. For a move operation this is the target
    #: location ID.
    location_id: Optional[str]


class ErrorObject(ApiModel):
    #: HTTP error code.
    key: Optional[str]
    #: Message string with further error information.
    message: Optional[list[ErrorMessageObject]]


class ItemObject(ApiModel):
    #: Phone number
    item: Optional[str]
    #: Index of error number.
    item_number: Optional[int]
    #: Unique identifier to track the HTTP requests.
    tracking_id: Optional[str]
    error: Optional[ErrorObject]


class NetworkConnectionType(str, Enum):
    #: Use public internet for the location's connection type.
    public_internet = 'PUBLIC_INTERNET'
    #: Use private network connect for the location's connection type.
    private_network = 'PRIVATE_NETWORK'


class Type54(str, Enum):
    #: Business hours schedule type.
    business_hours = 'businessHours'
    #: Holidays schedule type.
    holidays = 'holidays'


class ListScheduleObject(ListCallParkObject):
    #: Type of the schedule.
    type: Optional[Type54]


class RecurWeeklyObject(ApiModel):
    #: Frequency of occurrence in weeks and select the day - Sunday.
    sunday: Optional[bool]
    #: Frequency of occurrence in weeks and select the day - Monday.
    monday: Optional[bool]
    #: Frequency of occurrence in weeks and select the day - Tuesday.
    tuesday: Optional[bool]
    #: Frequency of occurrence in weeks and select the day - Wednesday.
    wednesday: Optional[bool]
    #: Frequency of occurrence in weeks and select the day - Thursday.
    thursday: Optional[bool]
    #: Frequency of occurrence in weeks and select the day - Friday.
    friday: Optional[bool]
    #: Frequency of occurrence in weeks and select the day - Saturday.
    saturday: Optional[bool]


class Month(str, Enum):
    january = 'JANUARY'
    february = 'FEBRUARY'
    march = 'MARCH'
    april = 'APRIL'
    may = 'MAY'
    june = 'JUNE'
    july = 'JULY'
    august = 'AUGUST'
    september = 'SEPTEMBER'
    october = 'OCTOBER'
    november = 'NOVEMBER'
    december = 'DECEMBER'


class RecurYearlyByDateObject(ApiModel):
    #: Schedule the event on a specific day of the month.
    day_of_month: Optional[int]
    #: Schedule the event on a specific month of the year.
    month: Optional[Month]


class Day(str, Enum):
    sunday = 'SUNDAY'
    monday = 'MONDAY'
    tuesday = 'TUESDAY'
    wednesday = 'WEDNESDAY'
    thursday = 'THURSDAY'
    friday = 'FRIDAY'
    saturday = 'SATURDAY'


class Week(str, Enum):
    first = 'FIRST'
    second = 'SECOND'
    third = 'THIRD'
    fourth = 'FOURTH'
    last = 'LAST'


class RecurYearlyByDayObject(ApiModel):
    #: Schedule the event on a specific day.
    day: Optional[Day]
    #: Schedule the event on a specific week.
    week: Optional[Week]
    #: Schedule the event on a specific month.
    month: Optional[Month]


class RecurrenceObject1(ApiModel):
    #: Flag to indicate if event will recur forever.
    recur_for_ever: Optional[bool]
    #: End date of recurrence.
    recur_end_date: Optional[str]
    #: Weekly recurrence definition.
    recur_weekly: Optional[RecurWeeklyObject]
    #: Recurrence definition yearly by date.
    recur_yearly_by_date: Optional[RecurYearlyByDateObject]
    #: Recurrence definition yearly by day.
    recur_yearly_by_day: Optional[RecurYearlyByDayObject]


class ScheduleEventObject(ApiModel):
    #: Name for the event.
    name: Optional[str]
    #: Start date of event.
    start_date: Optional[str]
    #: End date of event.
    end_date: Optional[str]
    #: Start time of event. Mandatory if the event is not all day.
    start_time: Optional[str]
    #: End time of event. Mandatory if the event is not all day.
    end_time: Optional[str]
    #: An indication of whether given event is an all-day event or not. Mandatory if the startTime and endTime are not
    #: defined.
    all_day_enabled: Optional[bool]
    #: Recurrence definition.
    recurrence: Optional[RecurrenceObject1]


class GetScheduleEventObject(ScheduleEventObject):
    #: A unique identifier for the schedule event.
    id: Optional[str]


class ModifyScheduleEventListObject(ScheduleEventObject):
    #: New name for the event.
    new_name: Optional[str]


class ExternalCallerIdNamePolicy(str, Enum):
    #: Shows virtual lines Caller ID name.
    direct_line = 'DIRECT_LINE'
    #: Shows virtual lines location name.
    location = 'LOCATION'
    #: Allow virtual lines first/last name to be configured.
    other = 'OTHER'


class ListVirtualLineObject(ApiModel):
    #: A unique identifier for the virtual line.
    id: Optional[str]
    #: Last name for virtual line.
    last_name: Optional[str]
    #: First name for virtual line.
    first_name: Optional[str]
    #: callerIdLastName for virtual line.
    caller_id_last_name: Optional[str]
    #: callerIdFirstName for virtual line.
    caller_id_first_name: Optional[str]
    #: callerIdNumber for virtual line.
    caller_id_number: Optional[str]
    #: externalCallerIdNamePolicy for the virtual line.
    external_caller_id_name_policy: Optional[ExternalCallerIdNamePolicy]
    #: customExternalCallerIdName for virtual line.
    custom_external_caller_id_name: Optional[str]
    #: Calling details of virtual line.
    number: Optional[GetUserNumberItemObject]
    #: Location details of virtual line.
    location: Optional[Role]
    #: Number of devices assigned to a virtual line.
    number_of_devices_assigned: Optional[int]
    #: Type of billing plan.
    billing_plan: Optional[str]


class GetVoicemailSettingsResponse(ApiModel):
    #: When enabled, you can set the deletion conditions for expired messages.
    message_expiry_enabled: Optional[bool]
    #: Number of days after which messages expire.
    number_of_days_for_message_expiry: Optional[int]
    #: When enabled, all read and unread voicemail messages will be deleted based on the time frame you set. When
    #: disabled, all unread voicemail messages will be kept.
    strict_deletion_enabled: Optional[bool]
    #: When enabled, people in the organization can configure the email forwarding of voicemails.
    voice_message_forwarding_enabled: Optional[bool]


class BlockRepeatedDigits(ApiModel):
    #: If enabled, passcode should not contain repeated digits.
    enabled: Optional[bool]
    #: Maximum number of repeaed digits. The minimum value is 1. The maximum value is 6.
    max: Optional[int]


class BlockContiguousSequences(ApiModel):
    #: If enabled, passcode should not contain a numerical sequence.
    enabled: Optional[bool]
    #: Number of ascending digits in sequence. The minimum value is 2. The maximum value is 5.
    number_of_ascending_digits: Optional[int]
    #: Number of descending digits in sequence. The minimum value is 2. The maximum value is 5.
    number_of_descending_digits: Optional[int]


class Length(ApiModel):
    #: The minimum value is 2. The maximum value is 15.
    min: Optional[int]
    #: The minimum value is 3. The maximum value is 30.
    max: Optional[int]


class DefaultVoicemailPinRules(ApiModel):
    #: If enabled, the passcode should not contain repeated pattern.
    block_repeated_patterns_enabled: Optional[bool]
    #: Settings for not allowing single or groups of repeated digits in passcode (for example, 22888, 121212, or
    #: 408408).
    block_repeated_digits: Optional[BlockRepeatedDigits]
    #: Settings for not allowing numerical sequence in passcode (for example, 012345 or 987654).
    block_contiguous_sequences: Optional[BlockContiguousSequences]
    #: Length of the passcode.
    length: Optional[Length]
    #: If enabled, the default voicemail passcode can be set.
    default_voicemail_pin_enabled: Optional[bool]


class ExpirePasscode(ApiModel):
    #: If enabled, passcode expires after the number of days specified.
    enabled: Optional[bool]
    #: Number of days for password expiry. The minimum value is 15. The maximum value is 180.
    number_of_days: Optional[int]


class BlockPreviousPasscodes(ApiModel):
    #: If enabled, set how many of the previous passcodes are not allowed to be re-used.
    enabled: Optional[bool]
    #: Number of previous passcodes. The minimum value is 1. The maximum value is 10.
    number_of_passcodes: Optional[int]


class Passcode(ApiModel):
    #: New passcode.
    new_passcode: Optional[str]
    #: Confirm new passcode.
    confirm_passcode: Optional[str]


class FailedAttempts(ApiModel):
    #: If enabled, allows specified number of attempts before locking voice portal access.
    enabled: Optional[bool]
    #: Number of failed attempts allowed.
    attempts: Optional[int]


class Greeting29(str, Enum):
    #: Play default music when call is placed on hold or parked. The system plays music to fill the silence and lets
    #: the customer know they are still connected.
    system = 'SYSTEM'
    #: Play previously uploaded custom music when call is placed on hold or parked.
    custom = 'CUSTOM'


class GetMusicOnHoldResponse(ApiModel):
    #: If enabled, music will be played when call is placed on hold.
    call_hold_enabled: Optional[bool]
    #: If enabled, music will be played when call is parked.
    call_park_enabled: Optional[bool]
    #: Greeting type for the location.
    greeting: Optional[Greeting29]


class GetVoicemailGroupObject(ListAutoAttendantObject):
    #: If enabled, incoming calls are sent to voicemail.
    enabled: Optional[bool]


class StorageType(str, Enum):
    #: Store messages in internal mailbox.
    internal = 'INTERNAL'
    #: Send messages to the email address provided.
    external = 'EXTERNAL'


class MessageStorage(ApiModel):
    #: Message storage type
    storage_type: Optional[StorageType]
    #: External email to forward the message.
    external_email: Optional[str]


class EmailCopyOfMessage(ApiModel):
    #: Enable/disable to email message copy.
    enabled: Optional[bool]
    #: Email message copy to email address provided.
    email_id: Optional[str]


class DialPattern(ApiModel):
    #: A unique dial pattern.
    dial_pattern: Optional[str]
    #: Action to add or delete a pattern.
    action: Optional[DialPatternAction]


class DialPatternValidate(ApiModel):
    #: Input dial pattern that is being validated.
    dial_pattern: Optional[str]
    #: Validation status.
    pattern_status: Optional[DialPatternStatus]
    #: Failure details.
    message: Optional[str]


class ModifyDialPlanBody(ApiModel):
    #: A unique name for the dial plan.
    name: Optional[str]
    #: ID of route type associated with the dial plan.
    route_id: Optional[str]
    #: Route Type associated with the dial plan.
    route_type: Optional[RouteType]


class DialPlan(ModifyDialPlanBody):
    #: Unique identifier for the dial plan.
    id: Optional[str]
    #: Name of route type associated with the dial plan.
    route_name: Optional[str]


class TrunkType(ApiModel):
    #: For Cisco CUBE Local Gateway.
    registering: Optional[str]
    #: For Cisco Unified Border Element, Oracle ACME Session Border Controller, AudioCodes Session Border Controller,
    #: Ribbon Session Border Controller.
    certificate_based: Optional[str]


class Trunk(Role):
    #: Location associated with the trunk.
    location: Optional[Role]
    #: Trunk in use flag.
    in_use: Optional[bool]
    #: Trunk Type associated with the trunk.
    trunk_type: Optional[TrunkType]


class ModifyTrunkBody(ApiModel):
    #: A unique name for the dial plan.
    name: Optional[str]
    #: A password to use on the trunk.
    password: Optional[str]
    #: Determines the behavior of the From and PAI headers on outbound calls.
    dual_identity_support_enabled: Optional[bool]
    #: Max Concurrent call. Required to create a static certificate-based trunk.
    max_concurrent_calls: Optional[int]


class DeviceStatus(ApiModel):
    #: Device is online
    online: Optional[str]
    #: Device is offline
    offline: Optional[str]
    #: Unknown. Default
    unknown: Optional[str]


class ResponseStatusType(ApiModel):
    #: Error
    error: Optional[str]
    #: Warning
    warning: Optional[str]


class ResponseStatus(ApiModel):
    #: Error Code. 25013 for error retrieving the outbound proxy. 25014 for error retrieving the status
    code: Optional[int]
    #: Status type.
    type: Optional[ResponseStatusType]
    #: Error summary in English.
    summary_english: Optional[str]
    #: Error Details.
    detail: Optional[list[str]]
    #: Error Tracking ID.
    tracking_id: Optional[str]


class ValidateLocalGatewayFQDNAndDomainForTrunkBody(ApiModel):
    #: FQDN or SRV address of the trunk.
    address: Optional[str]
    #: Domain name of the trunk.
    domain: Optional[str]
    #: FQDN port of the trunk.
    port: Optional[int]


class DeviceType(ApiModel):
    #: Device type assosiated with trunk configuration.
    device_type: Optional[str]
    #: Minimum number of concurrent calls. Required for static certificate based trunk.
    min_concurrent_calls: Optional[int]
    #: Maximum number of concurrent calls. Required for static certificate based trunk.
    max_concurrent_calls: Optional[int]


class TrunkTypeWithDeviceType(ApiModel):
    #: Trunk Type associated with the trunk.
    trunk_type: Optional[TrunkType]
    #: Device types for trunk configuration.
    device_types: Optional[list[DeviceType]]


class RouteGroup(Role):
    #: Flag to indicate if the route group is used.
    in_use: Optional[bool]


class LocalGateways(Role):
    #: Location ID to which local gateway belongs.
    location_id: Optional[str]
    #: Prioritizes local gateways based on these numbers; the lowest number gets the highest priority.
    priority: Optional[int]


class CreateRouteGroupForOrganizationBody(ApiModel):
    #: A unique name for the Route Group.
    name: Optional[str]
    #: Local Gateways that are part of this Route Group.
    local_gateways: Optional[list[LocalGateways]]


class RouteGroupUsageRouteListGet(ApiModel):
    #: List of route lists for this route group.
    route_lists: Optional[list[ListCallParkObject]]


class ModifyRouteListBody(ApiModel):
    #: Route List new name.
    name: Optional[str]
    #: New route group ID.
    route_group_id: Optional[str]


class RouteListNumberPatch(ApiModel):
    #: Number to be deleted/added.
    number: Optional[str]
    #: Possible value, ADD or DELETE.
    action: Optional[DialPatternAction]


class NumberStatus(DialPatternStatus):
    unavailable: Optional[str]


class RouteListNumberPatchResponse(ApiModel):
    #: Phone Number whose status is being reported.
    phone_number: Optional[str]
    #: Status of the number. Possible values are INVALID, DUPLICATE, DUPLICATE_IN_LIST, or UNAVAILABLE.
    number_status: Optional[NumberStatus]
    #: Message of the number add status.
    message: Optional[str]


class HolidayScheduleLevel(str, Enum):
    #: Specifies this Schedule is configured across location.
    location = 'LOCATION'
    #: Specifies this Schedule is configured across organization.
    organization = 'ORGANIZATION'


class CallQueueHolidaySchedulesObject(ApiModel):
    #: Name of the schedule configured for a holiday service.
    schedule_name: Optional[str]
    #: Specifies whether the schedule mentioned in scheduleName is org or location specific.
    schedule_level: Optional[HolidayScheduleLevel]


class Action11(str, Enum):
    #: The caller hears a fast-busy tone.
    busy = 'BUSY'
    #: Transfers the call to number specified in transferPhoneNumber.
    transfer = 'TRANSFER'


class Action15(Action11):
    #: Call remains in the queue.
    none = 'NONE'
    #: Calls are handled according to the Night Service configuration. If the Night Service action is set to none, then
    #: this is equivalent to this policy being set to none (that is, calls remain in the queue).
    night_service = 'NIGHT_SERVICE'
    #: Calls are removed from the queue and are provided with ringing until the caller releases the call. The ringback
    #: tone played to the caller is localized according to the country code of the caller.
    ringing = 'RINGING'
    #: Calls are removed from the queue and are provided with an announcement that is played in a loop until the caller
    #: releases the call.
    announcement = 'ANNOUNCEMENT'


class CallQueueAudioFilesObject(ApiModel):
    #: Name of the file.
    file_name: Optional[str]
    #: Media Type of the audio file.
    media_file_type: Optional[MediaType]


class GetDetailsForCallQueueStrandedCallsResponse(ApiModel):
    #: Specifies call processing action type.
    action: Optional[Action15]
    #: Call gets transferred to this number when action is set to TRANSFER. This can also be an extension.
    transfer_phone_number: Optional[str]
    #: Specifies what type of announcement to be played.
    audio_message_selection: Optional[Greeting]
    #: List of Announcement Audio Files when audioMessageSelection is CUSTOM.
    audio_files: Optional[list[CallQueueAudioFilesObject]]


class AnnouncementMode(str, Enum):
    #: Plays announcement as per audioMessageSelection.
    normal = 'NORMAL'
    #: Plays announcement as per manualAudioMessageSelection.
    manual = 'MANUAL'


class GetDetailsForCallQueueForcedForwardResponse(ApiModel):
    #: Whether or not the call queue forced forward routing policy setting is enabled.
    forced_forward_enabled: Optional[bool]
    #: Call gets transferred to this number when action is set to TRANSFER. This can also be an extension.
    transfer_phone_number: Optional[str]
    #: Specifies if an announcement plays to callers before applying the action.
    play_announcement_before_enabled: Optional[bool]
    #: Specifies what type of announcement to be played.
    audio_message_selection: Optional[Greeting]
    #: List of Announcement Audio Files when audioMessageSelection is CUSTOM.
    audio_files: Optional[list[CallQueueAudioFilesObject]]


class TypeObject(ApiModel):
    #: Cisco Multiplatform Phone
    mpp: Optional[str]
    #: Analog Telephone Adapters
    ata: Optional[str]
    #: GENERIC Session Initiation Protocol
    generic_sip: Optional[str]
    #: Esim Supported Webex Go
    esim: Optional[str]


class ManufacturerObject(ApiModel):
    #: Devices manufactured by Cisco.
    cisco: Optional[str]
    #: Devices manufactured by a third-party that are approved by a Cisco account manager to be enabled for
    #: provisioning in the control hub.
    third_party: Optional[str]


class ManagedByObject(ApiModel):
    #: Devices managed by Cisco.
    cisco: Optional[str]
    #: Devices managed by a customer that are approved by a Cisco account manager to be enabled for provisioning in the
    #: control hub.
    customer: Optional[str]


class OnboardingMethodObject(ApiModel):
    mac_address: Optional[str]
    activation_code: Optional[str]
    none: Optional[str]


class KemModuleTypeObject(ApiModel):
    kem_14_keys: Optional[str]
    kem_18_keys: Optional[str]


class DeviceObject(ApiModel):
    #: Model name of the device.
    model: Optional[str]
    #: Display name of the device.
    display_name: Optional[str]
    #: Type of the device.
    type: Optional[TypeObject]
    #: Manufacturer of the device.
    manufacturer: Optional[ManufacturerObject]
    #: Users who manage the device.
    managed_by: Optional[ManagedByObject]
    #: List of places the device is supported for.
    supported_for: Optional[list[MemberType]]
    #: Onboarding method.
    onboarding_method: Optional[list[OnboardingMethodObject]]
    #: Enables / Disables layout configuration for devices.
    allow_configure_layout_enabled: Optional[bool]
    #: Number of port lines.
    number_of_line_ports: Optional[int]
    #: Indicates whether Kem support is enabled or not.
    kem_support_enabled: Optional[bool]
    #: Module count.
    kem_module_count: Optional[int]
    #: Key expansion module type of the device.
    kem_module_type: Optional[list[KemModuleTypeObject]]
    #: Enables / Disables the upgrade channel.
    upgrade_channel_enabled: Optional[bool]
    #: The default upgrade channel.
    default_upgrade_channel: Optional[str]
    #: Enables / disables the additional primary line appearances.
    additional_primary_line_appearances_enabled: Optional[bool]
    #: Enables / disables Basic emergency nomadic.
    basic_emergency_nomadic_enabled: Optional[bool]
    #: Enables / disables customized behavior support on devices.
    customized_behaviors_enabled: Optional[bool]
    #: Enables / disables configuring port support on device.
    allow_configure_ports_enabled: Optional[bool]
    #: Enables / disables customizable line label.
    customizable_line_label_enabled: Optional[bool]


class DectObject(ApiModel):
    #: Choose up to three predefined codec priority options available for your region.
    audio_codec_priority: Optional[AudioCodecPriorityObject]
    #: Enable/disable Cisco Discovery Protocol for local devices.
    cdp_enabled: Optional[bool]
    #: Specify the destination number to be dialled from the DECT Handset top button when pressed.
    dect6825_handset_emergency_number: Optional[str]
    #: Enable/disable Link Layer Discovery Protocol for local devices.
    lldp_enabled: Optional[bool]
    #: Specify up to 3 multicast group URLs each with a unique listening port.
    multicast: Optional[str]
    #: Enable/disable quality of service tagging of packets from the local device to the Webex Calling platform.
    qos_enabled: Optional[bool]
    #: Specify a numeric Virtual LAN ID for devices.
    vlan: Optional[VlanObject]


class CustomizationObject(CustomizationDeviceLevelObject):
    #: Settings that are applicable to DECT devices.
    dect: Optional[DectObject]


class DectDeviceList(ApiModel):
    #: Model name of the device.
    model: Optional[str]
    #: Display name of the device.
    display_name: Optional[str]
    #: Indicates number of base stations.
    number_of_base_stations: Optional[int]
    #: Indicates number of port lines,
    number_of_line_ports: Optional[int]
    #: Indicates number of supported registrations.
    number_of_registrations_supported: Optional[int]


class State13(str, Enum):
    #: The requested MAC address is available.
    available = 'AVAILABLE'
    #: The requested MAC address is unavailable.
    unavailable = 'UNAVAILABLE'
    #: The requested MAC address is duplicated.
    duplicate_in_list = 'DUPLICATE_IN_LIST'
    #: The requested MAC address is invalid.
    invalid = 'INVALID'


class MacStatusObject(ApiModel):
    #: MAC address.
    mac: Optional[str]
    #: State of the MAC address.
    state: Optional[State13]
    #: MAC address validation error code.
    error_code: Optional[int]
    #: Provides a status message about the MAC address.
    message: Optional[str]


class GetManageNumbersJobStatusResponse(Role):
    #: Job type.
    job_type: Optional[str]
    #: Unique identifier to track the flow of HTTP requests.
    tracking_id: Optional[str]
    #: Unique identifier to identify which user has run the job.
    source_user_id: Optional[str]
    #: Unique identifier to identify the customer who has run the job.
    source_customer_id: Optional[str]
    #: Unique identifier to identify the customer for which the job was run.
    target_customer_id: Optional[str]
    #: Unique identifier to identify the instance of the job.
    instance_id: Optional[int]
    #: Displays the most recent step's execution status. Contains execution statuses of all the steps involved in the
    #: execution of the job.
    job_execution_status: Optional[list[JobExecutionStatusObject]]
    #: Indicates the most recent status (STARTING, STARTED, COMPLETED, FAILED) of the job at the time of invocation.
    latest_execution_status: Optional[str]
    #: Indicates the operation type that was carried out.
    operation_type: Optional[str]
    #: Unique location identifier for which the job was run.
    source_location_id: Optional[str]
    #: Unique location identifier for which the numbers have been moved.
    target_location_id: Optional[str]
    #: The location name for which the job was run.
    source_location_name: Optional[str]
    #: The location name for which the numbers have been moved.
    target_location_name: Optional[str]
    #: Job statistics.
    counts: Optional[CountObject]


class ChangeAnnouncementLanguageBody(ApiModel):
    #: Set to true to change announcement language for existing people and workspaces.
    agent_enabled: Optional[bool]
    #: Set to true to change announcement language for existing feature configurations.
    service_enabled: Optional[bool]
    #: Language code.
    announcement_language_code: Optional[str]


class ReadListOfAutoAttendantsResponse(ApiModel):
    #: Array of auto attendants.
    auto_attendants: Optional[list[ListAutoAttendantObject]]


class GetDetailsForAutoAttendantResponse(FaxMessage):
    #: A unique identifier for the auto attendant.
    id: Optional[str]
    #: Unique name for the auto attendant.
    name: Optional[str]
    #: Flag to indicate if auto attendant number is toll-free number.
    toll_free_number: Optional[bool]
    #: First name defined for an auto attendant.
    first_name: Optional[str]
    #: Last name defined for an auto attendant.
    last_name: Optional[str]
    #: Alternate numbers defined for the auto attendant.
    alternate_numbers: Optional[list[AlternateNumbersObject]]
    #: Language for the auto attendant.
    language: Optional[str]
    #: Language code for the auto attendant.
    language_code: Optional[str]
    #: Business hours defined for the auto attendant.
    business_schedule: Optional[str]
    #: Holiday defined for the auto attendant.
    holiday_schedule: Optional[str]
    #: Extension dialing setting. If the values are not set default will be set as ENTERPRISE.
    extension_dialing: Optional[ExtensionDialing]
    #: Name dialing setting. If the values are not set default will be set as ENTERPRISE.
    name_dialing: Optional[ExtensionDialing]
    #: Time zone defined for the auto attendant.
    time_zone: Optional[str]
    #: Business hours menu defined for the auto attendant.
    business_hours_menu: Optional[HoursMenuObject]
    #: After hours menu defined for the auto attendant.
    after_hours_menu: Optional[HoursMenuObject]


class CreateAutoAttendantBody(GetDetailsForCallParkExtensionResponse):
    #: Auto attendant phone number. Either phoneNumber or extension is mandatory.
    phone_number: Optional[str]
    #: First name defined for an auto attendant.
    first_name: Optional[str]
    #: Last name defined for an auto attendant.
    last_name: Optional[str]
    #: Alternate numbers defined for the auto attendant.
    alternate_numbers: Optional[list[AlternateNumbersObject]]
    #: Language code for the auto attendant.
    language_code: Optional[str]
    #: Business hours defined for the auto attendant.
    business_schedule: Optional[str]
    #: Holiday defined for the auto attendant.
    holiday_schedule: Optional[str]
    #: Extension dialing setting. If the values are not set default will be set as ENTERPRISE.
    extension_dialing: Optional[ExtensionDialing]
    #: Name dialing setting. If the values are not set default will be set as ENTERPRISE.
    name_dialing: Optional[ExtensionDialing]
    #: Time zone defined for the auto attendant.
    time_zone: Optional[str]
    #: Business hours menu defined for the auto attendant.
    business_hours_menu: Optional[PostHoursMenuObject]
    #: After hours menu defined for the auto attendant.
    after_hours_menu: Optional[PostHoursMenuObject]


class CreateAutoAttendantResponse(ApiModel):
    #: ID of the newly created auto attendant.
    id: Optional[str]


class UpdateAutoAttendantBody(GetDetailsForCallParkExtensionResponse):
    #: Auto attendant phone number. Either phoneNumber or extension is mandatory.
    phone_number: Optional[str]
    #: First name defined for an auto attendant.
    first_name: Optional[str]
    #: Last name defined for an auto attendant.
    last_name: Optional[str]
    #: Alternate numbers defined for the auto attendant.
    alternate_numbers: Optional[list[AlternateNumbersObject]]
    #: Language code for the auto attendant.
    language_code: Optional[str]
    #: Business hours defined for the auto attendant.
    business_schedule: Optional[str]
    #: Holiday defined for the auto attendant.
    holiday_schedule: Optional[str]
    #: Extension dialing setting. If the values are not set default will be set as ENTERPRISE.
    extension_dialing: Optional[ExtensionDialing]
    #: Name dialing setting. If the values are not set default will be set as ENTERPRISE.
    name_dialing: Optional[ExtensionDialing]
    #: Time zone defined for the auto attendant.
    time_zone: Optional[str]
    #: Business hours menu defined for the auto attendant.
    business_hours_menu: Optional[HoursMenuObject]
    #: After hours menu defined for the auto attendant.
    after_hours_menu: Optional[HoursMenuObject]


class GetCallForwardingSettingsForAutoAttendantResponse(ApiModel):
    #: Settings related to Always, Busy, and No Answer call forwarding.
    call_forwarding: Optional[AutoAttendantCallForwardSettingsDetailsObject]


class UpdateCallForwardingSettingsForAutoAttendantBody(ApiModel):
    #: Settings related to Always, Busy, and No Answer call forwarding.
    call_forwarding: Optional[AutoAttendantCallForwardSettingsModifyDetailsObject]


class CreateSelectiveCallForwardingRuleForAutoAttendantResponse(ApiModel):
    #: ID of the newly created auto attendant call forward selective rule.
    id: Optional[str]


class GetSelectiveCallForwardingRuleForAutoAttendantResponse(CreateSelectiveCallForwardingRuleForAutoAttendantBody):
    #: Unique ID for the rule.
    id: Optional[str]


class UpdateSelectiveCallForwardingRuleForAutoAttendantResponse(ApiModel):
    #: New ID for the modified rule.
    id: Optional[str]


class ReadListOfCallParksResponse(ApiModel):
    #: Array of call parks.
    call_parks: Optional[list[ListCallParkObject]]


class CreateCallParkResponse(ApiModel):
    #: ID of the newly created call park.
    id: Optional[str]


class GetDetailsForCallParkResponse(Role):
    #: Recall options that are added to call park.
    recall: Optional[GetRecallHuntGroupObject]
    #: People, workspaces and virtual lines that are eligible to receive calls.
    agents: Optional[list[GetPersonPlaceVirtualLineCallParksObject]]
    #: Whether or not the calls will be parked on agents as a destination.
    park_on_agents_enabled: Optional[bool]
    #: Array of call park extensions assigned to a call park.
    call_park_extensions: Optional[list[ListCPCallParkExtensionObject]]


class UpdateCallParkResponse(ApiModel):
    #: ID of the target call park.
    id: Optional[str]


class GetAvailableAgentsFromCallParksResponse(ApiModel):
    #: Array of agents.
    agents: Optional[list[GetPersonPlaceVirtualLineCallParksObject]]


class GetAvailableRecallHuntGroupsFromCallParksResponse(ApiModel):
    #: Array of available recall hunt groups.
    hunt_groups: Optional[list[Role]]


class GetCallParkSettingsResponse(ApiModel):
    #: Recall options that are added to call park.
    call_park_recall: Optional[GetRecallHuntGroupObject]
    #: Setting controlling call park behavior.
    call_park_settings: Optional[CallParkSettingsObject]


class UpdateCallParkSettingsBody(ApiModel):
    #: Recall options that are added to call park.
    call_park_recall: Optional[PutRecallHuntGroupObject]
    #: Setting controlling call park behavior.
    call_park_settings: Optional[CallParkSettingsObject]


class ReadListOfCallParkExtensionsResponse(ApiModel):
    #: Array of call park extensions.
    call_park_extensions: Optional[list[ListCallParkExtensionObject]]


class CreateCallParkExtensionResponse(ApiModel):
    #: ID of the newly created call park extension.
    id: Optional[str]


class ReadListOfCallPickupsResponse(ApiModel):
    #: Array of call pickups.
    call_pickups: Optional[list[ListCallParkObject]]


class CreateCallPickupResponse(ApiModel):
    #: ID of the newly created call pickup.
    id: Optional[str]


class GetDetailsForCallPickupResponse(Role):
    #: People, workspaces and virtual lines that are eligible to receive calls.
    agents: Optional[list[GetPersonPlaceVirtualLineCallPickupObject]]


class UpdateCallPickupResponse(ApiModel):
    #: ID of the target call pickup.
    id: Optional[str]


class GetAvailableAgentsFromCallPickupsResponse(ApiModel):
    #: Array of agents.
    agents: Optional[list[GetPersonPlaceVirtualLineCallPickupObject]]


class ReadListOfCallQueuesResponse(ApiModel):
    #: Array of call queues.
    queues: Optional[list[ListCallQueueObject]]


class CreateCallQueueBody(GetDetailsForCallParkExtensionResponse):
    #: Primary phone number of the call queue. Either a phoneNumber or extension is mandatory.
    phone_number: Optional[str]
    #: Language code.
    language_code: Optional[str]
    #: First name to be shown when calls are forwarded out of this call queue. Defaults to ".".
    first_name: Optional[str]
    #: Last name to be shown when calls are forwarded out of this call queue. Defaults to phoneNumber if set, otherwise
    #: defaults to call group name.
    last_name: Optional[str]
    #: Time zone for the call queue.
    time_zone: Optional[str]
    #: Policy controlling how calls are routed to agents.
    call_policies: Optional[PostCallQueueCallPolicyObject]
    #: Overall call queue settings.
    queue_settings: Optional[CallQueueQueueSettingsObject]
    #: People, workspaces and virtual lines that are eligible to receive calls.
    agents: Optional[list[PostPersonPlaceVirtualLineCallQueueObject]]
    #: Whether or not to allow agents to join or unjoin a queue.
    allow_agent_join_enabled: Optional[bool]
    #: When true, indicates that the agent's configuration allows them to use the queue's Caller ID for outgoing calls.
    phone_number_for_outgoing_calls_enabled: Optional[bool]


class CreateCallQueueResponse(ApiModel):
    #: ID of the newly created call queue.
    id: Optional[str]


class GetDetailsForCallQueueResponse(ListCPCallParkExtensionObject):
    #: Whether or not the call queue is enabled.
    enabled: Optional[bool]
    #: Language for the call queue.
    language: Optional[str]
    #: Language code.
    language_code: Optional[str]
    #: First name to be shown when calls are forwarded out of this call queue. Defaults to ..
    first_name: Optional[str]
    #: Last name to be shown when calls are forwarded out of this call queue. Defaults to the phoneNumber if set,
    #: otherwise defaults to call group name.
    last_name: Optional[str]
    #: Time zone for the call queue.
    time_zone: Optional[str]
    #: Primary phone number of the call queue.
    phone_number: Optional[str]
    #: When true, indicates that the agent's configuration allows them to use the queue's Caller ID for outgoing calls.
    phone_number_for_outgoing_calls_enabled: Optional[bool]
    #: The alternate numbers feature allows you to assign multiple phone numbers or extensions to a call queue. Each
    #: number will reach the same greeting and each menu will function identically to the main number. The alternate
    #: numbers option enables you to have up to ten (10) phone numbers ring into the call queue.
    alternate_number_settings: Optional[AlternateNumberSettings]
    #: Policy controlling how calls are routed to agents.
    call_policies: Optional[PostCallQueueCallPolicyObject]
    #: Overall call queue settings.
    queue_settings: Optional[CallQueueQueueSettingsObject]
    #: Flag to indicate whether call waiting is enabled for agents.
    allow_call_waiting_for_agents_enabled: Optional[bool]
    #: People, workspaces and virtual lines that are eligible to receive calls.
    agents: Optional[list[GetPersonPlaceVirtualLineCallQueueObject]]
    #: Whether or not to allow agents to join or unjoin a queue.
    allow_agent_join_enabled: Optional[bool]


class UpdateCallQueueBody(FaxMessage):
    #: Unique name for the call queue.
    name: Optional[str]
    #: Language code.
    language_code: Optional[str]
    #: First name to be shown when calls are forwarded out of this call queue. Defaults to ..
    first_name: Optional[str]
    #: Last name to be shown when calls are forwarded out of this call queue. Defaults to the phoneNumber if set,
    #: otherwise defaults to call group name.
    last_name: Optional[str]
    #: Time zone for the hunt group.
    time_zone: Optional[str]
    #: The alternate numbers feature allows you to assign multiple phone numbers or extensions to a call queue. Each
    #: number will reach the same greeting and each menu will function identically to the main number. The alternate
    #: numbers option enables you to have up to ten (10) phone numbers ring into the call queue.
    alternate_number_settings: Optional[AlternateNumberSettings]
    #: Policy controlling how calls are routed to agents.
    call_policies: Optional[PostCallQueueCallPolicyObject]
    #: Overall call queue settings.
    queue_settings: Optional[CallQueueQueueSettingsObject]
    #: Flag to indicate whether call waiting is enabled for agents.
    allow_call_waiting_for_agents_enabled: Optional[bool]
    #: People, workspaces and virtual lines that are eligible to receive calls.
    agents: Optional[list[ModifyPersonPlaceVirtualLineCallQueueObject]]
    #: Whether or not to allow agents to join or unjoin a queue.
    allow_agent_join_enabled: Optional[bool]
    #: When true, indicates that the agent's configuration allows them to use the queue's Caller ID for outgoing calls.
    phone_number_for_outgoing_calls_enabled: Optional[bool]


class ReadListOfCallQueueAnnouncementFilesResponse(ApiModel):
    #: Array of announcements for this call queue.
    announcements: Optional[list[GetAnnouncementFileInfo]]


class GetCallForwardingSettingsForCallQueueResponse(ApiModel):
    #: Settings related to Always, Busy, and No Answer call forwarding.
    call_forwarding: Optional[CallForwarding]


class UpdateCallForwardingSettingsForCallQueueBody(ApiModel):
    #: Settings related to Always, Busy, and No Answer call forwarding.
    call_forwarding: Optional[CallForwarding1]


class CreateSelectiveCallForwardingRuleForCallQueueResponse(ApiModel):
    #: ID of the newly created call queue.
    id: Optional[str]


class UpdateSelectiveCallForwardingRuleForCallQueueResponse(ApiModel):
    #: New ID for the modified rule.
    id: Optional[str]


class GetCallRecordingSettingsResponse(ApiModel):
    #: Details of the organization.
    organization: Optional[Role]
    #: Whether or not the call recording is enabled.
    enabled: Optional[bool]
    #: A unique identifier for the vendor.
    vendor_id: Optional[str]
    #: A unique name for the vendor.
    vendor_name: Optional[str]
    #: Url where can be found terms of service for the vendor.
    terms_of_service_url: Optional[str]


class UpdateCallRecordingSettingsBody(ApiModel):
    #: Whether or not the call recording is enabled.
    enabled: Optional[bool]


class GetCallRecordingTermsOfServiceSettingsResponse(ApiModel):
    #: A unique identifier for the vendor.
    vendor_id: Optional[str]
    #: A unique name for the vendor.
    vendor_name: Optional[str]
    #: Whether or not the call recording terms of service are enabled.
    terms_of_service_enabled: Optional[bool]
    #: Url where can be found terms of service for the vendor.
    terms_of_service_url: Optional[str]


class UpdateCallRecordingTermsOfServiceSettingsBody(ApiModel):
    #: Whether or not the call recording terms of service are enabled.
    terms_of_service_enabled: Optional[bool]


class TestCallRoutingBody(ApiModel):
    #: This element is used to identify the originating party. It can be user UUID or trunk UUID.
    originator_id: Optional[str]
    #: USER or TRUNK.
    originator_type: Optional[OriginatorType]
    #: Only used when originatorType is TRUNK. This element could be a phone number or URI.
    originator_number: Optional[str]
    #: This element specifies called party. It can be any dialable string, for example, an ESN number, E.164 number,
    #: hosted user DN, extension, extension with location code, URL, FAC code.
    destination: Optional[str]


class TestCallRoutingResponse(ApiModel):
    #: Only returned when originatorNumber is specified in the request.
    call_source_info: Optional[CallSourceInfo]
    #: Matching destination type for the call.
    destination_type: Optional[DestinationType]
    #: FAC code if destinationType is FAC. The routing address will be returned for all other destination types.
    routing_address: Optional[str]
    #: Outside access code.
    outside_access_code: Optional[str]
    #: true if the call would be rejected.
    is_rejected: Optional[bool]
    #: Returned when destinationType is HOSTED_AGENT.
    hosted_agent: Optional[HostedAgent]
    #: Returned when destinationType is HOSTED_FEATURE.
    hosted_feature: Optional[HostedFeature]
    #: Returned when destinationType is PBX_USER.
    pbx_user: Optional[PbxUser]
    #: Returned when destinationType is PSTN_NUMBER.
    pstn_number: Optional[PstnNumber]
    #: Returned when destinationType is VIRTUAL_EXTENSION.
    virtual_extension: Optional[VirtualExtension]
    #: Returned when destinationType is VIRTUAL_EXTENSION_RANGE.
    virtual_extension_range: Optional[VirtualExtensionRange]
    #: Returned when destinationType is ROUTE_LIST.
    route_list: Optional[RouteList]
    #: Returned when destinationType is FAC.
    feature_access_code: Optional[FeatureAccessCode]
    #: Returned when destinationType is EMERGENCY.
    emergency: Optional[Emergency]
    #: Returned when destinationType is REPAIR.
    repair: Optional[PstnNumber]
    #: Returned when destinationType is UNKNOWN_EXTENSION.
    unknown_extension: Optional[PstnNumber]
    #: Returned when destinationType is UNKNOWN_NUMBER.
    unknown_number: Optional[PstnNumber]


class ValidateListOfExtensionsBody(ApiModel):
    #: Array of Strings of IDs of the Extensions.
    #: Possible values: 12345, 3456
    extensions: Optional[list[str]]


class ValidateExtensionsBody(ApiModel):
    #: Array of extensions that will be validated.
    extensions: Optional[list[str]]


class ValidateExtensionsResponse(ApiModel):
    #: Status of the validated array of extensions
    status: Optional[Status30]
    #: Array of extensions statuses.
    extension_status: Optional[list[ExtensionStatusObject]]


class ReadListOfHuntGroupsResponse(ApiModel):
    #: Array of hunt groups.
    hunt_groups: Optional[list[ListCallQueueObject]]


class CreateHuntGroupBody(FaxMessage):
    #: Unique name for the hunt group.
    name: Optional[str]
    #: Language code.
    language_code: Optional[str]
    #: First name to be shown when calls are forwarded out of this hunt group. Defaults to ..
    first_name: Optional[str]
    #: Last name to be shown when calls are forwarded out of this hunt group. Defaults to the phone number if set,
    #: otherwise defaults to call group name.
    last_name: Optional[str]
    #: Time zone for the hunt group.
    time_zone: Optional[str]
    #: Policy controlling how calls are routed to agents.
    call_policies: Optional[PostHuntGroupCallPolicyObject]
    #: People, workspaces and virtual lines that are eligible to receive calls.
    agents: Optional[list[PostPersonPlaceVirtualLineHuntGroupObject]]


class CreateHuntGroupResponse(ApiModel):
    #: ID of the newly created hunt group.
    id: Optional[str]


class GetDetailsForHuntGroupResponse(ListCPCallParkExtensionObject):
    #: Whether or not the hunt group is enabled.
    enabled: Optional[bool]
    #: Primary phone number of the hunt group.
    phone_number: Optional[str]
    #: Whether or not the hunt group has the distinctive ring option enabled.
    distinctive_ring: Optional[bool]
    #: The alternate numbers feature allows you to assign multiple phone numbers or extensions to a hunt group. Each
    #: number will reach the same greeting and each menu will function identically to the main number. The alternate
    #: numbers option enables you to have up to ten (10) phone numbers ring into the hunt group.
    alternate_numbers: Optional[list[AlternateNumbersWithPattern]]
    #: Language for hunt group.
    language: Optional[str]
    #: Language code for hunt group.
    language_code: Optional[str]
    #: First name to be shown when calls are forwarded out of this hunt group. Defaults to ..
    first_name: Optional[str]
    #: Last name to be shown when calls are forwarded out of this hunt group. Defaults to phone number if set,
    #: otherwise defaults to call group name.
    last_name: Optional[str]
    #: Time zone for the hunt group.
    time_zone: Optional[str]
    #: Policy controlling how calls are routed to agents.
    call_policies: Optional[PostHuntGroupCallPolicyObject]
    #: People, workspaces and virtual lines that are eligible to receive calls.
    agents: Optional[list[GetPersonPlaceVirtualLineHuntGroupObject]]
    #: Whether or not the hunt group is enabled.
    enabled: Optional[bool]


class UpdateHuntGroupBody(SimultaneousInterpretation):
    #: Unique name for the hunt group.
    name: Optional[str]
    #: Primary phone number of the hunt group.
    phone_number: Optional[str]
    #: Primary phone extension of the hunt group.
    extension: Optional[str]
    #: Whether or not the hunt group has the distinctive ring option enabled.
    distinctive_ring: Optional[bool]
    #: The alternate numbers feature allows you to assign multiple phone numbers or extensions to a hunt group. Each
    #: number will reach the same greeting and each menu will function identically to the main number. The alternate
    #: numbers option enables you to have up to ten (10) phone numbers ring into the hunt group.
    alternate_numbers: Optional[list[AlternateNumbersWithPattern]]
    #: Language code.
    language_code: Optional[str]
    #: First name to be shown when calls are forwarded out of this hunt group. Defaults to ..
    first_name: Optional[str]
    #: Last name to be shown when calls are forwarded out of this hunt group. Defaults to the phone number if set,
    #: otherwise defaults to call group name.
    last_name: Optional[str]
    #: Time zone for the hunt group.
    time_zone: Optional[str]
    #: Policy controlling how calls are routed to agents.
    call_policies: Optional[PostHuntGroupCallPolicyObject]
    #: People, workspaces and virtual lines that are eligible to receive calls.
    agents: Optional[list[PostPersonPlaceVirtualLineHuntGroupObject]]


class GetCallForwardingSettingsForHuntGroupResponse(ApiModel):
    #: Settings related to Always, Busy, and No Answer call forwarding.
    call_forwarding: Optional[CallForwarding]


class UpdateCallForwardingSettingsForHuntGroupBody(ApiModel):
    #: Settings related to Always, Busy, and No Answer call forwarding.
    call_forwarding: Optional[CallForwarding1]


class CreateSelectiveCallForwardingRuleForHuntGroupResponse(ApiModel):
    #: ID of the newly created hunt group.
    id: Optional[str]


class UpdateSelectiveCallForwardingRuleForHuntGroupResponse(ApiModel):
    #: New ID for the modified rule.
    id: Optional[str]


class ReadInternalDialingConfigurationForlocationResponse(ApiModel):
    #: When enabled, calls made by users at the location to an unknown extension (between 2-6 digits) are routed to the
    #: selected route group/trunk as premises calls.
    enable_unknown_extension_route_policy: Optional[bool]
    #: The selected route group/trunk as premises calls.
    unknown_extension_route_identity: Optional[RouteIdentity]


class ModifyInternalDialingConfigurationForlocationBody(ApiModel):
    #: When enabled, calls made by users at the location to an unknown extension (between 2-6 digits) are routed to the
    #: selected route group/trunk as premises calls.
    enable_unknown_extension_route_policy: Optional[bool]
    #: Type associated with the identity.
    unknown_extension_route_identity: Optional[UnknownExtensionRouteIdentity]


class GetLocationWebexCallingDetailsResponse(UpdateLocationWebexCallingDetailsBody):
    #: A unique identifier for the location.
    id: Optional[str]
    #: The name of the location.
    name: Optional[str]
    #: Limit on the number of people at the location, Read-Only.
    user_limit: Optional[int]
    #: IP Address, hostname, or domain. Read-Only.
    default_domain: Optional[str]


class EnableLocationForWebexCallingBody(CreateLocationBody):
    #: A unique identifier for the location.
    id: Optional[str]


class EnableLocationForWebexCallingResponse(ApiModel):
    #: A unique identifier for the location.
    id: Optional[str]


class ListLocationsWebexCallingDetailsResponse(ApiModel):
    #: Array of locations.
    locations: Optional[list[ListLocationObject]]


class GenerateExamplePasswordForLocationBody(ApiModel):
    #: password settings array.
    #: SIP password setting
    generate: Optional[list[PasswordGenerate]]


class GenerateExamplePasswordForLocationResponse(ApiModel):
    #: Example password.
    example_sip_password: Optional[str]


class GetLocationOutgoingPermissionResponse(ApiModel):
    #: Array of calling permissions.
    calling_permissions: Optional[list[CallingPermissionObject]]


class UpdateLocationOutgoingPermissionBody(ApiModel):
    #: Array specifying the subset of calling permissions to be updated.
    calling_permissions: Optional[list[CallingPermissionObject]]


class GetOutgoingPermissionLocationAccessCodeResponse(ApiModel):
    #: Access code details
    access_codes: Optional[ReportError]


class CreateOutgoingPermissionnewAccessCodeForcustomerLocationBody(ApiModel):
    #: Access code details
    access_codes: Optional[ReportError]


class DeleteOutgoingPermissionAccessCodeLocationBody(ApiModel):
    #: Array of string to delete access codes. For example, ["1234","2345"]
    delete_codes: Optional[list[str]]


class ReadListOfPagingGroupsResponse(ApiModel):
    #: Array of paging groups.
    location_paging: Optional[list[ListAutoAttendantObject]]


class CreatenewPagingGroupResponse(ApiModel):
    #: ID of the newly created paging group.
    id: Optional[str]


class GetDetailsForPagingGroupResponse(ListCPCallParkExtensionObject):
    #: Whether or not the paging group is enabled.
    enabled: Optional[bool]
    #: Paging group phone number. Minimum length is 1. Maximum length is 23. Either phoneNumber or extension is
    #: mandatory.
    phone_number: Optional[str]
    #: Flag to indicate toll free number.
    toll_free_number: Optional[bool]
    #: Paging language. Minimum length is 1. Maximum length is 40.
    language: Optional[str]
    #: Language code.
    language_code: Optional[str]
    #: First name that displays when a group page is performed. Minimum length is 1. Maximum length is 30.
    first_name: Optional[str]
    #: Last name that displays when a group page is performed. Minimum length is 1. Maximum length is 30.
    last_name: Optional[str]
    #: Determines what is shown on target users caller ID when a group page is performed. If true shows page originator
    #: ID.
    originator_caller_id_enabled: Optional[bool]
    #: An array of people, workspaces and virtual lines ID's who may originate pages to this paging group.
    originators: Optional[list[GetPagingGroupAgentObject]]
    #: An array of people, workspaces and virtual lines ID's that are added to paging group as paging call targets.
    targets: Optional[list[GetPagingGroupAgentObject]]


class UpdatePagingGroupBody(CreatenewPagingGroupBody):
    #: Whether or not the paging group is enabled.
    enabled: Optional[bool]


class ActivatePhoneNumbersInlocationBody(ApiModel):
    #: List of phone numbers that need to be added.
    phone_numbers: Optional[list[str]]


class GetPhoneNumbersForOrganizationWithGivenCriteriasResponse(ApiModel):
    #: Array of phone numbers.
    phone_numbers: Optional[NumberListGetObject]


class ListManageNumbersJobsResponse(ApiModel):
    #: Lists all jobs for the customer in order of most recent one to oldest one irrespective of its status.
    items: Optional[list[StartJobResponse]]


class InitiateMoveNumberJobsBody(ApiModel):
    #: Indicates the kind of operation to be carried out.
    operation: Optional[str]
    #: The target location within organization where the unassigned numbers will be moved from the source location.
    target_location_id: Optional[str]
    #: Indicates the numbers to be moved from source to target locations.
    number_list: Optional[list[NumberItem]]


class ListManageNumbersJobErrorsResponse(ApiModel):
    items: Optional[list[ItemObject]]


class GetPrivateNetworkConnectResponse(ApiModel):
    #: Network Connection Type for the location.
    network_connection_type: Optional[NetworkConnectionType]


class UpdatePrivateNetworkConnectBody(ApiModel):
    #: Network Connection Type for the location.
    network_connection_type: Optional[NetworkConnectionType]


class ReadListOfRoutingChoicesResponse(ApiModel):
    #: Array of route identities.
    route_identities: Optional[list[RouteIdentity]]


class ReadListOfSchedulesResponse(ApiModel):
    #: Array of schedules.
    schedules: Optional[list[ListScheduleObject]]


class GetDetailsForScheduleResponse(Role):
    #: Type of the schedule.
    type: Optional[Type54]
    #: List of schedule events.
    events: Optional[list[GetScheduleEventObject]]


class CreateScheduleBody(ApiModel):
    #: Type of the schedule.
    type: Optional[Type54]
    #: Unique name for the schedule.
    name: Optional[str]
    #: List of schedule events.
    events: Optional[list[ScheduleEventObject]]


class CreateScheduleResponse(ApiModel):
    #: ID of the newly created schedule.
    id: Optional[str]


class UpdateScheduleBody(ApiModel):
    #: Unique name for the schedule.
    name: Optional[str]
    #: List of schedule events.
    events: Optional[list[ModifyScheduleEventListObject]]


class UpdateScheduleResponse(ApiModel):
    #: ID of the target schedule.
    id: Optional[str]


class CreateScheduleEventResponse(ApiModel):
    #: ID of the newly created schedule event.
    id: Optional[str]


class UpdateScheduleEventResponse(ApiModel):
    #: ID of the target schedule event.
    id: Optional[str]


class ReadListOfVirtualLinesResponse(ApiModel):
    #: Array of virtual lines.
    virtual_lines: Optional[list[ListVirtualLineObject]]


class GetVoicemailRulesResponse(ApiModel):
    #: Default voicemail passcode requirements.
    default_voicemail_pin_rules: Optional[DefaultVoicemailPinRules]
    #: Settings for passcode expiry.
    expire_passcode: Optional[ExpirePasscode]
    #: Settings for passcode changes.
    change_passcode: Optional[ExpirePasscode]
    #: Settings for previous passcode usage.
    block_previous_passcodes: Optional[BlockPreviousPasscodes]


class UpdateVoicemailRulesBody(ApiModel):
    #: Set to true to enable the default voicemail passcode.
    default_voicemail_pin_enabled: Optional[bool]
    #: Default voicemail passcode.
    default_voicemail_pin: Optional[str]
    #: Settings for passcode expiry.
    expire_passcode: Optional[ExpirePasscode]
    #: Settings for passcode changes.
    change_passcode: Optional[ExpirePasscode]
    #: Settings for previous passcode usage.
    block_previous_passcodes: Optional[BlockPreviousPasscodes]


class GetLocationVoicemailResponse(ApiModel):
    #: Set to true to enable voicemail transcription.
    voicemail_transcription_enabled: Optional[bool]


class UpdateLocationVoicemailBody(ApiModel):
    #: Set to true to enable voicemail transcription.
    voicemail_transcription_enabled: Optional[bool]


class GetVoicePortalResponse(ListCPCallParkExtensionObject):
    #: Language for audio announcements.
    language: Optional[str]
    #: Language code for voicemail group audio announcement.
    language_code: Optional[str]
    #: Phone Number of incoming call.
    phone_number: Optional[str]
    #: Caller ID First Name.
    first_name: Optional[str]
    #: Caller ID Last Name.
    last_name: Optional[str]


class UpdateVoicePortalBody(GetDetailsForCallParkExtensionResponse):
    #: Language code for voicemail group audio announcement.
    language_code: Optional[str]
    #: Phone Number of incoming call.
    phone_number: Optional[str]
    #: Caller ID First Name.
    first_name: Optional[str]
    #: Caller ID Last Name.
    last_name: Optional[str]
    #: Voice Portal Admin Passcode.
    passcode: Optional[Passcode]


class GetVoicePortalPasscodeRuleResponse(ApiModel):
    #: Settings for passcode expiry.
    expire_passcode: Optional[ExpirePasscode]
    #: Number of failed attempts allowed.
    failed_attempts: Optional[FailedAttempts]
    #: Settings for previous passcode usage.
    block_previous_passcodes: Optional[BlockPreviousPasscodes]
    #: Settings for not allowing single or groups of repeated digits in passcode (for example, 22888, 121212, or
    #: 408408).
    block_repeated_digits: Optional[object]
    #: Settings for not allowing numerical sequence in passcode (for example, 012345 or 987654).
    block_contiguous_sequences: Optional[object]
    #: Allowed length of the passcode.
    length: Optional[Length]
    #: If enabled, the passcode do not contain repeated pattern.
    block_repeated_patterns_enabled: Optional[bool]
    #: If enabled, the passcode do not allow user phone number or extension.
    block_user_number_enabled: Optional[bool]
    #: If enabled, the passcode do not allow revered phone number or extension.
    block_reversed_user_number_enabled: Optional[bool]
    #: If enabled, the passcode do not allow setting reversed old passcode.
    block_reversed_old_passcode_enabled: Optional[bool]


class ListVoicemailGroupResponse(ApiModel):
    #: Array of VoicemailGroups.
    voicemail_groups: Optional[list[GetVoicemailGroupObject]]


class GetLocationVoicemailGroupResponse(ListCPCallParkExtensionObject):
    #: Voicemail group phone number.
    phone_number: Optional[str]
    #: Voicemail group toll free number.
    toll_free_number: Optional[bool]
    #: Voicemail group caller ID first name.
    first_name: Optional[str]
    #: Voicemail group called ID last name.
    last_name: Optional[str]
    #: Enable/disable voicemail group.
    enabled: Optional[bool]
    #: Language for voicemail group audio announcement.
    language_code: Optional[str]
    #: Set voicemail group greeting type.
    greeting: Optional[Greeting]
    #: Enabled if CUSTOM greeting is previously uploaded.
    greeting_uploaded: Optional[bool]
    #: CUSTOM greeting for previously uploaded.
    greeting_description: Optional[str]
    #: Message storage information
    message_storage: Optional[MessageStorage]
    #: Message notifications
    notifications: Optional[NewNumber]
    #: Fax message receive settings
    fax_message: Optional[FaxMessage]
    #: Transfer message information
    transfer_to_number: Optional[NewNumber]
    #: Message copy information
    email_copy_of_message: Optional[EmailCopyOfMessage]
    #: Enable/disable to forward voice message.
    voice_message_forwarding_enabled: Optional[bool]


class ModifyLocationVoicemailGroupBody(FaxMessage):
    #: Set the name of the voicemail group.
    name: Optional[str]
    #: Set the voicemail group caller ID first name.
    first_name: Optional[str]
    #: Set the voicemail group called ID last name.
    last_name: Optional[str]
    #: Set passcode to access voicemail group when calling.
    passcode: Optional[int]
    #: Language code for the voicemail group audio announcement.
    language_code: Optional[str]
    #: Voicemail group greeting type.
    greeting: Optional[Greeting]
    #: CUSTOM greeting for previously uploaded.
    greeting_description: Optional[str]
    #: Message storage information
    message_storage: Optional[MessageStorage]
    #: Message notifications
    notifications: Optional[NewNumber]
    #: Fax message receive settings
    fax_message: Optional[FaxMessage]
    #: Transfer message information
    transfer_to_number: Optional[NewNumber]
    #: Message copy information
    email_copy_of_message: Optional[EmailCopyOfMessage]


class CreatenewVoicemailGroupForLocationBody(GetDetailsForCallParkExtensionResponse):
    #: Set voicemail group phone number for this particular location.
    phone_number: Optional[str]
    #: Set voicemail group caller ID first name.
    first_name: Optional[str]
    #: Set voicemail group called ID last name.
    last_name: Optional[str]
    #: Set passcode to access voicemail group when calling.
    passcode: Optional[int]
    #: Language code for voicemail group audio announcement.
    language_code: Optional[str]
    #: Message storage information
    message_storage: Optional[MessageStorage]
    #: Message notifications
    notifications: Optional[NewNumber]
    #: Fax message information
    fax_message: Optional[FaxMessage]
    #: Transfer message information
    transfer_to_number: Optional[NewNumber]
    #: Message copy information
    email_copy_of_message: Optional[EmailCopyOfMessage]


class CreatenewVoicemailGroupForLocationResponse(ApiModel):
    #: UUID of the newly created voice mail group.
    id: Optional[str]


class ReadListOfUCManagerProfilesResponse(ApiModel):
    #: Array of manager profiles.
    calling_profiles: Optional[list[Role]]


class ReadListOfDialPatternsResponse(ApiModel):
    #: Array of dial patterns. An enterprise dial pattern is represented by a sequence of digits (1-9), followed by
    #: optional wildcard characters.
    dial_patterns: Optional[list[str]]


class ModifyDialPatternsBody(ApiModel):
    #: Array of dial patterns to add or delete. Dial Pattern that is not present in the request is not modified.
    dial_patterns: Optional[list[DialPattern]]
    #: Delete all the dial patterns for a dial plan.
    delete_all_dial_patterns: Optional[bool]


class ValidateDialPatternBody(ApiModel):
    #: Array of dial patterns.
    #: Possible values: +5555,7777
    dial_patterns: Optional[list[str]]


class ValidateDialPatternResponse(ApiModel):
    #: Overall validation result status.
    status: Optional[Status30]
    #: Patterns validation result.
    dial_pattern_status: Optional[list[DialPatternValidate]]


class ReadListOfDialPlansResponse(ApiModel):
    #: Array of dial plans.
    dial_plans: Optional[list[DialPlan]]


class CreateDialPlanBody(ModifyDialPlanBody):
    #: An Array of dial patterns.
    #: Possible values: +5555,+5556
    dial_patterns: Optional[list[str]]


class CreateDialPlanResponse(ApiModel):
    #: ID of the newly created dial plan.
    id: Optional[str]


class GetDialPlanResponse(DialPlan):
    #: Customer information.
    customer: Optional[Role]


class ReadListOfTrunksResponse(ApiModel):
    #: Array of trunks.
    trunks: Optional[list[Trunk]]


class CreateTrunkBody(ModifyTrunkBody):
    #: ID of location associated with the trunk.
    location_id: Optional[str]
    #: Trunk Type associated with the trunk.
    trunk_type: Optional[TrunkType]
    #: Device type assosiated with trunk.
    device_type: Optional[str]
    #: FQDN or SRV address. Required to create a static certificate-based trunk.
    address: Optional[str]
    #: Domain name. Required to create a static certificate based trunk.
    domain: Optional[str]
    #: FQDN port. Required to create a static certificate-based trunk.
    port: Optional[int]


class CreateTrunkResponse(ApiModel):
    #: ID of the newly created trunk.
    id: Optional[str]


class GetTrunkResponse(ValidateLocalGatewayFQDNAndDomainForTrunkBody):
    #: A unique name for the trunk.
    name: Optional[str]
    #: Customer associated with the trunk.
    customer: Optional[Role]
    #: Location associated with the trunk.
    location: Optional[Role]
    #: Unique Outgoing and Destination trunk group associated with the dial plan.
    otg_dtg_id: Optional[str]
    #: The Line/Port identifies a device endpoint in standalone mode or a SIP URI public identity in IMS mode.
    line_port: Optional[str]
    #: Locations using trunk.
    locations_using_trunk: Optional[list[Role]]
    #: User ID.
    pilot_user_id: Optional[str]
    #: Contains the body of the HTTP response received following the request to Console API and will not be set if the
    #: response has no body.
    outbound_proxy: Optional[object]
    #: User's authentication service information.
    sip_authentication_user_name: Optional[str]
    #: Device status.
    status: Optional[DeviceStatus]
    #: Error codes.
    error_codes: Optional[list[str]]
    #: Present partial error/warning status information included when the http response is 206.
    response_status: Optional[ResponseStatus]
    #: Determines the behavior of the From and PAI headers on outbound calls.
    dual_identity_support_enabled: Optional[bool]
    #: Trunk Type associated with the trunk.
    trunk_type: Optional[TrunkType]
    #: Device type assosiated with trunk.
    device_type: Optional[str]
    #: Max Concurrent call. Required to create a static certificate based trunk.
    max_concurrent_calls: Optional[int]


class ReadListOfTrunkTypesResponse(ApiModel):
    #: Trunk type with device types.
    trunk_types: Optional[list[TrunkTypeWithDeviceType]]


class ReadListOfRoutingGroupsResponse(ApiModel):
    #: Array of route groups.
    route_groups: Optional[list[RouteGroup]]


class CreateRouteGroupForOrganizationResponse(ApiModel):
    #: ID of the Route Group.
    id: Optional[str]


class ReadRouteGroupForOrganizationResponse(CreateRouteGroupForOrganizationBody):
    #: Organization details.
    organization: Optional[Role]


class ReadUsageOfRoutingGroupResponse(ApiModel):
    #: Number of PSTN connection locations associated to this route group.
    pstn_connection_count: Optional[str]
    #: Number of call to extension locations associated to this route group.
    call_to_extension_count: Optional[str]
    #: Number of dial plan locations associated to this route group.
    dial_plan_count: Optional[str]
    #: Number of route list locations associated to this route group.
    route_list_count: Optional[str]


class ReadCallToExtensionLocationsOfRoutingGroupResponse(ApiModel):
    #: Array of locations.
    locations: Optional[list[Role]]


class ReadDialPlanLocationsOfRoutingGroupResponse(ApiModel):
    #: Array of locations.
    locations: Optional[list[Role]]


class ReadPSTNConnectionLocationsOfRoutingGroupResponse(ApiModel):
    #: Array of locations.
    locations: Optional[list[Role]]


class ReadRouteListsOfRoutingGroupResponse(ApiModel):
    #: Array of route lists.
    route_group_usage_route_list_get: Optional[list[RouteGroupUsageRouteListGet]]


class ReadListOfRouteListsResponse(ApiModel):
    #: Array of route lists.
    route_lists: Optional[list[RouteList]]


class CreateRouteListBody(ModifyRouteListBody):
    #: Location associated with the Route List.
    location_id: Optional[str]


class CreateRouteListResponse(ApiModel):
    #: ID of the newly route list created.
    id: Optional[str]


class GetRouteListResponse(ApiModel):
    #: Route list name.
    name: Optional[str]
    #: Location associated with the Route List.
    location: Optional[Role]
    #: Route group associated with the Route list.
    route_group: Optional[RouteGroup]


class ModifyNumbersForRouteListBody(ApiModel):
    #: Array of the numbers to be deleted/added.
    numbers: Optional[list[RouteListNumberPatch]]
    #: If present, the numbers array is ignored and all numbers in the route list are deleted.
    delete_all_numbers: Optional[bool]


class ModifyNumbersForRouteListResponse(ApiModel):
    #: Array of number statuses.
    number_status: Optional[list[RouteListNumberPatchResponse]]


class GetNumbersAssignedToRouteListResponse(ApiModel):
    #: Number assigned to the Route list.
    phone_numbers: Optional[str]


class GetLocalGatewayCallToOnPremisesExtensionUsageForTrunkResponse(ApiModel):
    #: Location associated with the trunk.
    location: Optional[Role]


class GetLocalGatewayDialPlanUsageForTrunkResponse(ApiModel):
    #: Array of dial Plans.
    dial_plans: Optional[list[Role]]


class GetLocationsUsingLocalGatewayAsPSTNConnectionRoutingResponse(ApiModel):
    #: Location associated with the trunk.
    location: Optional[Role]


class GetRouteGroupsUsingLocalGatewayResponse(ApiModel):
    #: Array of route Groups.
    route_group: Optional[list[RouteGroup]]


class GetLocalGatewayUsageCountResponse(ApiModel):
    #: The count where the local gateway is used as a PSTN Connection setting.
    pstn_connection_count: Optional[int]
    #: The count where the given local gateway is used as call to extension setting.
    call_to_extension_count: Optional[int]
    #: The count where the given local gateway is used by the dial plan.
    dial_plan_count: Optional[int]
    #: The count where the given local gateway is used by the route group.
    route_group_count: Optional[int]


class GetDetailsForCallQueueHolidayServiceResponse(GetDetailsForCallQueueStrandedCallsResponse):
    #: Whether or not the call queue holiday service routing policy is enabled.
    holiday_service_enabled: Optional[bool]
    #: Specifies whether the schedule mentioned in holidayScheduleName is org or location specific. (Must be from
    #: holidaySchedules list)
    holiday_schedule_level: Optional[HolidayScheduleLevel]
    #: Name of the schedule configured for a holiday service as one of from holidaySchedules list.
    holiday_schedule_name: Optional[str]
    #: Specifies if an announcement plays to callers before applying the action.
    play_announcement_before_enabled: Optional[bool]
    #: Lists the pre-configured holiday schedules.
    holiday_schedules: Optional[list[CallQueueHolidaySchedulesObject]]


class UpdateCallQueueHolidayServiceBody(GetDetailsForCallQueueStrandedCallsResponse):
    #: Enable or Disable the call queue holiday service routing policy.
    holiday_service_enabled: Optional[bool]
    #: Specifies whether the schedule mentioned in holidayScheduleName is org or location specific. (Must be from
    #: holidaySchedules list)
    holiday_schedule_level: Optional[HolidayScheduleLevel]
    #: Name of the schedule configured for a holiday service as one of from holidaySchedules list.
    holiday_schedule_name: Optional[str]
    #: Specifies if an announcement plays to callers before applying the action.
    play_announcement_before_enabled: Optional[bool]


class GetDetailsForCallQueueNightServiceResponse(GetDetailsForCallQueueStrandedCallsResponse):
    #: Whether or not the call queue night service routing policy is enabled.
    night_service_enabled: Optional[bool]
    #: Specifies if an announcement plays to callers before applying the action.
    play_announcement_before_enabled: Optional[bool]
    #: Specifies the type of announcements to played.
    announcement_mode: Optional[AnnouncementMode]
    #: Name of the schedule configured for a night service as one of from businessHourSchedules list.
    business_hours_name: Optional[str]
    #: Specifies whether the above mentioned schedule is org or location specific. (Must be from businessHourSchedules
    #: list).
    business_hours_level: Optional[HolidayScheduleLevel]
    #: Lists the pre-configured business hour schedules.
    business_hour_schedules: Optional[list[CallQueueHolidaySchedulesObject]]
    #: Force night service regardless of business hour schedule.
    force_night_service_enabled: Optional[bool]
    #: Specifies what type of announcement to be played when announcementMode is MANUAL.
    manual_audio_message_selection: Optional[Greeting]
    #: List Of Audio Files.
    manual_audio_files: Optional[list[CallQueueAudioFilesObject]]


class UpdateCallQueueNightServiceBody(GetDetailsForCallQueueStrandedCallsResponse):
    #: Enable or disable call queue night service routing policy.
    night_service_enabled: Optional[bool]
    #: Specifies if an announcement plays to callers before applying the action.
    play_announcement_before_enabled: Optional[bool]
    #: Specifies the type of announcements to played.
    announcement_mode: Optional[AnnouncementMode]
    #: Name of the schedule configured for a night service as one of from businessHourSchedules list.
    business_hours_name: Optional[str]
    #: Specifies whether the above mentioned schedule is org or location specific. (Must be from businessHourSchedules
    #: list)
    business_hours_level: Optional[HolidayScheduleLevel]
    #: Force night service regardless of business hour schedule.
    force_night_service_enabled: Optional[bool]
    #: Specifies what type of announcement to be played when announcementMode is MANUAL.
    manual_audio_message_selection: Optional[Greeting]
    #: List Of pre-configured Audio Files.
    manual_audio_files: Optional[list[CallQueueAudioFilesObject]]


class ReadListOfSupportedDevicesResponse(ApiModel):
    #: List of supported devices.
    devices: Optional[list[DeviceObject]]


class ReaddeviceOverrideSettingsFororganizationResponse(ApiModel):
    #: Customization object of the device settings.
    customizations: Optional[CustomizationObject]
    #: Progress of the device update.
    update_in_progress: Optional[bool]
    #: Device count.
    device_count: Optional[int]
    #: Last updated time.
    last_update_time: Optional[int]


class ReadDECTDeviceTypeListResponse(ApiModel):
    #: Contains a list of devices.
    devices: Optional[list[DectDeviceList]]


class ValidatelistOfMACAddressBody(ApiModel):
    #: MAC addresses to be validated.
    #: Possible values: {["ab125678cdef", "00005E0053B4"]}
    macs: Optional[list[str]]


class ValidatelistOfMACAddressResponse(ApiModel):
    #: Status of MAC address.
    status: Optional[Status30]
    #: Contains an array of all the MAC address provided and their statuses.
    mac_status: Optional[list[MacStatusObject]]


class ChangeDeviceSettingsAcrossOrganizationOrLocationJobBody(ApiModel):
    #: Location within an organization where changes of device setings will be applied to all the devices within it.
    location_id: Optional[str]
    #: Indicates if all the devices within this location will be customized with new requested customizations(if set to
    #: true) or will be overridden with the one at organization level (if set to false or any other value). This field
    #: has no effect when the job is being triggered at organization level.
    location_customizations_enabled: Optional[bool]
    #: Indicates the settings for ATA devices, DECT devices and MPP devices.
    customizations: Optional[CustomizationObject]


class ListChangeDeviceSettingsJobsResponse(ApiModel):
    #: Lists all jobs for the customer in order of most recent one to oldest one irrespective of its status.
    items: Optional[list[StartJobResponse]]


class ListChangeDeviceSettingsJobErrorsResponse(ApiModel):
    items: Optional[list[ItemObject]]


class ReadListOfAnnouncementLanguagesResponse(ApiModel):
    #: Array of Languages.
    languages: Optional[list[FeatureAccessCode]]


class CreateReceptionistContactDirectoryBody(ApiModel):
    #: Receptionist Contact Directory name.
    name: Optional[str]
    #: Array of users assigned to this Receptionist Contact Directory.
    #: Person ID.
    contacts: Optional[list[PersonId]]


class CreateReceptionistContactDirectoryResponse(ApiModel):
    #: Receptionist Contact Directory ID.
    id: Optional[str]


class ReadListOfReceptionistContactDirectoriesResponse(ApiModel):
    #: Array of Receptionist Contact Directories.
    directories: Optional[list[Role]]


class WebexCallingOrganizationSettingsApi(ApiChild, base='telephony/config/'):
    """
    Not supported for Webex for Government (FedRAMP)
    Webex Calling Organization Settings support reading and writing of Webex Calling settings for a specific
    organization.
    Viewing these read-only organization settings requires a full or read-only administrator auth token with a scope of
    spark-admin:telephony_config_read, as the current set of APIs is designed to provide supplemental information for
    administrators utilizing People Webex Calling APIs.
    Modifying these organization settings requires a full administrator auth token with a scope of
    spark-admin:telephony_config_write.
    A partner administrator can retrieve or change settings in a customer's organization using the optional OrgId query
    parameter.
    """

    def change_announcement_language(self, location_id: str, announcement_language_code: str, org_id: str = None, agent_enabled: bool = None, service_enabled: bool = None):
        """
        Change announcement language for the given location.
        Change announcement language for current people/workspaces and/or existing feature configurations. This does
        not change the default announcement language which is applied to new users/workspaces and new feature
        configurations.
        Changing announcement language for the given location requires a full administrator auth token with a scope of
        spark-admin:telephony_config_write.

        :param location_id: Change announcement language for this location.
        :type location_id: str
        :param announcement_language_code: Language code.
        :type announcement_language_code: str
        :param org_id: Change announcement language for this organization.
        :type org_id: str
        :param agent_enabled: Set to true to change announcement language for existing people and workspaces.
        :type agent_enabled: bool
        :param service_enabled: Set to true to change announcement language for existing feature configurations.
        :type service_enabled: bool

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/change-announcement-language
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = ChangeAnnouncementLanguageBody()
        if announcement_language_code is not None:
            body.announcement_language_code = announcement_language_code
        if agent_enabled is not None:
            body.agent_enabled = agent_enabled
        if service_enabled is not None:
            body.service_enabled = service_enabled
        url = self.ep(f'locations/{location_id}/actions/modifyAnnouncementLanguage/invoke')
        super().post(url=url, params=params, data=body.json())
        return

    def read_list_of_auto_attendants(self, org_id: str = None, location_id: str = None, name: str = None, phone_number: str = None, **params) -> Generator[ListAutoAttendantObject, None, None]:
        """
        List all Auto Attendants for the organization.
        Auto attendants play customized prompts and provide callers with menu options for routing their calls through
        your system.
        Retrieving this list requires a full or read-only administrator auth token with a scope of
        spark-admin:telephony_config_read.

        :param org_id: List auto attendants for this organization.
        :type org_id: str
        :param location_id: Return the list of auto attendants for this location.
        :type location_id: str
        :param name: Only return auto attendants with the matching name.
        :type name: str
        :param phone_number: Only return auto attendants with the matching phone number.
        :type phone_number: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/read-the-list-of-auto-attendants
        """
        if org_id is not None:
            params['orgId'] = org_id
        if location_id is not None:
            params['locationId'] = location_id
        if name is not None:
            params['name'] = name
        if phone_number is not None:
            params['phoneNumber'] = phone_number
        url = self.ep('autoAttendants')
        return self.session.follow_pagination(url=url, model=ListAutoAttendantObject, item_key='autoAttendants', params=params)

    def details_for_auto_attendant(self, location_id: str, auto_attendant_id: str, org_id: str = None) -> GetDetailsForAutoAttendantResponse:
        """
        Retrieve an Auto Attendant details.
        Auto attendants play customized prompts and provide callers with menu options for routing their calls through
        your system.
        Retrieving an auto attendant details requires a full or read-only administrator auth token with a scope of
        spark-admin:telephony_config_read.

        :param location_id: Retrieve an auto attendant details in this location.
        :type location_id: str
        :param auto_attendant_id: Retrieve the auto attendant with the matching ID.
        :type auto_attendant_id: str
        :param org_id: Retrieve auto attendant details from this organization.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/get-details-for-an-auto-attendant
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/autoAttendants/{auto_attendant_id}')
        data = super().get(url=url, params=params)
        return GetDetailsForAutoAttendantResponse.parse_obj(data)

    def create_auto_attendant(self, location_id: str, business_schedule: str, business_hours_menu: PostHoursMenuObject, after_hours_menu: PostHoursMenuObject, org_id: str = None, extension: str = None, name: str = None, phone_number: str = None, first_name: str = None, last_name: str = None, alternate_numbers: AlternateNumbersObject = None, language_code: str = None, holiday_schedule: str = None, extension_dialing: ExtensionDialing = None, name_dialing: ExtensionDialing = None, time_zone: str = None) -> str:
        """
        Create new Auto Attendant for the given location.
        Auto attendants play customized prompts and provide callers with menu options for routing their calls through
        your system.
        Creating an auto attendant requires a full administrator auth token with a scope of
        spark-admin:telephony_config_write.

        :param location_id: Create the auto attendant for this location.
        :type location_id: str
        :param business_schedule: Business hours defined for the auto attendant.
        :type business_schedule: str
        :param business_hours_menu: Business hours menu defined for the auto attendant.
        :type business_hours_menu: PostHoursMenuObject
        :param after_hours_menu: After hours menu defined for the auto attendant.
        :type after_hours_menu: PostHoursMenuObject
        :param org_id: Create the auto attendant for this organization.
        :type org_id: str
        :param extension: The extension for the call park extension.
        :type extension: str
        :param name: Unique name for the call park extension.
        :type name: str
        :param phone_number: Auto attendant phone number. Either phoneNumber or extension is mandatory.
        :type phone_number: str
        :param first_name: First name defined for an auto attendant.
        :type first_name: str
        :param last_name: Last name defined for an auto attendant.
        :type last_name: str
        :param alternate_numbers: Alternate numbers defined for the auto attendant.
        :type alternate_numbers: AlternateNumbersObject
        :param language_code: Language code for the auto attendant.
        :type language_code: str
        :param holiday_schedule: Holiday defined for the auto attendant.
        :type holiday_schedule: str
        :param extension_dialing: Extension dialing setting. If the values are not set default will be set as
            ENTERPRISE.
        :type extension_dialing: ExtensionDialing
        :param name_dialing: Name dialing setting. If the values are not set default will be set as ENTERPRISE.
        :type name_dialing: ExtensionDialing
        :param time_zone: Time zone defined for the auto attendant.
        :type time_zone: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/create-an-auto-attendant
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = CreateAutoAttendantBody()
        if business_schedule is not None:
            body.business_schedule = business_schedule
        if business_hours_menu is not None:
            body.business_hours_menu = business_hours_menu
        if after_hours_menu is not None:
            body.after_hours_menu = after_hours_menu
        if extension is not None:
            body.extension = extension
        if name is not None:
            body.name = name
        if phone_number is not None:
            body.phone_number = phone_number
        if first_name is not None:
            body.first_name = first_name
        if last_name is not None:
            body.last_name = last_name
        if alternate_numbers is not None:
            body.alternate_numbers = alternate_numbers
        if language_code is not None:
            body.language_code = language_code
        if holiday_schedule is not None:
            body.holiday_schedule = holiday_schedule
        if extension_dialing is not None:
            body.extension_dialing = extension_dialing
        if name_dialing is not None:
            body.name_dialing = name_dialing
        if time_zone is not None:
            body.time_zone = time_zone
        url = self.ep(f'locations/{location_id}/autoAttendants')
        data = super().post(url=url, params=params, data=body.json())
        return data["id"]

    def update_auto_attendant(self, location_id: str, auto_attendant_id: str, org_id: str = None, extension: str = None, name: str = None, phone_number: str = None, first_name: str = None, last_name: str = None, alternate_numbers: AlternateNumbersObject = None, language_code: str = None, business_schedule: str = None, holiday_schedule: str = None, extension_dialing: ExtensionDialing = None, name_dialing: ExtensionDialing = None, time_zone: str = None, business_hours_menu: HoursMenuObject = None, after_hours_menu: HoursMenuObject = None):
        """
        Update the designated Auto Attendant.
        Auto attendants play customized prompts and provide callers with menu options for routing their calls through
        your system.
        Updating an auto attendant requires a full administrator auth token with a scope of
        spark-admin:telephony_config_write.

        :param location_id: Location in which this auto attendant exists.
        :type location_id: str
        :param auto_attendant_id: Update an auto attendant with the matching ID.
        :type auto_attendant_id: str
        :param org_id: Update an auto attendant from this organization.
        :type org_id: str
        :param extension: The extension for the call park extension.
        :type extension: str
        :param name: Unique name for the call park extension.
        :type name: str
        :param phone_number: Auto attendant phone number. Either phoneNumber or extension is mandatory.
        :type phone_number: str
        :param first_name: First name defined for an auto attendant.
        :type first_name: str
        :param last_name: Last name defined for an auto attendant.
        :type last_name: str
        :param alternate_numbers: Alternate numbers defined for the auto attendant.
        :type alternate_numbers: AlternateNumbersObject
        :param language_code: Language code for the auto attendant.
        :type language_code: str
        :param business_schedule: Business hours defined for the auto attendant.
        :type business_schedule: str
        :param holiday_schedule: Holiday defined for the auto attendant.
        :type holiday_schedule: str
        :param extension_dialing: Extension dialing setting. If the values are not set default will be set as
            ENTERPRISE.
        :type extension_dialing: ExtensionDialing
        :param name_dialing: Name dialing setting. If the values are not set default will be set as ENTERPRISE.
        :type name_dialing: ExtensionDialing
        :param time_zone: Time zone defined for the auto attendant.
        :type time_zone: str
        :param business_hours_menu: Business hours menu defined for the auto attendant.
        :type business_hours_menu: HoursMenuObject
        :param after_hours_menu: After hours menu defined for the auto attendant.
        :type after_hours_menu: HoursMenuObject

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/update-an-auto-attendant
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = UpdateAutoAttendantBody()
        if extension is not None:
            body.extension = extension
        if name is not None:
            body.name = name
        if phone_number is not None:
            body.phone_number = phone_number
        if first_name is not None:
            body.first_name = first_name
        if last_name is not None:
            body.last_name = last_name
        if alternate_numbers is not None:
            body.alternate_numbers = alternate_numbers
        if language_code is not None:
            body.language_code = language_code
        if business_schedule is not None:
            body.business_schedule = business_schedule
        if holiday_schedule is not None:
            body.holiday_schedule = holiday_schedule
        if extension_dialing is not None:
            body.extension_dialing = extension_dialing
        if name_dialing is not None:
            body.name_dialing = name_dialing
        if time_zone is not None:
            body.time_zone = time_zone
        if business_hours_menu is not None:
            body.business_hours_menu = business_hours_menu
        if after_hours_menu is not None:
            body.after_hours_menu = after_hours_menu
        url = self.ep(f'locations/{location_id}/autoAttendants/{auto_attendant_id}')
        super().put(url=url, params=params, data=body.json())
        return

    def delete_auto_attendant(self, location_id: str, auto_attendant_id: str, org_id: str = None):
        """
        Delete the designated Auto Attendant.
        Auto attendants play customized prompts and provide callers with menu options for routing their calls through
        your system.
        Deleting an auto attendant requires a full administrator auth token with a scope of
        spark-admin:telephony_config_write.

        :param location_id: Location from which to delete an auto attendant.
        :type location_id: str
        :param auto_attendant_id: Delete the auto attendant with the matching ID.
        :type auto_attendant_id: str
        :param org_id: Delete the auto attendant from this organization.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/delete-an-auto-attendant
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/autoAttendants/{auto_attendant_id}')
        super().delete(url=url, params=params)
        return

    def forwarding_settings_for_auto_attendant(self, location_id: str, auto_attendant_id: str, org_id: str = None) -> AutoAttendantCallForwardSettingsDetailsObject:
        """
        Retrieve Call Forwarding settings for the designated Auto Attendant including the list of call forwarding
        rules.
        Retrieving call forwarding settings for an auto attendant requires a full or read-only administrator auth token
        with a scope of spark-admin:telephony_config_read.

        :param location_id: Location in which this auto attendant exists.
        :type location_id: str
        :param auto_attendant_id: Retrieve the call forwarding settings for this auto attendant.
        :type auto_attendant_id: str
        :param org_id: Retrieve auto attendant forwarding settings from this organization.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/get-call-forwarding-settings-for-an-auto-attendant
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/autoAttendants/{auto_attendant_id}/callForwarding')
        data = super().get(url=url, params=params)
        return AutoAttendantCallForwardSettingsDetailsObject.parse_obj(data["callForwarding"])

    def update_forwarding_settings_for_auto_attendant(self, location_id: str, auto_attendant_id: str, call_forwarding: AutoAttendantCallForwardSettingsModifyDetailsObject, org_id: str = None):
        """
        Update Call Forwarding settings for the designated Auto Attendant.
        Updating call forwarding settings for an auto attendant requires a full administrator auth token with a scope
        of spark-admin:telephony_config_write.

        :param location_id: Location in which this auto attendant exists.
        :type location_id: str
        :param auto_attendant_id: Update call forwarding settings for this auto attendant.
        :type auto_attendant_id: str
        :param call_forwarding: Settings related to Always, Busy, and No Answer call forwarding.
        :type call_forwarding: AutoAttendantCallForwardSettingsModifyDetailsObject
        :param org_id: Update auto attendant forwarding settings from this organization.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/update-call-forwarding-settings-for-an-auto-attendant
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = UpdateCallForwardingSettingsForAutoAttendantBody()
        if call_forwarding is not None:
            body.call_forwarding = call_forwarding
        url = self.ep(f'locations/{location_id}/autoAttendants/{auto_attendant_id}/callForwarding')
        super().put(url=url, params=params, data=body.json())
        return

    def create_selective_forwarding_rule_for_auto_attendant(self, location_id: str, auto_attendant_id: str, name: str, forward_to: CallForwardSelectiveForwardToObject, calls_from: CallForwardSelectiveCallsFromObject, org_id: str = None, enabled: bool = None, business_schedule: str = None, holiday_schedule: str = None, calls_to: CallForwardSelectiveCallsToObject = None) -> str:
        """
        Create a Selective Call Forwarding Rule for the designated Auto Attendant.
        A selective call forwarding rule for an auto attendant allows calls to be forwarded or not forwarded to the
        designated number, based on the defined criteria.
        Note that the list of existing call forward rules is available in the auto attendant's call forwarding
        settings.
        Creating a selective call forwarding rule for an auto attendant requires a full administrator auth token with a
        scope of spark-admin:telephony_config_write.
        NOTE: The Call Forwarding Rule ID will change upon modification of the Call Forwarding Rule name.

        :param location_id: Location in which the auto attendant exists.
        :type location_id: str
        :param auto_attendant_id: Create the rule for this auto attendant.
        :type auto_attendant_id: str
        :param name: Unique name for the selective rule in the auto attendant.
        :type name: str
        :param forward_to: Controls what happens when the rule matches including the destination number for the call
            forwarding.
        :type forward_to: CallForwardSelectiveForwardToObject
        :param calls_from: Settings related to the rule matching based on incoming caller ID.
        :type calls_from: CallForwardSelectiveCallsFromObject
        :param org_id: Create the auto attendant rule for this organization.
        :type org_id: str
        :param enabled: Reflects if rule is enabled.
        :type enabled: bool
        :param business_schedule: Name of the location's business schedule which determines when this selective call
            forwarding rule is in effect.
        :type business_schedule: str
        :param holiday_schedule: Name of the location's holiday schedule which determines when this selective call
            forwarding rule is in effect.
        :type holiday_schedule: str
        :param calls_to: Settings related to the rule matching based on the destination number.
        :type calls_to: CallForwardSelectiveCallsToObject

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/create-a-selective-call-forwarding-rule-for-an-auto-attendant
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = CreateSelectiveCallForwardingRuleForAutoAttendantBody()
        if name is not None:
            body.name = name
        if forward_to is not None:
            body.forward_to = forward_to
        if calls_from is not None:
            body.calls_from = calls_from
        if enabled is not None:
            body.enabled = enabled
        if business_schedule is not None:
            body.business_schedule = business_schedule
        if holiday_schedule is not None:
            body.holiday_schedule = holiday_schedule
        if calls_to is not None:
            body.calls_to = calls_to
        url = self.ep(f'locations/{location_id}/autoAttendants/{auto_attendant_id}/callForwarding/selectiveRules')
        data = super().post(url=url, params=params, data=body.json())
        return data["id"]

    def selective_forwarding_rule_for_auto_attendant(self, location_id: str, auto_attendant_id: str, rule_id: str, org_id: str = None) -> GetSelectiveCallForwardingRuleForAutoAttendantResponse:
        """
        Retrieve a Selective Call Forwarding Rule's settings for the designated Auto Attendant.
        A selective call forwarding rule for an auto attendant allows calls to be forwarded or not forwarded to the
        designated number, based on the defined criteria.
        Note that the list of existing call forward rules is available in the auto attendant's call forwarding
        settings.
        Retrieving a selective call forwarding rule's settings for an auto attendant requires a full or read-only
        administrator
        NOTE: The Call Forwarding Rule ID will change upon modification of the Call Forwarding Rule name.

        :param location_id: Location in which this auto attendant exists.
        :type location_id: str
        :param auto_attendant_id: Retrieve settings for a rule for this auto attendant.
        :type auto_attendant_id: str
        :param rule_id: Auto attendant rule you are retrieving settings for.
        :type rule_id: str
        :param org_id: Retrieve auto attendant rule settings for this organization.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/get-selective-call-forwarding-rule-for-an-auto-attendant
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/autoAttendants/{auto_attendant_id}/callForwarding/selectiveRules/{rule_id}')
        data = super().get(url=url, params=params)
        return GetSelectiveCallForwardingRuleForAutoAttendantResponse.parse_obj(data)

    def update_selective_forwarding_rule_for_auto_attendant(self, location_id: str, auto_attendant_id: str, rule_id: str, name: str, forward_to: CallForwardSelectiveForwardToObject, calls_from: CallForwardSelectiveCallsFromObject, org_id: str = None, enabled: bool = None, business_schedule: str = None, holiday_schedule: str = None, calls_to: CallForwardSelectiveCallsToObject = None) -> str:
        """
        Update a Selective Call Forwarding Rule's settings for the designated Auto Attendant.
        A selective call forwarding rule for an auto attendant allows calls to be forwarded or not forwarded to the
        designated number, based on the defined criteria.
        Note that the list of existing call forward rules is available in the auto attendant's call forwarding
        settings.
        Updating a selective call forwarding rule's settings for an auto attendant requires a full administrator auth
        token with a scope of spark-admin:telephony_config_write.
        NOTE: The Call Forwarding Rule ID will change upon modification of the Call Forwarding Rule name.

        :param location_id: Location in which this auto attendant exists.
        :type location_id: str
        :param auto_attendant_id: Update settings for a rule for this auto attendant.
        :type auto_attendant_id: str
        :param rule_id: Auto attendant rule you are updating settings for.
        :type rule_id: str
        :param name: Unique name for the selective rule in the auto attendant.
        :type name: str
        :param forward_to: Controls what happens when the rule matches including the destination number for the call
            forwarding.
        :type forward_to: CallForwardSelectiveForwardToObject
        :param calls_from: Settings related to the rule matching based on incoming caller ID.
        :type calls_from: CallForwardSelectiveCallsFromObject
        :param org_id: Update auto attendant rule settings for this organization.
        :type org_id: str
        :param enabled: Reflects if rule is enabled.
        :type enabled: bool
        :param business_schedule: Name of the location's business schedule which determines when this selective call
            forwarding rule is in effect.
        :type business_schedule: str
        :param holiday_schedule: Name of the location's holiday schedule which determines when this selective call
            forwarding rule is in effect.
        :type holiday_schedule: str
        :param calls_to: Settings related to the rule matching based on the destination number.
        :type calls_to: CallForwardSelectiveCallsToObject

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/update-selective-call-forwarding-rule-for-an-auto-attendant
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = CreateSelectiveCallForwardingRuleForAutoAttendantBody()
        if name is not None:
            body.name = name
        if forward_to is not None:
            body.forward_to = forward_to
        if calls_from is not None:
            body.calls_from = calls_from
        if enabled is not None:
            body.enabled = enabled
        if business_schedule is not None:
            body.business_schedule = business_schedule
        if holiday_schedule is not None:
            body.holiday_schedule = holiday_schedule
        if calls_to is not None:
            body.calls_to = calls_to
        url = self.ep(f'locations/{location_id}/autoAttendants/{auto_attendant_id}/callForwarding/selectiveRules/{rule_id}')
        data = super().put(url=url, params=params, data=body.json())
        return data["id"]

    def delete_selective_forwarding_rule_for_auto_attendant(self, location_id: str, auto_attendant_id: str, rule_id: str, org_id: str = None):
        """
        Delete a Selective Call Forwarding Rule for the designated Auto Attendant.
        A selective call forwarding rule for an auto attendant allows calls to be forwarded or not forwarded to the
        designated number, based on the defined criteria.
        Note that the list of existing call forward rules is available in the auto attendant's call forwarding
        settings.
        Deleting a selective call forwarding rule for an auto attendant requires a full administrator auth token with a
        scope of spark-admin:telephony_config_write.
        NOTE: The Call Forwarding Rule ID will change upon modification of the Call Forwarding Rule name.

        :param location_id: Location in which this auto attendant exists.
        :type location_id: str
        :param auto_attendant_id: Delete the rule for this auto attendant.
        :type auto_attendant_id: str
        :param rule_id: Auto attendant rule you are deleting.
        :type rule_id: str
        :param org_id: Delete auto attendant rule from this organization.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/delete-a-selective-call-forwarding-rule-for-an-auto-attendant
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/autoAttendants/{auto_attendant_id}/callForwarding/selectiveRules/{rule_id}')
        super().delete(url=url, params=params)
        return

    def read_list_of_parks(self, location_id: str, org_id: str = None, order: str = None, name: str = None, **params) -> Generator[ListCallParkObject, None, None]:
        """
        List all Call Parks for the organization.
        Call Park allows call recipients to place a call on hold so that it can be retrieved from another device.
        Retrieving this list requires a full or read-only administrator auth token with a scope of
        spark-admin:telephony_config_read.
        NOTE: The Call Park ID will change upon modification of the Call Park name.

        :param location_id: Return the list of call parks for this location.
        :type location_id: str
        :param org_id: List call parks for this organization.
        :type org_id: str
        :param order: Sort the list of call parks by name, either ASC or DSC. Default is ASC.
        :type order: str
        :param name: Return the list of call parks that contains the given name. The maximum length is 80.
        :type name: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/read-the-list-of-call-parks
        """
        if org_id is not None:
            params['orgId'] = org_id
        if order is not None:
            params['order'] = order
        if name is not None:
            params['name'] = name
        url = self.ep(f'locations/{location_id}/callParks')
        return self.session.follow_pagination(url=url, model=ListCallParkObject, item_key='callParks', params=params)

    def create_park(self, location_id: str, name: str, recall: PutRecallHuntGroupObject, org_id: str = None, agents: List[str] = None) -> str:
        """
        Create new Call Parks for the given location.
        Call Park allows call recipients to place a call on hold so that it can be retrieved from another device.
        Creating a call park requires a full administrator auth token with a scope of
        spark-admin:telephony_config_write.
        NOTE: The Call Park ID will change upon modification of the Call Park name.

        :param location_id: Create the call park for this location.
        :type location_id: str
        :param name: Unique name for the call pickup. The maximum length is 80.
        :type name: str
        :param recall: Recall options that are added to the call park.
        :type recall: PutRecallHuntGroupObject
        :param org_id: Create the call park for this organization.
        :type org_id: str
        :param agents: An Array of ID strings of people, workspaces and virtual lines that are added to call pickup.
        :type agents: List[str]

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/create-a-call-park
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = CreateCallParkBody()
        if name is not None:
            body.name = name
        if recall is not None:
            body.recall = recall
        if agents is not None:
            body.agents = agents
        url = self.ep(f'locations/{location_id}/callParks')
        data = super().post(url=url, params=params, data=body.json())
        return data["id"]

    def delete_park(self, location_id: str, call_park_id: str, org_id: str = None):
        """
        Delete the designated Call Park.
        Call Park allows call recipients to place a call on hold so that it can be retrieved from another device.
        Deleting a call park requires a full administrator auth token with a scope of
        spark-admin:telephony_config_write.
        NOTE: The Call Park ID will change upon modification of the Call Park name.

        :param location_id: Location from which to delete a call park.
        :type location_id: str
        :param call_park_id: Delete the call park with the matching ID.
        :type call_park_id: str
        :param org_id: Delete the call park from this organization.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/delete-a-call-park
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/callParks/{call_park_id}')
        super().delete(url=url, params=params)
        return

    def details_for_park(self, location_id: str, call_park_id: str, org_id: str = None) -> GetDetailsForCallParkResponse:
        """
        Retrieve Call Park details.
        Call Park allows call recipients to place a call on hold so that it can be retrieved from another device.
        Retrieving call park details requires a full or read-only administrator auth token with a scope of
        spark-admin:telephony_config_read.
        NOTE: The Call Park ID will change upon modification of the Call Park name.

        :param location_id: Retrieve settings for a call park in this location.
        :type location_id: str
        :param call_park_id: Retrieve settings for a call park with the matching ID.
        :type call_park_id: str
        :param org_id: Retrieve call park settings from this organization.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/get-details-for-a-call-park
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/callParks/{call_park_id}')
        data = super().get(url=url, params=params)
        return GetDetailsForCallParkResponse.parse_obj(data)

    def update_park(self, location_id: str, call_park_id: str, name: str, recall: PutRecallHuntGroupObject, org_id: str = None, agents: List[str] = None) -> str:
        """
        Update the designated Call Park.
        Call Park allows call recipients to place a call on hold so that it can be retrieved from another device.
        Updating a call park requires a full administrator auth token with a scope of
        spark-admin:telephony_config_write.
        NOTE: The Call Park ID will change upon modification of the Call Park name.

        :param location_id: Location in which this call park exists.
        :type location_id: str
        :param call_park_id: Update settings for a call park with the matching ID.
        :type call_park_id: str
        :param name: Unique name for the call pickup. The maximum length is 80.
        :type name: str
        :param recall: Recall options that are added to the call park.
        :type recall: PutRecallHuntGroupObject
        :param org_id: Update call park settings from this organization.
        :type org_id: str
        :param agents: An Array of ID strings of people, workspaces and virtual lines that are added to call pickup.
        :type agents: List[str]

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/update-a-call-park
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = CreateCallParkBody()
        if name is not None:
            body.name = name
        if recall is not None:
            body.recall = recall
        if agents is not None:
            body.agents = agents
        url = self.ep(f'locations/{location_id}/callParks/{call_park_id}')
        data = super().put(url=url, params=params, data=body.json())
        return data["id"]

    def available_agents_from_parks(self, location_id: str, org_id: str = None, call_park_name: str = None, name: str = None, phone_number: str = None, order: str = None, **params) -> Generator[GetPersonPlaceVirtualLineCallParksObject, None, None]:
        """
        Retrieve available agents from call parks for a given location.
        Call Park allows call recipients to place a call on hold so that it can be retrieved from another device.
        Retrieving available agents from call parks requires a full or read-only administrator auth token with a scope
        of spark-admin:telephony_config_read.

        :param location_id: Return the available agents for this location.
        :type location_id: str
        :param org_id: Return the available agents for this organization.
        :type org_id: str
        :param call_park_name: Only return available agents from call parks with the matching name.
        :type call_park_name: str
        :param name: Only return available agents with the matching name.
        :type name: str
        :param phone_number: Only return available agents with the matching primary number.
        :type phone_number: str
        :param order: Order the available agents according to the designated fields. Up to three vertical bar (|)
            separated sort order fields may be specified. Available sort fields: fname, lname, number and extension.
            The maximum supported sort order value is 3.
        :type order: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/get-available-agents-from-call-parks
        """
        if org_id is not None:
            params['orgId'] = org_id
        if call_park_name is not None:
            params['callParkName'] = call_park_name
        if name is not None:
            params['name'] = name
        if phone_number is not None:
            params['phoneNumber'] = phone_number
        if order is not None:
            params['order'] = order
        url = self.ep(f'locations/{location_id}/callParks/availableUsers')
        return self.session.follow_pagination(url=url, model=GetPersonPlaceVirtualLineCallParksObject, item_key='agents', params=params)

    def available_recall_hunt_groups_from_parks(self, location_id: str, org_id: str = None, name: str = None, order: str = None, **params) -> Generator[Role, None, None]:
        """
        Retrieve available recall hunt groups from call parks for a given location.
        Call Park allows call recipients to place a call on hold so that it can be retrieved from another device.
        Retrieving available recall hunt groups from call parks requires a full or read-only administrator auth token
        with a scope of spark-admin:telephony_config_read.

        :param location_id: Return the available recall hunt groups for this location.
        :type location_id: str
        :param org_id: Return the available recall hunt groups for this organization.
        :type org_id: str
        :param name: Only return available recall hunt groups with the matching name.
        :type name: str
        :param order: Order the available recall hunt groups according to the designated fields. Available sort fields:
            lname.
        :type order: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/get-available-recall-hunt-groups-from-call-parks
        """
        if org_id is not None:
            params['orgId'] = org_id
        if name is not None:
            params['name'] = name
        if order is not None:
            params['order'] = order
        url = self.ep(f'locations/{location_id}/callParks/availableRecallHuntGroups')
        return self.session.follow_pagination(url=url, model=Role, item_key='huntGroups', params=params)

    def park_settings(self, location_id: str, org_id: str = None) -> GetCallParkSettingsResponse:
        """
        Retrieve Call Park Settings from call parks for a given location.
        Call Park allows call recipients to place a call on hold so that it can be retrieved from another device.
        Retrieving settings from call parks requires a full or read-only administrator auth token with a scope of
        spark-admin:telephony_config_read.

        :param location_id: Return the call park settings for this location.
        :type location_id: str
        :param org_id: Return the call park settings for this organization.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/get-call-park-settings
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/callParks/settings')
        data = super().get(url=url, params=params)
        return GetCallParkSettingsResponse.parse_obj(data)

    def update_park_settings(self, location_id: str, org_id: str = None, call_park_recall: PutRecallHuntGroupObject = None, call_park_settings: CallParkSettingsObject = None):
        """
        Update Call Park settings for the designated location.
        Call Park allows call recipients to place a call on hold so that it can be retrieved from another device.
        Updating call park settings requires a full administrator auth token with a scope of
        spark-admin:telephony_config_write.

        :param location_id: Location for which call park settings will be updated.
        :type location_id: str
        :param org_id: Update call park settings from this organization.
        :type org_id: str
        :param call_park_recall: Recall options that are added to call park.
        :type call_park_recall: PutRecallHuntGroupObject
        :param call_park_settings: Setting controlling call park behavior.
        :type call_park_settings: CallParkSettingsObject

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/update-call-park-settings
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = UpdateCallParkSettingsBody()
        if call_park_recall is not None:
            body.call_park_recall = call_park_recall
        if call_park_settings is not None:
            body.call_park_settings = call_park_settings
        url = self.ep(f'locations/{location_id}/callParks/settings')
        super().put(url=url, params=params, data=body.json())
        return

    def read_list_of_park_extensions(self, org_id: str = None, extension: str = None, name: str = None, location_id: str = None, location_name: str = None, order: str = None, **params) -> Generator[ListCallParkExtensionObject, None, None]:
        """
        List all Call Park Extensions for the organization.
        The Call Park service, enabled for all users by default, allows a user to park a call against an available
        user's extension or to a Call Park Extension. Call Park Extensions are extensions defined within the Call Park
        service for holding parked calls.
        Retrieving this list requires a full or read-only administrator auth token with a scope of
        spark-admin:telephony_config_read.

        :param org_id: List call park extensions for this organization.
        :type org_id: str
        :param extension: Only return call park extensions with the matching extension.
        :type extension: str
        :param name: Only return call park extensions with the matching name.
        :type name: str
        :param location_id: Only return call park extensions with matching location ID.
        :type location_id: str
        :param location_name: Only return call park extensions with the matching extension.
        :type location_name: str
        :param order: Order the available agents according to the designated fields. Available sort fields: groupName,
            callParkExtension, callParkExtensionName, callParkExtensionExternalId.
        :type order: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/read-the-list-of-call-park-extensions
        """
        if org_id is not None:
            params['orgId'] = org_id
        if extension is not None:
            params['extension'] = extension
        if name is not None:
            params['name'] = name
        if location_id is not None:
            params['locationId'] = location_id
        if location_name is not None:
            params['locationName'] = location_name
        if order is not None:
            params['order'] = order
        url = self.ep('callParkExtensions')
        return self.session.follow_pagination(url=url, model=ListCallParkExtensionObject, item_key='callParkExtensions', params=params)

    def details_for_park_extension(self, location_id: str, call_park_extension_id: str, org_id: str = None) -> GetDetailsForCallParkExtensionResponse:
        """
        Retrieve Call Park Extension details.
        The Call Park service, enabled for all users by default, allows a user to park a call against an available
        user's extension or to a Call Park Extension. Call Park Extensions are extensions defined within the Call Park
        service for holding parked calls.
        Retrieving call park extension details requires a full or read-only administrator auth token with a scope of
        spark-admin:telephony_config_read.

        :param location_id: Retrieve details for a call park extension in this location.
        :type location_id: str
        :param call_park_extension_id: Retrieve details for a call park extension with the matching ID.
        :type call_park_extension_id: str
        :param org_id: Retrieve call park extension details from this organization.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/get-details-for-a-call-park-extension
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/callParkExtensions/{call_park_extension_id}')
        data = super().get(url=url, params=params)
        return GetDetailsForCallParkExtensionResponse.parse_obj(data)

    def create_park_extension(self, location_id: str, org_id: str = None, extension: str = None, name: str = None) -> str:
        """
        Create new Call Park Extensions for the given location.
        Call Park Extension enables a call recipient to park a call to an extension, so someone else within the same
        Organization can retrieve the parked call by dialing that extension. Call Park Extensions can be added as
        monitored lines by users' Cisco phones, so users can park and retrieve calls by pressing the associated phone
        line key.
        Creating a call park extension requires a full administrator auth token with a scope of
        spark-admin:telephony_config_write.

        :param location_id: Create the call park extension for this location.
        :type location_id: str
        :param org_id: Create the call park extension for this organization.
        :type org_id: str
        :param extension: The extension for the call park extension.
        :type extension: str
        :param name: Unique name for the call park extension.
        :type name: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/create-a-call-park-extension
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = GetDetailsForCallParkExtensionResponse()
        if extension is not None:
            body.extension = extension
        if name is not None:
            body.name = name
        url = self.ep(f'locations/{location_id}/callParkExtensions')
        data = super().post(url=url, params=params, data=body.json())
        return data["id"]

    def delete_park_extension(self, location_id: str, call_park_extension_id: str, org_id: str = None):
        """
        Delete the designated Call Park Extension.
        Call Park Extension enables a call recipient to park a call to an extension, so someone else within the same
        Organization can retrieve the parked call by dialing that extension. Call Park Extensions can be added as
        monitored lines by users' Cisco phones, so users can park and retrieve calls by pressing the associated phone
        line key.
        Deleting a call park extension requires a full administrator auth token with a scope of
        spark-admin:telephony_config_write.

        :param location_id: Location from which to delete a call park extension.
        :type location_id: str
        :param call_park_extension_id: Delete the call park extension with the matching ID.
        :type call_park_extension_id: str
        :param org_id: Delete the call park extension from this organization.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/delete-a-call-park-extension
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/callParkExtensions/{call_park_extension_id}')
        super().delete(url=url, params=params)
        return

    def update_park_extension(self, location_id: str, call_park_extension_id: str, org_id: str = None, extension: str = None, name: str = None):
        """
        Update the designated Call Park Extension.
        Call Park Extension enables a call recipient to park a call to an extension, so someone else within the same
        Organization can retrieve the parked call by dialing that extension. Call Park Extensions can be added as
        monitored lines by users' Cisco phones, so users can park and retrieve calls by pressing the associated phone
        line key.
        Updating a call park extension requires a full administrator auth token with a scope of
        spark-admin:telephony_config_write.

        :param location_id: Location in which this call park extension exists.
        :type location_id: str
        :param call_park_extension_id: Update a call park extension with the matching ID.
        :type call_park_extension_id: str
        :param org_id: Update a call park extension from this organization.
        :type org_id: str
        :param extension: The extension for the call park extension.
        :type extension: str
        :param name: Unique name for the call park extension.
        :type name: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/update-a-call-park-extension
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = GetDetailsForCallParkExtensionResponse()
        if extension is not None:
            body.extension = extension
        if name is not None:
            body.name = name
        url = self.ep(f'locations/{location_id}/callParkExtensions/{call_park_extension_id}')
        super().put(url=url, params=params, data=body.json())
        return

    def read_list_of_pickups(self, location_id: str, org_id: str = None, order: str = None, name: str = None, **params) -> Generator[ListCallParkObject, None, None]:
        """
        List all Call Pickups for the organization.
        Call Pickup enables a user (agent) to answer any ringing line within their pickup group.
        Retrieving this list requires a full or read-only administrator auth token with a scope of
        spark-admin:telephony_config_read.
        NOTE: The Call Pickup ID will change upon modification of the Call Pickup name.

        :param location_id: Return the list of call pickups for this location.
        :type location_id: str
        :param org_id: List call pickups for this organization.
        :type org_id: str
        :param order: Sort the list of call pickups by name, either ASC or DSC. Default is ASC.
        :type order: str
        :param name: Return the list of call pickups that contains the given name. The maximum length is 80.
        :type name: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/read-the-list-of-call-pickups
        """
        if org_id is not None:
            params['orgId'] = org_id
        if order is not None:
            params['order'] = order
        if name is not None:
            params['name'] = name
        url = self.ep(f'locations/{location_id}/callPickups')
        return self.session.follow_pagination(url=url, model=ListCallParkObject, item_key='callPickups', params=params)

    def create_pickup(self, location_id: str, name: str, org_id: str = None, agents: List[str] = None) -> str:
        """
        Create new Call Pickups for the given location.
        Call Pickup enables a user (agent) to answer any ringing line within their pickup group.
        Creating a call pickup requires a full administrator auth token with a scope of
        spark-admin:telephony_config_write.
        NOTE: The Call Pickup ID will change upon modification of the Call Pickup name.

        :param location_id: Create the call pickup for this location.
        :type location_id: str
        :param name: Unique name for the call pickup. The maximum length is 80.
        :type name: str
        :param org_id: Create the call pickup for this organization.
        :type org_id: str
        :param agents: An Array of ID strings of people, workspaces and virtual lines that are added to call pickup.
        :type agents: List[str]

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/create-a-call-pickup
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = CreateCallPickupBody()
        if name is not None:
            body.name = name
        if agents is not None:
            body.agents = agents
        url = self.ep(f'locations/{location_id}/callPickups')
        data = super().post(url=url, params=params, data=body.json())
        return data["id"]

    def delete_pickup(self, location_id: str, call_pickup_id: str, org_id: str = None):
        """
        Delete the designated Call Pickup.
        Call Pickup enables a user (agent) to answer any ringing line within their pickup group.
        Deleting a call pickup requires a full administrator auth token with a scope of
        spark-admin:telephony_config_write.
        NOTE: The Call Pickup ID will change upon modification of the Call Pickup name.

        :param location_id: Location from which to delete a call pickup.
        :type location_id: str
        :param call_pickup_id: Delete the call pickup with the matching ID.
        :type call_pickup_id: str
        :param org_id: Delete the call pickup from this organization.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/delete-a-call-pickup
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/callPickups/{call_pickup_id}')
        super().delete(url=url, params=params)
        return

    def details_for_pickup(self, location_id: str, call_pickup_id: str, org_id: str = None) -> GetDetailsForCallPickupResponse:
        """
        Retrieve Call Pickup details.
        Call Pickup enables a user (agent) to answer any ringing line within their pickup group.
        Retrieving call pickup details requires a full or read-only administrator auth token with a scope of
        spark-admin:telephony_config_read.
        NOTE: The Call Pickup ID will change upon modification of the Call Pickup name.

        :param location_id: Retrieve settings for a call pickup in this location.
        :type location_id: str
        :param call_pickup_id: Retrieve settings for a call pickup with the matching ID.
        :type call_pickup_id: str
        :param org_id: Retrieve call pickup settings from this organization.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/get-details-for-a-call-pickup
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/callPickups/{call_pickup_id}')
        data = super().get(url=url, params=params)
        return GetDetailsForCallPickupResponse.parse_obj(data)

    def update_pickup(self, location_id: str, call_pickup_id: str, name: str, org_id: str = None, agents: List[str] = None) -> str:
        """
        Update the designated Call Pickup.
        Call Pickup enables a user (agent) to answer any ringing line within their pickup group.
        Updating a call pickup requires a full administrator auth token with a scope of
        spark-admin:telephony_config_write.
        NOTE: The Call Pickup ID will change upon modification of the Call Pickup name.

        :param location_id: Location in which this call pickup exists.
        :type location_id: str
        :param call_pickup_id: Update settings for a call pickup with the matching ID.
        :type call_pickup_id: str
        :param name: Unique name for the call pickup. The maximum length is 80.
        :type name: str
        :param org_id: Update call pickup settings from this organization.
        :type org_id: str
        :param agents: An Array of ID strings of people, workspaces and virtual lines that are added to call pickup.
        :type agents: List[str]

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/update-a-call-pickup
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = CreateCallPickupBody()
        if name is not None:
            body.name = name
        if agents is not None:
            body.agents = agents
        url = self.ep(f'locations/{location_id}/callPickups/{call_pickup_id}')
        data = super().put(url=url, params=params, data=body.json())
        return data["id"]

    def available_agents_from_pickups(self, location_id: str, org_id: str = None, call_pickup_name: str = None, name: str = None, phone_number: str = None, order: str = None, **params) -> Generator[GetPersonPlaceVirtualLineCallPickupObject, None, None]:
        """
        Retrieve available agents from call pickups for a given location.
        Call Pickup enables a user (agent) to answer any ringing line within their pickup group.
        Retrieving available agents from call pickups requires a full or read-only administrator auth token with a
        scope of spark-admin:telephony_config_read.

        :param location_id: Return the available agents for this location.
        :type location_id: str
        :param org_id: Return the available agents for this organization.
        :type org_id: str
        :param call_pickup_name: Only return available agents from call pickups with the matching name.
        :type call_pickup_name: str
        :param name: Only return available agents with the matching name.
        :type name: str
        :param phone_number: Only return available agents with the matching primary number.
        :type phone_number: str
        :param order: Order the available agents according to the designated fields. Up to three vertical bar (|)
            separated sort order fields may be specified. Available sort fields: fname, lname, extension, number.
        :type order: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/get-available-agents-from-call-pickups
        """
        if org_id is not None:
            params['orgId'] = org_id
        if call_pickup_name is not None:
            params['callPickupName'] = call_pickup_name
        if name is not None:
            params['name'] = name
        if phone_number is not None:
            params['phoneNumber'] = phone_number
        if order is not None:
            params['order'] = order
        url = self.ep(f'locations/{location_id}/callPickups/availableUsers')
        return self.session.follow_pagination(url=url, model=GetPersonPlaceVirtualLineCallPickupObject, item_key='agents', params=params)

    def read_list_of_queues(self, org_id: str = None, location_id: str = None, name: str = None, phone_number: str = None, **params) -> Generator[ListCallQueueObject, None, None]:
        """
        List all Call Queues for the organization.
        Call queues temporarily hold calls in the cloud when all agents, which
        can be users or agents, assigned to receive calls from the queue are
        unavailable. Queued calls are routed to an available agent when not on an
        active call. Each call queue is assigned a Lead Number, which is a telephone
        number outside callers can dial to reach users assigned to the call queue.
        Call queues are also assigned an internal extension, which can be dialed
        internally to reach users assigned to the call queue.
        Retrieving this list requires a full or read-only administrator auth token with a scope of
        spark-admin:telephony_config_read.

        :param org_id: List call queues for this organization.
        :type org_id: str
        :param location_id: Only return call queues with matching location ID.
        :type location_id: str
        :param name: Only return call queues with the matching name.
        :type name: str
        :param phone_number: Only return call queues with matching primary phone number or extension.
        :type phone_number: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/read-the-list-of-call-queues
        """
        if org_id is not None:
            params['orgId'] = org_id
        if location_id is not None:
            params['locationId'] = location_id
        if name is not None:
            params['name'] = name
        if phone_number is not None:
            params['phoneNumber'] = phone_number
        url = self.ep('queues')
        return self.session.follow_pagination(url=url, model=ListCallQueueObject, item_key='queues', params=params)

    def create_queue(self, location_id: str, call_policies: PostCallQueueCallPolicyObject, queue_settings: CallQueueQueueSettingsObject, agents: PostPersonPlaceVirtualLineCallQueueObject, org_id: str = None, extension: str = None, name: str = None, phone_number: str = None, language_code: str = None, first_name: str = None, last_name: str = None, time_zone: str = None, allow_agent_join_enabled: bool = None, phone_number_for_outgoing_calls_enabled: bool = None) -> str:
        """
        Create new Call Queues for the given location.
        Call queues temporarily hold calls in the cloud when all agents, which
        can be users or agents, assigned to receive calls from the queue are
        unavailable. Queued calls are routed to an available agent when not on an
        active call. Each call queue is assigned a Lead Number, which is a telephone
        number outside callers can dial to reach users assigned to the call queue.
        Call queues are also assigned an internal extension, which can be dialed
        internally to reach users assigned to the call queue.
        Creating a call queue requires a full administrator auth token with a scope of
        spark-admin:telephony_config_write.

        :param location_id: Create the call queue for this location.
        :type location_id: str
        :param call_policies: Policy controlling how calls are routed to agents.
        :type call_policies: PostCallQueueCallPolicyObject
        :param queue_settings: Overall call queue settings.
        :type queue_settings: CallQueueQueueSettingsObject
        :param agents: People, workspaces and virtual lines that are eligible to receive calls.
        :type agents: PostPersonPlaceVirtualLineCallQueueObject
        :param org_id: Create the call queue for this organization.
        :type org_id: str
        :param extension: The extension for the call park extension.
        :type extension: str
        :param name: Unique name for the call park extension.
        :type name: str
        :param phone_number: Primary phone number of the call queue. Either a phoneNumber or extension is mandatory.
        :type phone_number: str
        :param language_code: Language code.
        :type language_code: str
        :param first_name: First name to be shown when calls are forwarded out of this call queue. Defaults to ".".
        :type first_name: str
        :param last_name: Last name to be shown when calls are forwarded out of this call queue. Defaults to
            phoneNumber if set, otherwise defaults to call group name.
        :type last_name: str
        :param time_zone: Time zone for the call queue.
        :type time_zone: str
        :param allow_agent_join_enabled: Whether or not to allow agents to join or unjoin a queue.
        :type allow_agent_join_enabled: bool
        :param phone_number_for_outgoing_calls_enabled: When true, indicates that the agent's configuration allows them
            to use the queue's Caller ID for outgoing calls.
        :type phone_number_for_outgoing_calls_enabled: bool

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/create-a-call-queue
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = CreateCallQueueBody()
        if call_policies is not None:
            body.call_policies = call_policies
        if queue_settings is not None:
            body.queue_settings = queue_settings
        if agents is not None:
            body.agents = agents
        if extension is not None:
            body.extension = extension
        if name is not None:
            body.name = name
        if phone_number is not None:
            body.phone_number = phone_number
        if language_code is not None:
            body.language_code = language_code
        if first_name is not None:
            body.first_name = first_name
        if last_name is not None:
            body.last_name = last_name
        if time_zone is not None:
            body.time_zone = time_zone
        if allow_agent_join_enabled is not None:
            body.allow_agent_join_enabled = allow_agent_join_enabled
        if phone_number_for_outgoing_calls_enabled is not None:
            body.phone_number_for_outgoing_calls_enabled = phone_number_for_outgoing_calls_enabled
        url = self.ep(f'locations/{location_id}/queues')
        data = super().post(url=url, params=params, data=body.json())
        return data["id"]

    def delete_queue(self, location_id: str, queue_id: str, org_id: str = None):
        """
        Delete the designated Call Queue.
        Call queues temporarily hold calls in the cloud when all agents, which
        can be users or agents, assigned to receive calls from the queue are
        unavailable. Queued calls are routed to an available agent when not on an
        active call. Each call queue is assigned a Lead Number, which is a telephone
        number outside callers can dial to reach users assigned to the call queue.
        Call queues are also assigned an internal extension, which can be dialed
        internally to reach users assigned to the call queue.
        Deleting a call queue requires a full administrator auth token with a scope of
        spark-admin:telephony_config_write.

        :param location_id: Location from which to delete a call queue.
        :type location_id: str
        :param queue_id: Delete the call queue with the matching ID.
        :type queue_id: str
        :param org_id: Delete the call queue from this organization.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/delete-a-call-queue
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/queues/{queue_id}')
        super().delete(url=url, params=params)
        return

    def details_for_queue(self, location_id: str, queue_id: str, org_id: str = None) -> GetDetailsForCallQueueResponse:
        """
        Retrieve Call Queue details.
        Call queues temporarily hold calls in the cloud when all agents, which
        can be users or agents, assigned to receive calls from the queue are
        unavailable. Queued calls are routed to an available agent when not on an
        active call. Each call queue is assigned a Lead Number, which is a telephone
        number outside callers can dial to reach users assigned to the call queue.
        Call queues are also assigned an internal extension, which can be dialed
        internally to reach users assigned to the call queue.
        Retrieving call queue details requires a full or read-only administrator auth token with a scope of
        spark-admin:telephony_config_read.

        :param location_id: Retrieve settings for a call queue in this location.
        :type location_id: str
        :param queue_id: Retrieve settings for the call queue with this identifier.
        :type queue_id: str
        :param org_id: Retrieve call queue settings from this organization.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/get-details-for-a-call-queue
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/queues/{queue_id}')
        data = super().get(url=url, params=params)
        return GetDetailsForCallQueueResponse.parse_obj(data)

    def update_queue(self, location_id: str, queue_id: str, queue_settings: CallQueueQueueSettingsObject, org_id: str = None, enabled: bool = None, phone_number: str = None, extension: int = None, name: str = None, language_code: str = None, first_name: str = None, last_name: str = None, time_zone: str = None, alternate_number_settings: AlternateNumberSettings = None, call_policies: PostCallQueueCallPolicyObject = None, allow_call_waiting_for_agents_enabled: bool = None, agents: ModifyPersonPlaceVirtualLineCallQueueObject = None, allow_agent_join_enabled: bool = None, phone_number_for_outgoing_calls_enabled: bool = None):
        """
        Update the designated Call Queue.
        Call queues temporarily hold calls in the cloud when all agents, which
        can be users or agents, assigned to receive calls from the queue are
        unavailable. Queued calls are routed to an available agent when not on an
        active call. Each call queue is assigned a Lead Number, which is a telephone
        number outside callers can dial to reach users assigned to the call queue.
        Call queues are also assigned an internal extension, which can be dialed
        internally to reach users assigned to the call queue.
        Updating a call queue requires a full administrator auth token with a scope of
        spark-admin:telephony_config_write.

        :param location_id: Location in which this call queue exists.
        :type location_id: str
        :param queue_id: Update setting for the call queue with the matching ID.
        :type queue_id: str
        :param queue_settings: Overall call queue settings.
        :type queue_settings: CallQueueQueueSettingsObject
        :param org_id: Update call queue settings from this organization.
        :type org_id: str
        :param enabled: Enable/disable fax messaging.
        :type enabled: bool
        :param phone_number: Phone number to receive fax messages.
        :type phone_number: str
        :param extension: Extension to receive fax messages.
        :type extension: int
        :param name: Unique name for the call queue.
        :type name: str
        :param language_code: Language code.
        :type language_code: str
        :param first_name: First name to be shown when calls are forwarded out of this call queue. Defaults to ..
        :type first_name: str
        :param last_name: Last name to be shown when calls are forwarded out of this call queue. Defaults to the
            phoneNumber if set, otherwise defaults to call group name.
        :type last_name: str
        :param time_zone: Time zone for the hunt group.
        :type time_zone: str
        :param alternate_number_settings: The alternate numbers feature allows you to assign multiple phone numbers or
            extensions to a call queue. Each number will reach the same greeting and each menu will function
            identically to the main number. The alternate numbers option enables you to have up to ten (10) phone
            numbers ring into the call queue.
        :type alternate_number_settings: AlternateNumberSettings
        :param call_policies: Policy controlling how calls are routed to agents.
        :type call_policies: PostCallQueueCallPolicyObject
        :param allow_call_waiting_for_agents_enabled: Flag to indicate whether call waiting is enabled for agents.
        :type allow_call_waiting_for_agents_enabled: bool
        :param agents: People, workspaces and virtual lines that are eligible to receive calls.
        :type agents: ModifyPersonPlaceVirtualLineCallQueueObject
        :param allow_agent_join_enabled: Whether or not to allow agents to join or unjoin a queue.
        :type allow_agent_join_enabled: bool
        :param phone_number_for_outgoing_calls_enabled: When true, indicates that the agent's configuration allows them
            to use the queue's Caller ID for outgoing calls.
        :type phone_number_for_outgoing_calls_enabled: bool

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/update-a-call-queue
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = UpdateCallQueueBody()
        if queue_settings is not None:
            body.queue_settings = queue_settings
        if enabled is not None:
            body.enabled = enabled
        if phone_number is not None:
            body.phone_number = phone_number
        if extension is not None:
            body.extension = extension
        if name is not None:
            body.name = name
        if language_code is not None:
            body.language_code = language_code
        if first_name is not None:
            body.first_name = first_name
        if last_name is not None:
            body.last_name = last_name
        if time_zone is not None:
            body.time_zone = time_zone
        if alternate_number_settings is not None:
            body.alternate_number_settings = alternate_number_settings
        if call_policies is not None:
            body.call_policies = call_policies
        if allow_call_waiting_for_agents_enabled is not None:
            body.allow_call_waiting_for_agents_enabled = allow_call_waiting_for_agents_enabled
        if agents is not None:
            body.agents = agents
        if allow_agent_join_enabled is not None:
            body.allow_agent_join_enabled = allow_agent_join_enabled
        if phone_number_for_outgoing_calls_enabled is not None:
            body.phone_number_for_outgoing_calls_enabled = phone_number_for_outgoing_calls_enabled
        url = self.ep(f'locations/{location_id}/queues/{queue_id}')
        super().put(url=url, params=params, data=body.json())
        return

    def read_list_of_queue_announcement_files(self, location_id: str, queue_id: str, org_id: str = None) -> list[GetAnnouncementFileInfo]:
        """
        List file info for all Call Queue announcement files associated with this Call Queue.
        Call Queue announcement files contain messages and music that callers hear while waiting in the queue. A call
        queue can be configured to play whatever subset of these announcement files is desired.
        Retrieving this list of files requires a full or read-only administrator auth token with a scope of
        spark-admin:telephony_config_read.
        Note that uploading of announcement files via API is not currently supported, but is available via Webex
        Control Hub.

        :param location_id: Location in which this call queue exists.
        :type location_id: str
        :param queue_id: Retrieve anouncement files for the call queue with this identifier.
        :type queue_id: str
        :param org_id: Retrieve announcement files for a call queue from this organization.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/read-the-list-of-call-queue-announcement-files
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/queues/{queue_id}/announcements')
        data = super().get(url=url, params=params)
        return parse_obj_as(list[GetAnnouncementFileInfo], data["announcements"])

    def delete_queue_announcement_file(self, location_id: str, queue_id: str, file_name: str, org_id: str = None):
        """
        Delete an announcement file for the designated Call Queue.
        Call Queue announcement files contain messages and music that callers hear while waiting in the queue. A call
        queue can be configured to play whatever subset of these announcement files is desired.
        Deleting an announcement file for a call queue requires a full administrator auth token with a scope of
        spark-admin:telephony_config_write.

        :param location_id: Delete an announcement for a call queue in this location.
        :type location_id: str
        :param queue_id: Delete an announcement for the call queue with this identifier.
        :type queue_id: str
        :param file_name: 
        :type file_name: str
        :param org_id: Delete call queue announcement from this organization.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/delete-a-call-queue-announcement-file
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/queues/{queue_id}/announcements/{file_name}')
        super().delete(url=url, params=params)
        return

    def forwarding_settings_for_queue(self, location_id: str, queue_id: str, org_id: str = None) -> CallForwarding:
        """
        Retrieve Call Forwarding settings for the designated Call Queue including the list of call forwarding rules.
        Retrieving call forwarding settings for a call queue requires a full or read-only administrator auth token with
        a scope of spark-admin:telephony_config_read.

        :param location_id: Location in which this call queue exists.
        :type location_id: str
        :param queue_id: Retrieve the call forwarding settings for this call queue.
        :type queue_id: str
        :param org_id: Retrieve call queue forwarding settings from this organization.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/get-call-forwarding-settings-for-a-call-queue
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/queues/{queue_id}/callForwarding')
        data = super().get(url=url, params=params)
        return CallForwarding.parse_obj(data["callForwarding"])

    def update_forwarding_settings_for_queue(self, location_id: str, queue_id: str, org_id: str = None, call_forwarding: CallForwarding1 = None):
        """
        Update Call Forwarding settings for the designated Call Queue.
        Updating call forwarding settings for a call queue requires a full administrator auth token with a scope of
        spark-admin:telephony_config_write.

        :param location_id: Location in which this call queue exists.
        :type location_id: str
        :param queue_id: Update call forwarding settings for this call queue.
        :type queue_id: str
        :param org_id: Update call queue forwarding settings from this organization.
        :type org_id: str
        :param call_forwarding: Settings related to Always, Busy, and No Answer call forwarding.
        :type call_forwarding: CallForwarding1

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/update-call-forwarding-settings-for-a-call-queue
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = UpdateCallForwardingSettingsForCallQueueBody()
        if call_forwarding is not None:
            body.call_forwarding = call_forwarding
        url = self.ep(f'locations/{location_id}/queues/{queue_id}/callForwarding')
        super().put(url=url, params=params, data=body.json())
        return

    def create_selective_forwarding_rule_for_queue(self, location_id: str, queue_id: str, name: str, calls_from: CallsFrom, calls_to: CallsTo, org_id: str = None, enabled: bool = None, holiday_schedule: str = None, business_schedule: str = None, forward_to: CallForwardSelectiveForwardToObject = None) -> str:
        """
        Create a Selective Call Forwarding Rule for the designated Call Queue.
        A selective call forwarding rule for a call queue allows calls to be forwarded or not forwarded to the
        designated number, based on the defined criteria.
        Note that the list of existing call forward rules is available in the call queue's call forwarding settings.
        Creating a selective call forwarding rule for a call queue requires a full administrator auth token with a
        scope of spark-admin:telephony_config_write.
        NOTE: The Call Forwarding Rule ID will change upon modification of the Call Forwarding Rule name.

        :param location_id: Location in which the call queue exists.
        :type location_id: str
        :param queue_id: Create the rule for this call queue.
        :type queue_id: str
        :param name: Unique name for the selective rule in the hunt group.
        :type name: str
        :param calls_from: Settings related to the rule matching based on incoming caller ID.
        :type calls_from: CallsFrom
        :param calls_to: Settings related to the rule matching based on the destination number.
        :type calls_to: CallsTo
        :param org_id: Create the call queue rule for this organization.
        :type org_id: str
        :param enabled: Reflects if rule is enabled.
        :type enabled: bool
        :param holiday_schedule: Name of the location's holiday schedule which determines when this selective call
            forwarding rule is in effect.
        :type holiday_schedule: str
        :param business_schedule: Name of the location's business schedule which determines when this selective call
            forwarding rule is in effect.
        :type business_schedule: str
        :param forward_to: Controls what happens when the rule matches including the destination number for the call
            forwarding.
        :type forward_to: CallForwardSelectiveForwardToObject

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/create-a-selective-call-forwarding-rule-for-a-call-queue
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = CreateSelectiveCallForwardingRuleForCallQueueBody()
        if name is not None:
            body.name = name
        if calls_from is not None:
            body.calls_from = calls_from
        if calls_to is not None:
            body.calls_to = calls_to
        if enabled is not None:
            body.enabled = enabled
        if holiday_schedule is not None:
            body.holiday_schedule = holiday_schedule
        if business_schedule is not None:
            body.business_schedule = business_schedule
        if forward_to is not None:
            body.forward_to = forward_to
        url = self.ep(f'locations/{location_id}/queues/{queue_id}/callForwarding/selectiveRules')
        data = super().post(url=url, params=params, data=body.json())
        return data["id"]

    def selective_forwarding_rule_for_queue(self, location_id: str, queue_id: str, rule_id: str, org_id: str = None) -> GetSelectiveCallForwardingRuleForCallQueueResponse:
        """
        Retrieve a Selective Call Forwarding Rule's settings for the designated Call Queue.
        A selective call forwarding rule for a call queue allows calls to be forwarded or not forwarded to the
        designated number, based on the defined criteria.
        Note that the list of existing call forward rules is available in the call queue's call forwarding settings.
        Retrieving a selective call forwarding rule's settings for a call queue requires a full or read-only
        administrator auth token with a scope of spark-admin:telephony_config_read.
        NOTE: The Call Forwarding Rule ID will change upon modification of the Call Forwarding Rule name.

        :param location_id: Location in which to call queue exists.
        :type location_id: str
        :param queue_id: Retrieve setting for a rule for this call queue.
        :type queue_id: str
        :param rule_id: Call queue rule you are retrieving settings for.
        :type rule_id: str
        :param org_id: Retrieve call queue rule settings for this organization.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/get-selective-call-forwarding-rule-for-a-call-queue
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/queues/{queue_id}/callForwarding/selectiveRules/{rule_id}')
        data = super().get(url=url, params=params)
        return GetSelectiveCallForwardingRuleForCallQueueResponse.parse_obj(data)

    def update_selective_forwarding_rule_for_queue(self, location_id: str, queue_id: str, rule_id: str, name: str, calls_from: CallsFrom, calls_to: CallsTo, org_id: str = None, enabled: bool = None, holiday_schedule: str = None, business_schedule: str = None, forward_to: CallForwardSelectiveForwardToObject = None) -> str:
        """
        Update a Selective Call Forwarding Rule's settings for the designated Call Queue.
        A selective call forwarding rule for a call queue allows calls to be forwarded or not forwarded to the
        designated number, based on the defined criteria.
        Note that the list of existing call forward rules is available in the call queue's call forwarding settings.
        Updating a selective call forwarding rule's settings for a call queue requires a full administrator auth token
        with a scope of spark-admin:telephony_config_write.
        NOTE: The Call Forwarding Rule ID will change upon modification of the Call Forwarding Rule name.

        :param location_id: Location in which this call queue exists.
        :type location_id: str
        :param queue_id: Update settings for a rule for this call queue.
        :type queue_id: str
        :param rule_id: Call queue rule you are updating settings for.
        :type rule_id: str
        :param name: Unique name for the selective rule in the hunt group.
        :type name: str
        :param calls_from: Settings related to the rule matching based on incoming caller ID.
        :type calls_from: CallsFrom
        :param calls_to: Settings related to the rule matching based on the destination number.
        :type calls_to: CallsTo
        :param org_id: Update call queue rule settings for this organization.
        :type org_id: str
        :param enabled: Reflects if rule is enabled.
        :type enabled: bool
        :param holiday_schedule: Name of the location's holiday schedule which determines when this selective call
            forwarding rule is in effect.
        :type holiday_schedule: str
        :param business_schedule: Name of the location's business schedule which determines when this selective call
            forwarding rule is in effect.
        :type business_schedule: str
        :param forward_to: Controls what happens when the rule matches including the destination number for the call
            forwarding.
        :type forward_to: CallForwardSelectiveForwardToObject

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/update-a-selective-call-forwarding-rule-for-a-call-queue
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = CreateSelectiveCallForwardingRuleForCallQueueBody()
        if name is not None:
            body.name = name
        if calls_from is not None:
            body.calls_from = calls_from
        if calls_to is not None:
            body.calls_to = calls_to
        if enabled is not None:
            body.enabled = enabled
        if holiday_schedule is not None:
            body.holiday_schedule = holiday_schedule
        if business_schedule is not None:
            body.business_schedule = business_schedule
        if forward_to is not None:
            body.forward_to = forward_to
        url = self.ep(f'locations/{location_id}/queues/{queue_id}/callForwarding/selectiveRules/{rule_id}')
        data = super().put(url=url, params=params, data=body.json())
        return data["id"]

    def delete_selective_forwarding_rule_for_queue(self, location_id: str, queue_id: str, rule_id: str, org_id: str = None):
        """
        Delete a Selective Call Forwarding Rule for the designated Call Queue.
        A selective call forwarding rule for a call queue allows calls to be forwarded or not forwarded to the
        designated number, based on the defined criteria.
        Note that the list of existing call forward rules is available in the call queue's call forwarding settings.
        Deleting a selective call forwarding rule for a call queue requires a full administrator auth token with a
        scope of spark-admin:telephony_config_write.
        NOTE: The Call Forwarding Rule ID will change upon modification of the Call Forwarding Rule name.

        :param location_id: Location in which this call queue exists.
        :type location_id: str
        :param queue_id: Delete the rule for this call queue.
        :type queue_id: str
        :param rule_id: Call queue rule you are deleting.
        :type rule_id: str
        :param org_id: Delete call queue rule from this organization.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/delete-a-selective-call-forwarding-rule-for-a-call-queue
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/queues/{queue_id}/callForwarding/selectiveRules/{rule_id}')
        super().delete(url=url, params=params)
        return

    def recording_settings(self, org_id: str = None) -> GetCallRecordingSettingsResponse:
        """
        Retrieve Call Recording settings for the organization.
        Call Recording feature enables authorized agents to record any active call that Webex Contact Center manages.
        Retrieving call recording settings requires a full or read-only administrator auth token with a scope of
        spark-admin:telephony_config_read.

        :param org_id: Retrieve call recording settings from this organization.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/get-call-recording-settings
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep('callRecording')
        data = super().get(url=url, params=params)
        return GetCallRecordingSettingsResponse.parse_obj(data)

    def update_recording_settings(self, enabled: bool, org_id: str = None):
        """
        Update Call Recording settings for the organization.
        Call Recording feature enables authorized agents to record any active call that Webex Contact Center manages.
        Updating call recording settings requires a full administrator auth token with a scope of
        spark-admin:telephony_config_write.
        NOTE: This API is for Cisco partners only.

        :param enabled: Whether or not the call recording is enabled.
        :type enabled: bool
        :param org_id: Retrieve call recording settings from this organization.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/update-call-recording-settings
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = UpdateCallRecordingSettingsBody()
        if enabled is not None:
            body.enabled = enabled
        url = self.ep('callRecording')
        super().put(url=url, params=params, data=body.json())
        return

    def recording_terms_of_service_settings(self, vendor_id: str, org_id: str = None) -> GetCallRecordingTermsOfServiceSettingsResponse:
        """
        Retrieve Call Recording Terms Of Service settings for the organization.
        Call Recording feature enables authorized agents to record any active call that Webex Contact Center manages.
        Retrieving call recording terms of service settings requires a full or read-only administrator auth token with
        a scope of spark-admin:telephony_config_read.

        :param vendor_id: Retrieve call recording terms of service details for the given vendor.
        :type vendor_id: str
        :param org_id: Retrieve call recording terms of service details from this organization.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/get-call-recording-terms-of-service-settings
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'callRecording/vendors/{vendor_id}/termsOfService')
        data = super().get(url=url, params=params)
        return GetCallRecordingTermsOfServiceSettingsResponse.parse_obj(data)

    def update_recording_terms_of_service_settings(self, vendor_id: str, terms_of_service_enabled: bool, org_id: str = None):
        """
        Update Call Recording Terms Of Service settings for the given vendor.
        Call Recording feature enables authorized agents to record any active call that Webex Contact Center manages.
        Updating call recording terms of service settings requires a full administrator auth token with a scope of
        spark-admin:telephony_config_write.

        :param vendor_id: Update call recording terms of service settings for the given vendor.
        :type vendor_id: str
        :param terms_of_service_enabled: Whether or not the call recording terms of service are enabled.
        :type terms_of_service_enabled: bool
        :param org_id: Update call recording terms of service settings from this organization.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/update-call-recording-terms-of-service-settings
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = UpdateCallRecordingTermsOfServiceSettingsBody()
        if terms_of_service_enabled is not None:
            body.terms_of_service_enabled = terms_of_service_enabled
        url = self.ep(f'callRecording/vendors/{vendor_id}/termsOfService')
        super().put(url=url, params=params, data=body.json())
        return

    def test_routing(self, originator_id: str, originator_type: OriginatorType, destination: str, org_id: str = None, originator_number: str = None) -> TestCallRoutingResponse:
        """
        Validates that an incoming call can be routed.
        Dial plans route calls to on-premises destinations by use of trunks or route groups.
        They are configured globally for an enterprise and apply to all users, regardless of location.
        A dial plan also specifies the routing choice (trunk or route group) for calls that match any of its dial
        patterns.
        Specific dial patterns can be defined as part of your dial plan.
        Test call routing requires a full or write-only administrator auth token with a scope of
        spark-admin:telephony_config_write.

        :param originator_id: This element is used to identify the originating party. It can be user UUID or trunk
            UUID.
        :type originator_id: str
        :param originator_type: USER or TRUNK.
        :type originator_type: OriginatorType
        :param destination: This element specifies called party. It can be any dialable string, for example, an ESN
            number, E.164 number, hosted user DN, extension, extension with location code, URL, FAC code.
        :type destination: str
        :param org_id: Organization in which we are validating a call routing.
        :type org_id: str
        :param originator_number: Only used when originatorType is TRUNK. This element could be a phone number or URI.
        :type originator_number: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/test-call-routing
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = TestCallRoutingBody()
        if originator_id is not None:
            body.originator_id = originator_id
        if originator_type is not None:
            body.originator_type = originator_type
        if destination is not None:
            body.destination = destination
        if originator_number is not None:
            body.originator_number = originator_number
        url = self.ep('actions/testCallRouting/invoke')
        data = super().post(url=url, params=params, data=body.json())
        return TestCallRoutingResponse.parse_obj(data)

    def validate_list_of_extensions(self, org_id: str = None, extensions: List[str] = None):
        """
        Validate the List of Extensions.
        Retrieving this list requires a full or read-only administrator auth token with a scope of
        spark-admin:telephony_config_read.

        :param org_id: Validate Extension for this organization.
        :type org_id: str
        :param extensions: Array of Strings of IDs of the Extensions. Possible values: 12345, 3456
        :type extensions: List[str]

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/validate-the-list-of-extensions
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = ValidateListOfExtensionsBody()
        if extensions is not None:
            body.extensions = extensions
        url = self.ep('actions/validateExtensions/invoke')
        super().post(url=url, params=params, data=body.json())
        return

    def validate_extensions(self, location_id: str, extensions: List[str], org_id: str = None) -> ValidateExtensionsResponse:
        """
        Validate extensions for a specific location.
        Validating extensions requires a full administrator auth token with a scope of
        spark-admin:telephony_config_write.

        :param location_id: Validate extensions for this location.
        :type location_id: str
        :param extensions: Array of extensions that will be validated.
        :type extensions: List[str]
        :param org_id: Validate extensions for this organization.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/validate-extensions
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = ValidateExtensionsBody()
        if extensions is not None:
            body.extensions = extensions
        url = self.ep(f'locations/{location_id}/actions/validateExtensions/invoke')
        data = super().post(url=url, params=params, data=body.json())
        return ValidateExtensionsResponse.parse_obj(data)

    def read_list_of_hunt_groups(self, org_id: str = None, location_id: str = None, name: str = None, phone_number: str = None, **params) -> Generator[ListCallQueueObject, None, None]:
        """
        List all calling Hunt Groups for the organization.
        Hunt groups can route incoming calls to a group of people or workspaces. You can even configure a pattern to
        route to a whole group.
        Retrieving this list requires a full or read-only administrator auth token with a scope of
        spark-admin:telephony_config_read.

        :param org_id: List hunt groups for this organization.
        :type org_id: str
        :param location_id: Only return hunt groups with matching location ID.
        :type location_id: str
        :param name: Only return hunt groups with the matching name.
        :type name: str
        :param phone_number: Only return hunt groups with the matching primary phone number or extension.
        :type phone_number: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/read-the-list-of-hunt-groups
        """
        if org_id is not None:
            params['orgId'] = org_id
        if location_id is not None:
            params['locationId'] = location_id
        if name is not None:
            params['name'] = name
        if phone_number is not None:
            params['phoneNumber'] = phone_number
        url = self.ep('huntGroups')
        return self.session.follow_pagination(url=url, model=ListCallQueueObject, item_key='huntGroups', params=params)

    def create_hunt_group(self, location_id: str, name: str, call_policies: PostHuntGroupCallPolicyObject, agents: PostPersonPlaceVirtualLineHuntGroupObject, org_id: str = None, enabled: bool = None, phone_number: str = None, extension: int = None, language_code: str = None, first_name: str = None, last_name: str = None, time_zone: str = None) -> str:
        """
        Create new Hunt Groups for the given location.
        Hunt groups can route incoming calls to a group of people, workspaces or virtual lines. You can even configure
        a pattern to route to a whole group.
        Creating a hunt group requires a full administrator auth token with a scope of
        spark-admin:telephony_config_write.

        :param location_id: Create the hunt group for the given location.
        :type location_id: str
        :param name: Unique name for the hunt group.
        :type name: str
        :param call_policies: Policy controlling how calls are routed to agents.
        :type call_policies: PostHuntGroupCallPolicyObject
        :param agents: People, workspaces and virtual lines that are eligible to receive calls.
        :type agents: PostPersonPlaceVirtualLineHuntGroupObject
        :param org_id: Create the hunt group for this organization.
        :type org_id: str
        :param enabled: Enable/disable fax messaging.
        :type enabled: bool
        :param phone_number: Phone number to receive fax messages.
        :type phone_number: str
        :param extension: Extension to receive fax messages.
        :type extension: int
        :param language_code: Language code.
        :type language_code: str
        :param first_name: First name to be shown when calls are forwarded out of this hunt group. Defaults to ..
        :type first_name: str
        :param last_name: Last name to be shown when calls are forwarded out of this hunt group. Defaults to the phone
            number if set, otherwise defaults to call group name.
        :type last_name: str
        :param time_zone: Time zone for the hunt group.
        :type time_zone: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/create-a-hunt-group
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = CreateHuntGroupBody()
        if name is not None:
            body.name = name
        if call_policies is not None:
            body.call_policies = call_policies
        if agents is not None:
            body.agents = agents
        if enabled is not None:
            body.enabled = enabled
        if phone_number is not None:
            body.phone_number = phone_number
        if extension is not None:
            body.extension = extension
        if language_code is not None:
            body.language_code = language_code
        if first_name is not None:
            body.first_name = first_name
        if last_name is not None:
            body.last_name = last_name
        if time_zone is not None:
            body.time_zone = time_zone
        url = self.ep(f'locations/{location_id}/huntGroups')
        data = super().post(url=url, params=params, data=body.json())
        return data["id"]

    def delete_hunt_group(self, location_id: str, hunt_group_id: str, org_id: str = None):
        """
        Delete the designated Hunt Group.
        Hunt groups can route incoming calls to a group of people or workspaces. You can even configure a pattern to
        route to a whole group.
        Deleting a hunt group requires a full administrator auth token with a scope of
        spark-admin:telephony_config_write.

        :param location_id: Location from which to delete a hunt group.
        :type location_id: str
        :param hunt_group_id: Delete the hunt group with the matching ID.
        :type hunt_group_id: str
        :param org_id: Delete the hunt group from this organization.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/delete-a-hunt-group
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/huntGroups/{hunt_group_id}')
        super().delete(url=url, params=params)
        return

    def details_for_hunt_group(self, location_id: str, hunt_group_id: str, org_id: str = None) -> GetDetailsForHuntGroupResponse:
        """
        Retrieve Hunt Group details.
        Hunt groups can route incoming calls to a group of people, workspaces or virtual lines. You can even configure
        a pattern to route to a whole group.
        Retrieving hunt group details requires a full or read-only administrator auth token with a scope of
        spark-admin:telephony_config_read.

        :param location_id: Retrieve settings for a hunt group in this location.
        :type location_id: str
        :param hunt_group_id: Retrieve settings for the hunt group with this identifier.
        :type hunt_group_id: str
        :param org_id: Retrieve hunt group settings from this organization.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/get-details-for-a-hunt-group
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/huntGroups/{hunt_group_id}')
        data = super().get(url=url, params=params)
        return GetDetailsForHuntGroupResponse.parse_obj(data)

    def update_hunt_group(self, location_id: str, hunt_group_id: str, enabled: bool, org_id: str = None, interpreters: InterpreterObjectForSimultaneousInterpretationOfCreateOrUpdateMeeting = None, name: str = None, phone_number: str = None, extension: str = None, distinctive_ring: bool = None, alternate_numbers: AlternateNumbersWithPattern = None, language_code: str = None, first_name: str = None, last_name: str = None, time_zone: str = None, call_policies: PostHuntGroupCallPolicyObject = None, agents: PostPersonPlaceVirtualLineHuntGroupObject = None):
        """
        Update the designated Hunt Group.
        Hunt groups can route incoming calls to a group of people, workspaces or virtual lines. You can even configure
        a pattern to route to a whole group.
        Updating a hunt group requires a full administrator auth token with a scope of
        spark-admin:telephony_config_write.

        :param location_id: Update the hunt group for this location.
        :type location_id: str
        :param hunt_group_id: Update settings for the hunt group with the matching ID.
        :type hunt_group_id: str
        :param enabled: Whether or not simultaneous interpretation is enabled.
        :type enabled: bool
        :param org_id: Update hunt group settings from this organization.
        :type org_id: str
        :param interpreters: Interpreters for meeting.
        :type interpreters: InterpreterObjectForSimultaneousInterpretationOfCreateOrUpdateMeeting
        :param name: Unique name for the hunt group.
        :type name: str
        :param phone_number: Primary phone number of the hunt group.
        :type phone_number: str
        :param extension: Primary phone extension of the hunt group.
        :type extension: str
        :param distinctive_ring: Whether or not the hunt group has the distinctive ring option enabled.
        :type distinctive_ring: bool
        :param alternate_numbers: The alternate numbers feature allows you to assign multiple phone numbers or
            extensions to a hunt group. Each number will reach the same greeting and each menu will function
            identically to the main number. The alternate numbers option enables you to have up to ten (10) phone
            numbers ring into the hunt group.
        :type alternate_numbers: AlternateNumbersWithPattern
        :param language_code: Language code.
        :type language_code: str
        :param first_name: First name to be shown when calls are forwarded out of this hunt group. Defaults to ..
        :type first_name: str
        :param last_name: Last name to be shown when calls are forwarded out of this hunt group. Defaults to the phone
            number if set, otherwise defaults to call group name.
        :type last_name: str
        :param time_zone: Time zone for the hunt group.
        :type time_zone: str
        :param call_policies: Policy controlling how calls are routed to agents.
        :type call_policies: PostHuntGroupCallPolicyObject
        :param agents: People, workspaces and virtual lines that are eligible to receive calls.
        :type agents: PostPersonPlaceVirtualLineHuntGroupObject

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/update-a-hunt-group
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = UpdateHuntGroupBody()
        if enabled is not None:
            body.enabled = enabled
        if interpreters is not None:
            body.interpreters = interpreters
        if name is not None:
            body.name = name
        if phone_number is not None:
            body.phone_number = phone_number
        if extension is not None:
            body.extension = extension
        if distinctive_ring is not None:
            body.distinctive_ring = distinctive_ring
        if alternate_numbers is not None:
            body.alternate_numbers = alternate_numbers
        if language_code is not None:
            body.language_code = language_code
        if first_name is not None:
            body.first_name = first_name
        if last_name is not None:
            body.last_name = last_name
        if time_zone is not None:
            body.time_zone = time_zone
        if call_policies is not None:
            body.call_policies = call_policies
        if agents is not None:
            body.agents = agents
        url = self.ep(f'locations/{location_id}/huntGroups/{hunt_group_id}')
        super().put(url=url, params=params, data=body.json())
        return

    def forwarding_settings_for_hunt_group(self, location_id: str, hunt_group_id: str, org_id: str = None) -> CallForwarding:
        """
        Retrieve Call Forwarding settings for the designated Hunt Group including the list of call forwarding rules.
        Retrieving call forwarding settings for a hunt group requires a full or read-only administrator auth token with
        a scope of spark-admin:telephony_config_read.

        :param location_id: Location in which this hunt group exists.
        :type location_id: str
        :param hunt_group_id: Read the call forwarding settings for this hunt group.
        :type hunt_group_id: str
        :param org_id: Retrieve hunt group forwarding settings from this organization.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/get-call-forwarding-settings-for-a-hunt-group
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/huntGroups/{hunt_group_id}/callForwarding')
        data = super().get(url=url, params=params)
        return CallForwarding.parse_obj(data["callForwarding"])

    def update_forwarding_settings_for_hunt_group(self, location_id: str, hunt_group_id: str, org_id: str = None, call_forwarding: CallForwarding1 = None):
        """
        Update Call Forwarding settings for the designated Hunt Group.
        Updating call forwarding settings for a hunt group requires a full administrator auth token with a scope of
        spark-admin:telephony_config_write.

        :param location_id: Location from which this hunt group exists.
        :type location_id: str
        :param hunt_group_id: Update call forwarding settings for this hunt group.
        :type hunt_group_id: str
        :param org_id: Update hunt group forwarding settings from this organization.
        :type org_id: str
        :param call_forwarding: Settings related to Always, Busy, and No Answer call forwarding.
        :type call_forwarding: CallForwarding1

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/update-call-forwarding-settings-for-a-hunt-group
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = UpdateCallForwardingSettingsForHuntGroupBody()
        if call_forwarding is not None:
            body.call_forwarding = call_forwarding
        url = self.ep(f'locations/{location_id}/huntGroups/{hunt_group_id}/callForwarding')
        super().put(url=url, params=params, data=body.json())
        return

    def create_selective_forwarding_rule_for_hunt_group(self, location_id: str, hunt_group_id: str, name: str, calls_from: CallsFrom, calls_to: CallsTo, org_id: str = None, enabled: bool = None, holiday_schedule: str = None, business_schedule: str = None, forward_to: CallForwardSelectiveForwardToObject = None) -> str:
        """
        Create a Selective Call Forwarding Rule for the designated Hunt Group.
        A selective call forwarding rule for a hunt group allows calls to be forwarded or not forwarded to the
        designated number, based on the defined criteria.
        Note that the list of existing call forward rules is available in the hunt group's call forwarding settings.
        Creating a selective call forwarding rule for a hunt group requires a full administrator auth token with a
        scope of spark-admin:telephony_config_write.
        NOTE: The Call Forwarding Rule ID will change upon modification of the Call Forwarding Rule name.

        :param location_id: Location in which this hunt group exists.
        :type location_id: str
        :param hunt_group_id: Create the rule for this hunt group.
        :type hunt_group_id: str
        :param name: Unique name for the selective rule in the hunt group.
        :type name: str
        :param calls_from: Settings related to the rule matching based on incoming caller ID.
        :type calls_from: CallsFrom
        :param calls_to: Settings related to the rule matching based on the destination number.
        :type calls_to: CallsTo
        :param org_id: Create the hunt group rule for this organization.
        :type org_id: str
        :param enabled: Reflects if rule is enabled.
        :type enabled: bool
        :param holiday_schedule: Name of the location's holiday schedule which determines when this selective call
            forwarding rule is in effect.
        :type holiday_schedule: str
        :param business_schedule: Name of the location's business schedule which determines when this selective call
            forwarding rule is in effect.
        :type business_schedule: str
        :param forward_to: Controls what happens when the rule matches including the destination number for the call
            forwarding.
        :type forward_to: CallForwardSelectiveForwardToObject

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/create-a-selective-call-forwarding-rule-for-a-hunt-group
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = CreateSelectiveCallForwardingRuleForCallQueueBody()
        if name is not None:
            body.name = name
        if calls_from is not None:
            body.calls_from = calls_from
        if calls_to is not None:
            body.calls_to = calls_to
        if enabled is not None:
            body.enabled = enabled
        if holiday_schedule is not None:
            body.holiday_schedule = holiday_schedule
        if business_schedule is not None:
            body.business_schedule = business_schedule
        if forward_to is not None:
            body.forward_to = forward_to
        url = self.ep(f'locations/{location_id}/huntGroups/{hunt_group_id}/callForwarding/selectiveRules')
        data = super().post(url=url, params=params, data=body.json())
        return data["id"]

    def selective_forwarding_rule_for_hunt_group(self, location_id: str, hunt_group_id: str, rule_id: str, org_id: str = None) -> GetSelectiveCallForwardingRuleForCallQueueResponse:
        """
        Retrieve a Selective Call Forwarding Rule's settings for the designated Hunt Group.
        A selective call forwarding rule for a hunt group allows calls to be forwarded or not forwarded to the
        designated number, based on the defined criteria.
        Note that the list of existing call forward rules is available in the hunt group's call forwarding settings.
        Retrieving a selective call forwarding rule's settings for a hunt group requires a full or read-only
        administrator auth token with a scope of spark-admin:telephony_config_read.
        NOTE: The Call Forwarding Rule ID will change upon modification of the Call Forwarding Rule name.

        :param location_id: Location in which this hunt group exists.
        :type location_id: str
        :param hunt_group_id: Retrieve settings for a rule for this hunt group.
        :type hunt_group_id: str
        :param rule_id: Hunt group rule you are retrieving settings for.
        :type rule_id: str
        :param org_id: Retrieve hunt group rule settings for this organization.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/get-selective-call-forwarding-rule-for-a-hunt-group
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/huntGroups/{hunt_group_id}/callForwarding/selectiveRules/{rule_id}')
        data = super().get(url=url, params=params)
        return GetSelectiveCallForwardingRuleForCallQueueResponse.parse_obj(data)

    def update_selective_forwarding_rule_for_hunt_group(self, location_id: str, hunt_group_id: str, rule_id: str, name: str, calls_from: CallsFrom, calls_to: CallsTo, org_id: str = None, enabled: bool = None, holiday_schedule: str = None, business_schedule: str = None, forward_to: CallForwardSelectiveForwardToObject = None) -> str:
        """
        Update a Selective Call Forwarding Rule's settings for the designated Hunt Group.
        A selective call forwarding rule for a hunt group allows calls to be forwarded or not forwarded to the
        designated number, based on the defined criteria.
        Note that the list of existing call forward rules is available in the hunt group's call forwarding settings.
        Updating a selective call forwarding rule's settings for a hunt group requires a full administrator auth token
        with a scope of spark-admin:telephony_config_write.
        NOTE: The Call Forwarding Rule ID will change upon modification of the Call Forwarding Rule name.

        :param location_id: Location in which this hunt group exists.
        :type location_id: str
        :param hunt_group_id: Update settings for a rule for this hunt group.
        :type hunt_group_id: str
        :param rule_id: Hunt group rule you are updating settings for.
        :type rule_id: str
        :param name: Unique name for the selective rule in the hunt group.
        :type name: str
        :param calls_from: Settings related to the rule matching based on incoming caller ID.
        :type calls_from: CallsFrom
        :param calls_to: Settings related to the rule matching based on the destination number.
        :type calls_to: CallsTo
        :param org_id: Update hunt group rule settings for this organization.
        :type org_id: str
        :param enabled: Reflects if rule is enabled.
        :type enabled: bool
        :param holiday_schedule: Name of the location's holiday schedule which determines when this selective call
            forwarding rule is in effect.
        :type holiday_schedule: str
        :param business_schedule: Name of the location's business schedule which determines when this selective call
            forwarding rule is in effect.
        :type business_schedule: str
        :param forward_to: Controls what happens when the rule matches including the destination number for the call
            forwarding.
        :type forward_to: CallForwardSelectiveForwardToObject

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/update-a-selective-call-forwarding-rule-for-a-hunt-group
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = CreateSelectiveCallForwardingRuleForCallQueueBody()
        if name is not None:
            body.name = name
        if calls_from is not None:
            body.calls_from = calls_from
        if calls_to is not None:
            body.calls_to = calls_to
        if enabled is not None:
            body.enabled = enabled
        if holiday_schedule is not None:
            body.holiday_schedule = holiday_schedule
        if business_schedule is not None:
            body.business_schedule = business_schedule
        if forward_to is not None:
            body.forward_to = forward_to
        url = self.ep(f'locations/{location_id}/huntGroups/{hunt_group_id}/callForwarding/selectiveRules/{rule_id}')
        data = super().put(url=url, params=params, data=body.json())
        return data["id"]

    def delete_selective_forwarding_rule_for_hunt_group(self, location_id: str, hunt_group_id: str, rule_id: str, org_id: str = None):
        """
        Delete a Selective Call Forwarding Rule for the designated Hunt Group.
        A selective call forwarding rule for a hunt group allows calls to be forwarded or not forwarded to the
        designated number, based on the defined criteria.
        Note that the list of existing call forward rules is available in the hunt group's call forwarding settings.
        Deleting a selective call forwarding rule for a hunt group requires a full administrator auth token with a
        scope of spark-admin:telephony_config_write.
        NOTE: The Call Forwarding Rule ID will change upon modification of the Call Forwarding Rule name.

        :param location_id: Location in which this hunt group exists.
        :type location_id: str
        :param hunt_group_id: Delete the rule for this hunt group.
        :type hunt_group_id: str
        :param rule_id: Hunt group rule you are deleting.
        :type rule_id: str
        :param org_id: Delete hunt group rule from this organization.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/delete-a-selective-call-forwarding-rule-for-a-hunt-group
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/huntGroups/{hunt_group_id}/callForwarding/selectiveRules/{rule_id}')
        super().delete(url=url, params=params)
        return

    def location_intercept(self, location_id: str, org_id: str = None) -> GetLocationInterceptResponse:
        """
        Retrieve intercept location details for a customer location.
        Intercept incoming or outgoing calls for persons in your organization. If this is enabled, calls are either
        routed to a designated number the person chooses, or to the person's voicemail.
        Retrieving intercept location details requires a full, user or read-only administrator auth token with a scope
        of spark-admin:telephony_config_read.

        :param location_id: Retrieve intercept details for this location.
        :type location_id: str
        :param org_id: Retrieve intercept location details for a customer location.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/get-location-intercept
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/intercept')
        data = super().get(url=url, params=params)
        return GetLocationInterceptResponse.parse_obj(data)

    def put_location_intercept(self, location_id: str, org_id: str = None, enabled: bool = None, incoming: Incoming = None, outgoing: Outgoing = None):
        """
        Modifies the intercept location details for a customer location.
        Intercept incoming or outgoing calls for users in your organization. If this is enabled, calls are either
        routed to a designated number the user chooses, or to the user's voicemail.
        Modifying the intercept location details requires a full, user administrator auth token with a scope of
        spark-admin:telephony_config_write.

        :param location_id: Modifies the intercept details for this location.
        :type location_id: str
        :param org_id: Modifies the intercept location details for a customer location.
        :type org_id: str
        :param enabled: Enable/disable location intercept. Enable this feature to override any Location's Call
            Intercept settings that person configures.
        :type enabled: bool
        :param incoming: Inbound call details.
        :type incoming: Incoming
        :param outgoing: Outbound Call details
        :type outgoing: Outgoing

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/put-location-intercept
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = GetLocationInterceptResponse()
        if enabled is not None:
            body.enabled = enabled
        if incoming is not None:
            body.incoming = incoming
        if outgoing is not None:
            body.outgoing = outgoing
        url = self.ep(f'locations/{location_id}/intercept')
        super().put(url=url, params=params, data=body.json())
        return

    def read_internal_dialing_configuration_forlocation(self, location_id: str, org_id: str = None) -> ReadInternalDialingConfigurationForlocationResponse:
        """
        Get current configuration for routing unknown extensions to the Premises as internal calls
        If some users in a location are registered to a PBX, retrieve the setting to route unknown extensions (digits
        that match the extension length) to the PBX.
        Retrieving the internal dialing configuration requires a full or read-only administrator auth token with a
        scope of spark-admin:telephony_config_read.

        :param location_id: location for which internal calling configuration is being requested
        :type location_id: str
        :param org_id: List route identities for this organization.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/read-the-internal-dialing-configuration-for-a-location
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/internalDialing')
        data = super().get(url=url, params=params)
        return ReadInternalDialingConfigurationForlocationResponse.parse_obj(data)

    def modify_internal_dialing_configuration_forlocation(self, location_id: str, org_id: str = None, enable_unknown_extension_route_policy: bool = None, unknown_extension_route_identity: UnknownExtensionRouteIdentity = None):
        """
        Modify current configuration for routing unknown extensions to the premise as internal calls
        If some users in a location are registered to a PBX, enable the setting to route unknown extensions (digits
        that match the extension length) to the PBX.
        Editing the internal dialing configuration requires a full administrator auth token with a scope of
        spark-admin:telephony_config_write.

        :param location_id: location for which internal calling configuration is being requested
        :type location_id: str
        :param org_id: List route identities for this organization.
        :type org_id: str
        :param enable_unknown_extension_route_policy: When enabled, calls made by users at the location to an unknown
            extension (between 2-6 digits) are routed to the selected route group/trunk as premises calls.
        :type enable_unknown_extension_route_policy: bool
        :param unknown_extension_route_identity: Type associated with the identity.
        :type unknown_extension_route_identity: UnknownExtensionRouteIdentity

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/modify-the-internal-dialing-configuration-for-a-location
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = ModifyInternalDialingConfigurationForlocationBody()
        if enable_unknown_extension_route_policy is not None:
            body.enable_unknown_extension_route_policy = enable_unknown_extension_route_policy
        if unknown_extension_route_identity is not None:
            body.unknown_extension_route_identity = unknown_extension_route_identity
        url = self.ep(f'locations/{location_id}/internalDialing')
        super().put(url=url, params=params, data=body.json())
        return

    def location_webexing_details(self, location_id: str, org_id: str = None) -> GetLocationWebexCallingDetailsResponse:
        """
        Shows Webex Calling details for a location, by ID.
        Specifies the location ID in the locationId parameter in the URI.
        Searching and viewing locations in your organization requires an administrator auth token with the
        spark-admin:telephony_config_read scope.

        :param location_id: Retrieve Webex Calling location attributes for this location.
        :type location_id: str
        :param org_id: Retrieve Webex Calling location attributes for this organization.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/get-location-webex-calling-details
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}')
        data = super().get(url=url, params=params)
        return GetLocationWebexCallingDetailsResponse.parse_obj(data)

    def enable_location_for_webexing(self, announcement_language: str, id: str, org_id: str = None, name: str = None, time_zone: str = None, preferred_language: str = None, address: Address = None) -> str:
        """
        Enable a location by adding it to Webex Calling. This add Webex Calling support to a
        location created created using the POST /v1/locations API.
        Locations are used to support calling features which can be defined at the location level.
        This API requires a full administrator auth token with a scope of spark-admin:telephony_config_write.

        :param announcement_language: Location's phone announcement language.
        :type announcement_language: str
        :param id: A unique identifier for the location.
        :type id: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :param name: The name of the location.
        :type name: str
        :param time_zone: Time zone associated with this location, refer to this link
            (https://developer.webex.com/docs/api/guides/webex-for-broadworks-developers-guide#webex-meetings-site-timezone)
            for format.
        :type time_zone: str
        :param preferred_language: Default email language.
        :type preferred_language: str
        :param address: The address of the location.
        :type address: Address

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/enable-a-location-for-webex-calling
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = EnableLocationForWebexCallingBody()
        if announcement_language is not None:
            body.announcement_language = announcement_language
        if id is not None:
            body.id = id
        if name is not None:
            body.name = name
        if time_zone is not None:
            body.time_zone = time_zone
        if preferred_language is not None:
            body.preferred_language = preferred_language
        if address is not None:
            body.address = address
        url = self.ep('locations')
        data = super().post(url=url, params=params, data=body.json())
        return data["id"]

    def list_locations_webexing_details(self, org_id: str = None, name: str = None, order: str = None, **params) -> Generator[ListLocationObject, None, None]:
        """
        Lists Webex Calling locations for an organization with Webex Calling details.
        Searching and viewing locations with Webex Calling details in your
        organization require an administrator auth token with the
        spark-admin:telephony_config_read scope.

        :param org_id: List locations for this organization.
        :type org_id: str
        :param name: List locations whose name contains this string.
        :type name: str
        :param order: Sort the list of locations based on name, either asc or desc.
        :type order: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/list-locations-webex-calling-details
        """
        if org_id is not None:
            params['orgId'] = org_id
        if name is not None:
            params['name'] = name
        if order is not None:
            params['order'] = order
        url = self.ep('locations')
        return self.session.follow_pagination(url=url, model=ListLocationObject, item_key='locations', params=params)

    def update_location_webexing_details(self, location_id: str, org_id: str = None, announcement_language: str = None, calling_line_id: CallingLineId = None, connection: UnknownExtensionRouteIdentity = None, external_caller_id_name: str = None, p_access_network_info: str = None, outside_dial_digit: str = None, routing_prefix: str = None, charge_number: str = None):
        """
        Update Webex Calling details for a location, by ID.
        Specifies the location ID in the locationId parameter in the URI.
        Modifying the connection via API is only supported for the local PSTN types of TRUNK and ROUTE_GROUP.
        Updating a location in your organization requires an administrator auth token with the
        spark-admin:telephony_config_write scope.

        :param location_id: Updating Webex Calling location attributes for this location.
        :type location_id: str
        :param org_id: Updating Webex Calling location attributes for this organization.
        :type org_id: str
        :param announcement_language: Location's phone announcement language.
        :type announcement_language: str
        :param calling_line_id: Location calling line information.
        :type calling_line_id: CallingLineId
        :param connection: Connection details can only be modified to and from local PSTN types of TRUNK and
            ROUTE_GROUP.
        :type connection: UnknownExtensionRouteIdentity
        :param external_caller_id_name: Denve' (string) - External Caller ID Name value. Unicode characters.
        :type external_caller_id_name: str
        :param p_access_network_info: Location Identifier.
        :type p_access_network_info: str
        :param outside_dial_digit: Must dial to reach an outside line. Default is None.
        :type outside_dial_digit: str
        :param routing_prefix: Must dial a prefix when calling between locations having same extension within same
            location; should be numeric.
        :type routing_prefix: str
        :param charge_number: Chargeable number for the line placing the call. When this is set, all calls placed from
            this location will include a P-Charge-Info header with the selected number in the SIP INVITE.
        :type charge_number: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/update-location-webex-calling-details
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = UpdateLocationWebexCallingDetailsBody()
        if announcement_language is not None:
            body.announcement_language = announcement_language
        if calling_line_id is not None:
            body.calling_line_id = calling_line_id
        if connection is not None:
            body.connection = connection
        if external_caller_id_name is not None:
            body.external_caller_id_name = external_caller_id_name
        if p_access_network_info is not None:
            body.p_access_network_info = p_access_network_info
        if outside_dial_digit is not None:
            body.outside_dial_digit = outside_dial_digit
        if routing_prefix is not None:
            body.routing_prefix = routing_prefix
        if charge_number is not None:
            body.charge_number = charge_number
        url = self.ep(f'locations/{location_id}')
        super().put(url=url, params=params, data=body.json())
        return

    def generate_example_password_for_location(self, location_id: str, org_id: str = None, generate: List[PasswordGenerate] = None) -> str:
        """
        Generates an example password using the effective password settings for the location. If you don't specify
        anything in the generate field or don't provide a request body, then you will receive a SIP password by
        default.
        Used while creating a trunk and shouldn't be used anywhere else.
        Generating an example password requires a full or write-only administrator auth token with a scope of
        spark-admin:telephony_config_write.

        :param location_id: Location for which example password has to be generated.
        :type location_id: str
        :param org_id: Organization to which the location belongs.
        :type org_id: str
        :param generate: password settings array. SIP password setting
        :type generate: List[PasswordGenerate]

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/generate-example-password-for-location
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = GenerateExamplePasswordForLocationBody()
        if generate is not None:
            body.generate = generate
        url = self.ep(f'locations/{location_id}/actions/generatePassword/invoke')
        data = super().post(url=url, params=params, data=body.json())
        return data["exampleSipPassword"]

    def location_outgoing_permission(self, location_id: str, org_id: str = None) -> list[CallingPermissionObject]:
        """
        Retrieve the location's outgoing call settings.
        A location's outgoing call settings allow you to determine the types of calls the people/workspaces at the
        location are allowed to make, as well as configure the default calling permission for each call type at the
        location.
        Retrieving a location's outgoing call settings requires a full, user or read-only administrator auth token with
        a scope of spark-admin:telephony_config_read.

        :param location_id: Retrieve outgoing call settings for this location.
        :type location_id: str
        :param org_id: Retrieve outgoing call settings for this organization.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/get-location-outgoing-permission
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/outgoingPermission')
        data = super().get(url=url, params=params)
        return parse_obj_as(list[CallingPermissionObject], data["callingPermissions"])

    def update_location_outgoing_permission(self, location_id: str, org_id: str = None, calling_permissions: CallingPermissionObject = None):
        """
        Update the location's outgoing call settings.
        Location's outgoing call settings allows you to determine the types of calls the people/workspaces at this
        location are allowed to make and configure the default calling permission for each call type at a location.
        Updating a location's outgoing call settings requires a full administrator auth token with a scope of
        spark-admin:telephony_config_write.

        :param location_id: Update outgoing call settings for this location.
        :type location_id: str
        :param org_id: Update outgoing call settings for this organization.
        :type org_id: str
        :param calling_permissions: Array specifying the subset of calling permissions to be updated.
        :type calling_permissions: CallingPermissionObject

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/update-location-outgoing-permission
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = UpdateLocationOutgoingPermissionBody()
        if calling_permissions is not None:
            body.calling_permissions = calling_permissions
        url = self.ep(f'locations/{location_id}/outgoingPermission')
        super().put(url=url, params=params, data=body.json())
        return

    def outgoing_permission_auto_transfer_number(self, location_id: str, org_id: str = None) -> GetOutgoingPermissionAutoTransferNumberResponse:
        """
        Get the transfer numbers for the outbound permission in a location.
        Outbound permissions can specify which transfer number an outbound call should transfer to via the action
        field.
        Retrieving an auto transfer number requires a full, user or read-only administrator auth token with a scope of
        spark-admin:telephony_config_read.

        :param location_id: Retrieve auto transfer number for this location.
        :type location_id: str
        :param org_id: Retrieve auto transfer number for this organization.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/get-outgoing-permission-auto-transfer-number
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/outgoingPermission/autoTransferNumbers')
        data = super().get(url=url, params=params)
        return GetOutgoingPermissionAutoTransferNumberResponse.parse_obj(data)

    def put_outgoing_permission_auto_transfer_number(self, location_id: str, org_id: str = None, auto_transfer_number1: str = None, auto_transfer_number2: str = None, auto_transfer_number3: str = None):
        """
        Modifies the transfer numbers for the outbound permission in a location.
        Outbound permissions can specify which transfer number an outbound call should transfer to via the action
        field.
        Updating auto transfer number requires a full administrator auth token with a scope of
        spark-admin:telephony_config_write.

        :param location_id: Updating auto transfer number for this location.
        :type location_id: str
        :param org_id: Updating auto transfer number for this organization.
        :type org_id: str
        :param auto_transfer_number1: Calls placed meeting the criteria in an outbound rule whose action is
            TRANSFER_NUMBER_1 will be transferred to this number.
        :type auto_transfer_number1: str
        :param auto_transfer_number2: Calls placed meeting the criteria in an outbound rule whose action is
            TRANSFER_NUMBER_2 will be transferred to this number.
        :type auto_transfer_number2: str
        :param auto_transfer_number3: Calls placed meeting the criteria in an outbound rule whose action is
            TRANSFER_NUMBER_3 will be transferred to this number.
        :type auto_transfer_number3: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/put-outgoing-permission-auto-transfer-number
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = GetOutgoingPermissionAutoTransferNumberResponse()
        if auto_transfer_number1 is not None:
            body.auto_transfer_number1 = auto_transfer_number1
        if auto_transfer_number2 is not None:
            body.auto_transfer_number2 = auto_transfer_number2
        if auto_transfer_number3 is not None:
            body.auto_transfer_number3 = auto_transfer_number3
        url = self.ep(f'locations/{location_id}/outgoingPermission/autoTransferNumbers')
        super().put(url=url, params=params, data=body.json())
        return

    def outgoing_permission_location_access_code(self, location_id: str, org_id: str = None) -> ReportError:
        """
        Retrieve access codes details for a customer location.
        Use Access Codes to bypass the set permissions for all persons/workspaces at this location.
        Retrieving access codes details requires a full, user or read-only administrator auth token with a scope of
        spark-admin:telephony_config_read.

        :param location_id: Retrieve access codes details for this location.
        :type location_id: str
        :param org_id: Retrieve access codes details for a customer location.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/get-outgoing-permission-location-access-code
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/outgoingPermission/accessCodes')
        data = super().get(url=url, params=params)
        return ReportError.parse_obj(data["accessCodes"])

    def create_outgoing_permissionnew_access_code_forcustomer_location(self, location_id: str, org_id: str = None, access_codes: ReportError = None):
        """
        Add a new access code for the given location for a customer.
        Use Access Codes to bypass the set permissions for all persons/workspaces at this location.
        Creating an access code for the given location requires a full or user administrator auth token with a scope of
        spark-admin:telephony_config_write.

        :param location_id: Add new access code for this location.
        :type location_id: str
        :param org_id: Add new access code for this organization.
        :type org_id: str
        :param access_codes: Access code details
        :type access_codes: ReportError

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/create-outgoing-permission-a-new-access-code-for-a-customer-location
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = CreateOutgoingPermissionnewAccessCodeForcustomerLocationBody()
        if access_codes is not None:
            body.access_codes = access_codes
        url = self.ep(f'locations/{location_id}/outgoingPermission/accessCodes')
        super().post(url=url, params=params, data=body.json())
        return

    def delete_outgoing_permission_access_code_location(self, location_id: str, delete_codes: List[str], org_id: str = None):
        """
        Deletes the access code details for a particular location for a customer.
        Use Access Codes to bypass the set permissions for all persons/workspaces at this location.
        Modifying the access code location details requires a full administrator auth token with a scope of
        spark-admin:telephony_config_write.

        :param location_id: Deletes the access code details for this location.
        :type location_id: str
        :param delete_codes: Array of string to delete access codes. For example, ["1234","2345"]
        :type delete_codes: List[str]
        :param org_id: Deletes the access code details for a customer location.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/delete-outgoing-permission-access-code-location
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = DeleteOutgoingPermissionAccessCodeLocationBody()
        if delete_codes is not None:
            body.delete_codes = delete_codes
        url = self.ep(f'locations/{location_id}/outgoingPermission/accessCodes')
        super().put(url=url, params=params, data=body.json())
        return

    def read_list_of_paging_groups(self, org_id: str = None, location_id: str = None, name: str = None, phone_number: str = None, **params) -> Generator[ListAutoAttendantObject, None, None]:
        """
        List all Paging Groups for the organization.
        Group Paging allows a person to place a one-way call or group page to up to 75 people and/or workspaces by
        dialing a number or extension assigned to a specific paging group. The Group Paging service makes a
        simultaneous call to all the assigned targets.
        Retrieving this list requires a full or read-only administrator auth token with a scope of
        spark-admin:telephony_config_read.

        :param org_id: List paging groups for this organization.
        :type org_id: str
        :param location_id: Return only paging groups with matching location ID. Default is all locations
        :type location_id: str
        :param name: Return only paging groups with the matching name.
        :type name: str
        :param phone_number: Return only paging groups with matching primary phone number or extension.
        :type phone_number: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/read-the-list-of-paging-groups
        """
        if org_id is not None:
            params['orgId'] = org_id
        if location_id is not None:
            params['locationId'] = location_id
        if name is not None:
            params['name'] = name
        if phone_number is not None:
            params['phoneNumber'] = phone_number
        url = self.ep('paging')
        return self.session.follow_pagination(url=url, model=ListAutoAttendantObject, item_key='locationPaging', params=params)

    def createnew_paging_group(self, location_id: str, org_id: str = None, extension: str = None, name: str = None, phone_number: str = None, language_code: str = None, first_name: str = None, last_name: str = None, originator_caller_id_enabled: bool = None, originators: List[str] = None, targets: List[str] = None) -> str:
        """
        Create a new Paging Group for the given location.
        Group Paging allows a one-way call or group page to up to 75 people, workspaces and virtual lines by
        dialing a number or extension assigned to a specific paging group. The Group Paging service makes a
        simultaneous call to all the assigned targets.
        Creating a paging group requires a full administrator auth token with a scope of
        spark-admin:telephony_config_write.

        :param location_id: Create the paging group for this location.
        :type location_id: str
        :param org_id: Create the paging group for this organization.
        :type org_id: str
        :param extension: The extension for the call park extension.
        :type extension: str
        :param name: Unique name for the call park extension.
        :type name: str
        :param phone_number: Paging group phone number. Minimum length is 1. Maximum length is 23. Either phoneNumber
            or extension is mandatory.
        :type phone_number: str
        :param language_code: Language code.
        :type language_code: str
        :param first_name: First name that displays when a group page is performed. Minimum length is 1. Maximum length
            is 30.
        :type first_name: str
        :param last_name: Last name that displays when a group page is performed. Minimum length is 1. Maximum length
            is 30.
        :type last_name: str
        :param originator_caller_id_enabled: Determines what is shown on target users caller ID when a group page is
            performed. If true shows page originator ID.
        :type originator_caller_id_enabled: bool
        :param originators: An array of people, workspace, and virtual lines IDs who can originate pages to this paging
            group.
        :type originators: List[str]
        :param targets: An array of people, workspaces and virtual lines IDs will add to a paging group as paging call
            targets.
        :type targets: List[str]

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/create-a-new-paging-group
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = CreatenewPagingGroupBody()
        if extension is not None:
            body.extension = extension
        if name is not None:
            body.name = name
        if phone_number is not None:
            body.phone_number = phone_number
        if language_code is not None:
            body.language_code = language_code
        if first_name is not None:
            body.first_name = first_name
        if last_name is not None:
            body.last_name = last_name
        if originator_caller_id_enabled is not None:
            body.originator_caller_id_enabled = originator_caller_id_enabled
        if originators is not None:
            body.originators = originators
        if targets is not None:
            body.targets = targets
        url = self.ep(f'locations/{location_id}/paging')
        data = super().post(url=url, params=params, data=body.json())
        return data["id"]

    def delete_paging_group(self, location_id: str, paging_id: str, org_id: str = None):
        """
        Delete the designated Paging Group.
        Group Paging allows a person to place a one-way call or group page to up to 75 people and/or workspaces by
        dialing a number or extension assigned to a specific paging group. The Group Paging service makes a
        simultaneous call to all the assigned targets.
        Deleting a paging group requires a full administrator auth token with a scope of
        spark-admin:telephony_config_write.

        :param location_id: Location from which to delete a paging group.
        :type location_id: str
        :param paging_id: Delete the paging group with the matching ID.
        :type paging_id: str
        :param org_id: Delete the paging group from this organization.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/delete-a-paging-group
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/paging/{paging_id}')
        super().delete(url=url, params=params)
        return

    def details_for_paging_group(self, location_id: str, paging_id: str, org_id: str = None) -> GetDetailsForPagingGroupResponse:
        """
        Retrieve Paging Group details.
        Group Paging allows a person, place or virtual line a one-way call or group page to up to 75 people and/or
        workspaces and/or virtual line by
        dialing a number or extension assigned to a specific paging group. The Group Paging service makes a
        simultaneous call to all the assigned targets.
        Retrieving paging group details requires a full or read-only administrator auth token with a scope of
        spark-admin:telephony_config_read.

        :param location_id: Retrieve settings for a paging group in this location.
        :type location_id: str
        :param paging_id: Retrieve settings for the paging group with this identifier.
        :type paging_id: str
        :param org_id: Retrieve paging group settings from this organization.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/get-details-for-a-paging-group
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/paging/{paging_id}')
        data = super().get(url=url, params=params)
        return GetDetailsForPagingGroupResponse.parse_obj(data)

    def update_paging_group(self, location_id: str, paging_id: str, org_id: str = None, extension: str = None, name: str = None, phone_number: str = None, language_code: str = None, first_name: str = None, last_name: str = None, originator_caller_id_enabled: bool = None, originators: List[str] = None, targets: List[str] = None, enabled: bool = None):
        """
        Update the designated Paging Group.
        Group Paging allows a person to place a one-way call or group page to up to 75 people, workspaces and virtual
        lines by
        dialing a number or extension assigned to a specific paging group. The Group Paging service makes a
        simultaneous call to all the assigned targets.
        Updating a paging group requires a full administrator auth token with a scope of
        spark-admin:telephony_config_write.

        :param location_id: Update settings for a paging group in this location.
        :type location_id: str
        :param paging_id: Update settings for the paging group with this identifier.
        :type paging_id: str
        :param org_id: Update paging group settings from this organization.
        :type org_id: str
        :param extension: The extension for the call park extension.
        :type extension: str
        :param name: Unique name for the call park extension.
        :type name: str
        :param phone_number: Paging group phone number. Minimum length is 1. Maximum length is 23. Either phoneNumber
            or extension is mandatory.
        :type phone_number: str
        :param language_code: Language code.
        :type language_code: str
        :param first_name: First name that displays when a group page is performed. Minimum length is 1. Maximum length
            is 30.
        :type first_name: str
        :param last_name: Last name that displays when a group page is performed. Minimum length is 1. Maximum length
            is 30.
        :type last_name: str
        :param originator_caller_id_enabled: Determines what is shown on target users caller ID when a group page is
            performed. If true shows page originator ID.
        :type originator_caller_id_enabled: bool
        :param originators: An array of people, workspace, and virtual lines IDs who can originate pages to this paging
            group.
        :type originators: List[str]
        :param targets: An array of people, workspaces and virtual lines IDs will add to a paging group as paging call
            targets.
        :type targets: List[str]
        :param enabled: Whether or not the paging group is enabled.
        :type enabled: bool

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/update-a-paging-group
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = UpdatePagingGroupBody()
        if extension is not None:
            body.extension = extension
        if name is not None:
            body.name = name
        if phone_number is not None:
            body.phone_number = phone_number
        if language_code is not None:
            body.language_code = language_code
        if first_name is not None:
            body.first_name = first_name
        if last_name is not None:
            body.last_name = last_name
        if originator_caller_id_enabled is not None:
            body.originator_caller_id_enabled = originator_caller_id_enabled
        if originators is not None:
            body.originators = originators
        if targets is not None:
            body.targets = targets
        if enabled is not None:
            body.enabled = enabled
        url = self.ep(f'locations/{location_id}/paging/{paging_id}')
        super().put(url=url, params=params, data=body.json())
        return

    def add_phone_numbers_tolocation(self, location_id: str, phone_numbers: List[str], state: State11, org_id: str = None):
        """
        Adds a specified set of phone numbers to a location for an organization.
        Each location has a set of phone numbers that can be assigned to people, workspaces, or features. Phone numbers
        must follow E.164 format for all countries, except for the United States, which can also follow the National
        format. Active phone numbers are in service.
        Adding a phone number to a location requires a full administrator auth token with a scope of
        spark-admin:telephony_config_write.

        :param location_id: LocationId to which numbers should be added.
        :type location_id: str
        :param phone_numbers: List of phone numbers that need to be added.
        :type phone_numbers: List[str]
        :param state: State of the phone numbers.
        :type state: State11
        :param org_id: Organization of the Route Group.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/add-phone-numbers-to-a-location
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = AddPhoneNumbersTolocationBody()
        if phone_numbers is not None:
            body.phone_numbers = phone_numbers
        if state is not None:
            body.state = state
        url = self.ep(f'locations/{location_id}/numbers')
        super().post(url=url, params=params, data=body.json())
        return

    def activate_phone_numbers_inlocation(self, location_id: str, phone_numbers: List[str], org_id: str = None):
        """
        Activate the specified set of phone numbers in a location for an organization.
        Each location has a set of phone numbers that can be assigned to people, workspaces, or features. Phone numbers
        must follow E.164 format for all countries, except for the United States, which can also follow the National
        format. Active phone numbers are in service.
        Activating a phone number in a location requires a full administrator auth token with a scope of
        spark-admin:telephony_config_write.

        :param location_id: LocationId to which numbers should be added.
        :type location_id: str
        :param phone_numbers: List of phone numbers that need to be added.
        :type phone_numbers: List[str]
        :param org_id: Organization of the Route Group.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/activate-phone-numbers-in-a-location
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = ActivatePhoneNumbersInlocationBody()
        if phone_numbers is not None:
            body.phone_numbers = phone_numbers
        url = self.ep(f'locations/{location_id}/numbers')
        super().put(url=url, params=params, data=body.json())
        return

    def remove_phone_numbers_fromlocation(self, location_id: str, phone_numbers: List[str], state: State11, org_id: str = None):
        """
        Remove the specified set of phone numbers from a location for an organization.
        Each location has a set of phone numbers that can be assigned to people, workspaces, or features. Phone numbers
        must follow E.164 format for all countries, except for the United States, which can also follow the National
        format. Active phone numbers are in service.
        Removing a phone number from a location requires a full administrator auth token with a scope of
        spark-admin:telephony_config_write.

        :param location_id: LocationId to which numbers should be added.
        :type location_id: str
        :param phone_numbers: List of phone numbers that need to be added.
        :type phone_numbers: List[str]
        :param state: State of the phone numbers.
        :type state: State11
        :param org_id: Organization of the Route Group.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/remove-phone-numbers-from-a-location
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = AddPhoneNumbersTolocationBody()
        if phone_numbers is not None:
            body.phone_numbers = phone_numbers
        if state is not None:
            body.state = state
        url = self.ep(f'locations/{location_id}/numbers')
        super().delete(url=url, params=params, data=body.json())
        return

    def phone_numbers_for_organization_with_given_criterias(self, org_id: str = None, location_id: str = None, max: int = None, start: int = None, phone_number: str = None, available: bool = None, order: str = None, owner_name: str = None, owner_id: str = None, owner_type: enum = None, extension: str = None, number_type: str = None, phone_number_type: str = None, state: str = None, details: bool = None, toll_free_numbers: bool = None, restricted_non_geo_numbers: bool = None) -> NumberListGetObject:
        """
        List all the phone numbers for the given organization along with the status and owner (if any).
        PSTN phone numbers are associated with a specific location and can be active/inactive and assigned/unassigned.
        The owner is the person, workspace, or feature to which the number is assigned.
        Retrieving this list requires a full or read-only administrator auth token with a scope of
        spark-admin:telephony_config_read.

        :param org_id: List numbers for this organization.
        :type org_id: str
        :param location_id: Return the list of phone numbers for this location within the given organization. The
            maximum length is 36.
        :type location_id: str
        :param max: Limit the number of phone numbers returned to this maximum count. Default is 2000.
        :type max: int
        :param start: Start at the zero-based offset in the list of matching phone numbers. Default is 0.
        :type start: int
        :param phone_number: Search for this phoneNumber.
        :type phone_number: str
        :param available: Search among the available phone numbers. This parameter cannot be used along with ownerType
            parameter when set to true.
        :type available: bool
        :param order: Sort the list of phone numbers based on the following:lastName,dn,extension. Default sort will be
            based on number and extension in an ascending order
        :type order: str
        :param owner_name: Return the list of phone numbers that is owned by given ownerName. Maximum length is 255.
        :type owner_name: str
        :param owner_id: Returns only the matched number/extension entries assigned to the feature with specified
            uuid/broadsoftId.
        :type owner_id: str
        :param owner_type: Returns the list of phone numbers that are of given ownerType. Possible input values
        :type owner_type: enum
        :param extension: Returns the list of PSTN phone numbers with the given extension.
        :type extension: str
        :param number_type: Returns the filtered list of PSTN phone numbers that contains given type of numbers. This
            parameter cannot be used along with available or state.
        :type number_type: str
        :param phone_number_type: Returns the filtered list of PSTN phone numbers that are of given phoneNumberType.
        :type phone_number_type: str
        :param state: Returns the list of PSTN phone numbers with matching state.
        :type state: str
        :param details: Returns the overall count of the PSTN phone numbers along with other details for given
            organization.
        :type details: bool
        :param toll_free_numbers: Returns the list of toll free phone numbers.
        :type toll_free_numbers: bool
        :param restricted_non_geo_numbers: Returns the list of restricted non geographical numbers.
        :type restricted_non_geo_numbers: bool

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/get-phone-numbers-for-an-organization-with-given-criterias
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        if location_id is not None:
            params['locationId'] = location_id
        if max is not None:
            params['max'] = max
        if start is not None:
            params['start'] = start
        if phone_number is not None:
            params['phoneNumber'] = phone_number
        if available is not None:
            params['available'] = str(available).lower()
        if order is not None:
            params['order'] = order
        if owner_name is not None:
            params['ownerName'] = owner_name
        if owner_id is not None:
            params['ownerId'] = owner_id
        if owner_type is not None:
            params['ownerType'] = owner_type
        if extension is not None:
            params['extension'] = extension
        if number_type is not None:
            params['numberType'] = number_type
        if phone_number_type is not None:
            params['phoneNumberType'] = phone_number_type
        if state is not None:
            params['state'] = state
        if details is not None:
            params['details'] = str(details).lower()
        if toll_free_numbers is not None:
            params['tollFreeNumbers'] = str(toll_free_numbers).lower()
        if restricted_non_geo_numbers is not None:
            params['restrictedNonGeoNumbers'] = str(restricted_non_geo_numbers).lower()
        url = self.ep('numbers')
        data = super().get(url=url, params=params)
        return NumberListGetObject.parse_obj(data["phoneNumbers"])

    def list_manage_numbers_jobs(self, org_id: str = None, **params) -> Generator[StartJobResponse, None, None]:
        """
        Lists all Manage Numbers jobs for the given organization in order of most recent one to oldest one irrespective
        of its status.
        The public API only supports initiating jobs which move numbers between locations.
        Via Control Hub they can initiate both the move and delete, so this listing can show both.
        This API requires a full or read-only administrator auth token with a scope of
        spark-admin:telephony_config_read.

        :param org_id: Retrieve list of Manage Number jobs for this organization.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/list-manage-numbers-jobs
        """
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep('jobs/numbers/manageNumbers')
        return self.session.follow_pagination(url=url, model=StartJobResponse, params=params)

    def initiate_move_number_jobs(self, operation: str, target_location_id: str, number_list: NumberItem) -> StartJobResponse:
        """
        Starts the numbers move from one location to another location. Although jobs can do both MOVE and DELETE
        actions internally, only MOVE is supported publicly.
        In order to move a number,
        For example, you can move from Cisco PSTN to Cisco PSTN, but you cannot move from Cisco PSTN to a location with
        Cloud Connected PSTN.
        This API requires a full administrator auth token with a scope of spark-admin:telephony_config_write.

        :param operation: Indicates the kind of operation to be carried out.
        :type operation: str
        :param target_location_id: The target location within organization where the unassigned numbers will be moved
            from the source location.
        :type target_location_id: str
        :param number_list: Indicates the numbers to be moved from source to target locations.
        :type number_list: NumberItem

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/initiate-move-number-jobs
        """
        body = InitiateMoveNumberJobsBody()
        if operation is not None:
            body.operation = operation
        if target_location_id is not None:
            body.target_location_id = target_location_id
        if number_list is not None:
            body.number_list = number_list
        url = self.ep('jobs/numbers/manageNumbers')
        data = super().post(url=url, data=body.json())
        return StartJobResponse.parse_obj(data)

    def manage_numbers_job_status(self, job_id: str = None) -> GetManageNumbersJobStatusResponse:
        """
        Returns the status and other details of the job.
        This API requires a full or read-only administrator auth token with a scope of
        spark-admin:telephony_config_read.

        :param job_id: Retrieve job details for this jobId.
        :type job_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/get-manage-numbers-job-status
        """
        url = self.ep(f'jobs/numbers/manageNumbers/{job_id}')
        data = super().get(url=url)
        return GetManageNumbersJobStatusResponse.parse_obj(data)

    def pause_manage_numbers_job(self, job_id: str = None, org_id: str = None):
        """
        Pause the running Manage Numbers Job. A paused job can be resumed or abandoned.
        This API requires a full administrator auth token with a scope of spark-admin:telephony_config_write.

        :param job_id: Pause the Manage Numbers job for this jobId.
        :type job_id: str
        :param org_id: Pause the Manage Numbers job for this organization.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/pause-the-manage-numbers-job
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'jobs/numbers/manageNumbers/{job_id}/actions/pause/invoke')
        super().post(url=url, params=params)
        return

    def resume_manage_numbers_job(self, job_id: str = None, org_id: str = None):
        """
        Resume the paused Manage Numbers Job. A paused job can be resumed or abandoned.
        This API requires a full administrator auth token with a scope of spark-admin:telephony_config_write.

        :param job_id: Resume the Manage Numbers job for this jobId.
        :type job_id: str
        :param org_id: Resume the Manage Numbers job for this organization.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/resume-the-manage-numbers-job
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'jobs/numbers/manageNumbers/{job_id}/actions/resume/invoke')
        super().post(url=url, params=params)
        return

    def abandon_manage_numbers_job(self, job_id: str = None, org_id: str = None):
        """
        Abandon the Manage Numbers Job.
        This API requires a full administrator auth token with a scope of spark-admin:telephony_config_write.

        :param job_id: Abandon the Manage Numbers job for this jobId.
        :type job_id: str
        :param org_id: Abandon the Manage Numbers job for this organization.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/abandon-the-manage-numbers-job
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'jobs/numbers/manageNumbers/{job_id}/actions/abandon/invoke')
        super().post(url=url, params=params)
        return

    def list_manage_numbers_job_errors(self, job_id: str = None, org_id: str = None, **params) -> Generator[ItemObject, None, None]:
        """
        Lists all error details of Manage Numbers job. This will not list any errors if exitCode is COMPLETED. If the
        status is COMPLETED_WITH_ERRORS then this lists the cause of failures.
        List of possible Errors:
        This API requires a full or read-only administrator auth token with a scope of
        spark-admin:telephony_config_read.

        :param job_id: Retrieve the error details for this jobId.
        :type job_id: str
        :param org_id: Retrieve list of jobs for this organization.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/list-manage-numbers-job-errors
        """
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'jobs/numbers/manageNumbers/{job_id}/errors')
        return self.session.follow_pagination(url=url, model=ItemObject, params=params)

    def private_network_connect(self, location_id: str, org_id: str = None) -> NetworkConnectionType:
        """
        Retrieve the location's network connection type.
        Network Connection Type determines if the location's network connection is public or private.
        Retrieving a location's network connection type requires a full, user or read-only administrator auth token
        with a scope of spark-admin:telephony_config_read.

        :param location_id: Retrieve the network connection type for this location.
        :type location_id: str
        :param org_id: Retrieve the network connection type for this organization.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/get-private-network-connect
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/privateNetworkConnect')
        data = super().get(url=url, params=params)
        return NetworkConnectionType.parse_obj(data["networkConnectionType"])

    def update_private_network_connect(self, location_id: str, network_connection_type: NetworkConnectionType, org_id: str = None):
        """
        Update the location's network connection type.
        Network Connection Type determines if the location's network connection is public or private.
        Updating a location's network connection type requires a full administrator auth token with a scope of
        spark-admin:telephony_config_write.

        :param location_id: Update the network connection type for this location.
        :type location_id: str
        :param network_connection_type: Network Connection Type for the location.
        :type network_connection_type: NetworkConnectionType
        :param org_id: Update network connection type for this organization.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/update-private-network-connect
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = UpdatePrivateNetworkConnectBody()
        if network_connection_type is not None:
            body.network_connection_type = network_connection_type
        url = self.ep(f'locations/{location_id}/privateNetworkConnect')
        super().put(url=url, params=params, data=body.json())
        return

    def read_list_of_routing_choices(self, org_id: str = None, route_group_name: str = None, trunk_name: str = None, order: str = None, **params) -> Generator[RouteIdentity, None, None]:
        """
        List all Routes for the organization.
        Trunk and Route Group qualify as Route. Trunks and Route Groups provide you the ability to configure Webex
        Calling to manage calls between Webex Calling hosted users and premises PBX users. This solution lets you
        configure users to use Cloud PSTN (CCP or Cisco PSTN) or Premises-based PSTN.
        Retrieving this list requires a full or read-only administrator auth token with a scope of
        spark-admin:telephony_config_read.

        :param org_id: List route identities for this organization.
        :type org_id: str
        :param route_group_name: Return the list of route identities matching the Route group name..
        :type route_group_name: str
        :param trunk_name: Return the list of route identities matching the Trunk name..
        :type trunk_name: str
        :param order: Order the route identities according to the designated fields. Available sort fields: routeName,
            routeType.
        :type order: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/read-the-list-of-routing-choices
        """
        if org_id is not None:
            params['orgId'] = org_id
        if route_group_name is not None:
            params['routeGroupName'] = route_group_name
        if trunk_name is not None:
            params['trunkName'] = trunk_name
        if order is not None:
            params['order'] = order
        url = self.ep('routeChoices')
        return self.session.follow_pagination(url=url, model=RouteIdentity, item_key='routeIdentities', params=params)

    def read_list_of_schedules(self, location_id: str, org_id: str = None, type_: str = None, name: str = None, **params) -> Generator[ListScheduleObject, None, None]:
        """
        List all schedules for the given location of the organization.
        A time schedule establishes a set of times during the day or holidays in the year in which a feature, for
        example auto attendants, can perform a specific action.
        Retrieving this list requires a full or read-only administrator auth token with a scope of
        spark-admin:telephony_config_read.

        :param location_id: Return the list of schedules for this location.
        :type location_id: str
        :param org_id: List schedules for this organization.
        :type org_id: str
        :param type_: Type of the schedule. * businessHours - Business hours schedule type. * holidays - Holidays
            schedule type.
        :type type_: str
        :param name: Only return schedules with the matching name.
        :type name: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/read-the-list-of-schedules
        """
        if org_id is not None:
            params['orgId'] = org_id
        if type_ is not None:
            params['type'] = type_
        if name is not None:
            params['name'] = name
        url = self.ep(f'locations/{location_id}/schedules')
        return self.session.follow_pagination(url=url, model=ListScheduleObject, item_key='schedules', params=params)

    def details_for_schedule(self, location_id: str, type_: str, schedule_id: str, org_id: str = None) -> GetDetailsForScheduleResponse:
        """
        Retrieve Schedule details.
        A time schedule establishes a set of times during the day or holidays in the year in which a feature, for
        example auto attendants, can perform a specific action.
        Retrieving schedule details requires a full or read-only administrator auth token with a scope of
        spark-admin:telephony_config_read.

        :param location_id: Retrieve schedule details in this location.
        :type location_id: str
        :param type_: Type of the schedule. * businessHours - Business hours schedule type. * holidays - Holidays
            schedule type.
        :type type_: str
        :param schedule_id: Retrieve the schedule with the matching ID.
        :type schedule_id: str
        :param org_id: Retrieve schedule details from this organization.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/get-details-for-a-schedule
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/schedules/{type}/{schedule_id}')
        data = super().get(url=url, params=params)
        return GetDetailsForScheduleResponse.parse_obj(data)

    def create_schedule(self, location_id: str, type_: Type54, name: str, org_id: str = None, events: ScheduleEventObject = None) -> str:
        """
        Create new Schedule for the given location.
        A time schedule establishes a set of times during the day or holidays in the year in which a feature, for
        example auto attendants, can perform a specific action.
        Creating a schedule requires a full administrator auth token with a scope of
        spark-admin:telephony_config_write.

        :param location_id: Create the schedule for this location.
        :type location_id: str
        :param type_: Type of the schedule.
        :type type_: Type54
        :param name: Unique name for the schedule.
        :type name: str
        :param org_id: Create the schedule for this organization.
        :type org_id: str
        :param events: List of schedule events.
        :type events: ScheduleEventObject

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/create-a-schedule
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = CreateScheduleBody()
        if type_ is not None:
            body.type_ = type_
        if name is not None:
            body.name = name
        if events is not None:
            body.events = events
        url = self.ep(f'locations/{location_id}/schedules')
        data = super().post(url=url, params=params, data=body.json())
        return data["id"]

    def update_schedule(self, location_id: str, type_: str, schedule_id: str, name: str, org_id: str = None, events: ModifyScheduleEventListObject = None) -> str:
        """
        Update the designated schedule.
        A time schedule establishes a set of times during the day or holidays in the year in which a feature, for
        example auto attendants, can perform a specific action.
        Updating a schedule requires a full administrator auth token with a scope of
        spark-admin:telephony_config_write.
        NOTE: The Schedule ID will change upon modification of the Schedule name.

        :param location_id: Location in which this schedule exists.
        :type location_id: str
        :param type_: Type of schedule. * businessHours - Business hours schedule type. * holidays - Holidays schedule
            type.
        :type type_: str
        :param schedule_id: Update schedule with the matching ID.
        :type schedule_id: str
        :param name: Unique name for the schedule.
        :type name: str
        :param org_id: Update schedule from this organization.
        :type org_id: str
        :param events: List of schedule events.
        :type events: ModifyScheduleEventListObject

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/update-a-schedule
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = UpdateScheduleBody()
        if name is not None:
            body.name = name
        if events is not None:
            body.events = events
        url = self.ep(f'locations/{location_id}/schedules/{type}/{schedule_id}')
        data = super().put(url=url, params=params, data=body.json())
        return data["id"]

    def delete_schedule(self, location_id: str, type_: str, schedule_id: str, org_id: str = None):
        """
        Delete the designated Schedule.
        A time schedule establishes a set of times during the day or holidays in the year in which a feature, for
        example auto attendants, can perform a specific action.
        Deleting a schedule requires a full administrator auth token with a scope of
        spark-admin:telephony_config_write.

        :param location_id: Location from which to delete a schedule.
        :type location_id: str
        :param type_: Type of the schedule. * businessHours - Business hours schedule type. * holidays - Holidays
            schedule type.
        :type type_: str
        :param schedule_id: Delete the schedule with the matching ID.
        :type schedule_id: str
        :param org_id: Delete the schedule from this organization.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/delete-a-schedule
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/schedules/{type}/{schedule_id}')
        super().delete(url=url, params=params)
        return

    def details_for_schedule_event(self, location_id: str, type_: str, schedule_id: str, event_id: str, org_id: str = None) -> GetScheduleEventObject:
        """
        Retrieve Schedule Event details.
        A time schedule establishes a set of times during the day or holidays in the year in which a feature, for
        example auto attendants, can perform a specific action.
        Retrieving a schedule event's details requires a full or read-only administrator auth token with a scope of
        spark-admin:telephony_config_read.

        :param location_id: Retrieve schedule event details in this location.
        :type location_id: str
        :param type_: Type of schedule. * businessHours - Business hours schedule type. * holidays - Holidays schedule
            type.
        :type type_: str
        :param schedule_id: Retrieve the schedule event with the matching schedule ID.
        :type schedule_id: str
        :param event_id: Retrieve the schedule event with the matching schedule event ID.
        :type event_id: str
        :param org_id: Retrieve schedule event details from this organization.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/get-details-for-a-schedule-event
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/schedules/{type}/{schedule_id}/events/{event_id}')
        data = super().get(url=url, params=params)
        return GetScheduleEventObject.parse_obj(data)

    def create_schedule_event(self, location_id: str, type_: str, schedule_id: str, name: str, start_date: str, end_date: str, org_id: str = None, start_time: str = None, end_time: str = None, all_day_enabled: bool = None, recurrence: RecurrenceObject1 = None) -> str:
        """
        Create new Event for the given location Schedule.
        A time schedule establishes a set of times during the day or holidays in the year in which a feature, for
        example auto attendants, can perform a specific action.
        Creating a schedule event requires a full administrator auth token with a scope of
        spark-admin:telephony_config_write.

        :param location_id: Create the schedule for this location.
        :type location_id: str
        :param type_: Type of schedule. * businessHours - Business hours schedule type. * holidays - Holidays schedule
            type.
        :type type_: str
        :param schedule_id: Create event for a given schedule ID.
        :type schedule_id: str
        :param name: Name for the event.
        :type name: str
        :param start_date: Start date of event.
        :type start_date: str
        :param end_date: End date of event.
        :type end_date: str
        :param org_id: Create the schedule for this organization.
        :type org_id: str
        :param start_time: Start time of event. Mandatory if the event is not all day.
        :type start_time: str
        :param end_time: End time of event. Mandatory if the event is not all day.
        :type end_time: str
        :param all_day_enabled: An indication of whether given event is an all-day event or not. Mandatory if the
            startTime and endTime are not defined.
        :type all_day_enabled: bool
        :param recurrence: Recurrence definition.
        :type recurrence: RecurrenceObject1

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/create-a-schedule-event
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = ScheduleEventObject()
        if name is not None:
            body.name = name
        if start_date is not None:
            body.start_date = start_date
        if end_date is not None:
            body.end_date = end_date
        if start_time is not None:
            body.start_time = start_time
        if end_time is not None:
            body.end_time = end_time
        if all_day_enabled is not None:
            body.all_day_enabled = all_day_enabled
        if recurrence is not None:
            body.recurrence = recurrence
        url = self.ep(f'locations/{location_id}/schedules/{type}/{schedule_id}/events')
        data = super().post(url=url, params=params, data=body.json())
        return data["id"]

    def update_schedule_event(self, location_id: str, type_: str, schedule_id: str, event_id: str, name: str, start_date: str, end_date: str, org_id: str = None, start_time: str = None, end_time: str = None, all_day_enabled: bool = None, recurrence: RecurrenceObject1 = None) -> str:
        """
        Update the designated Schedule Event.
        A time schedule establishes a set of times during the day or holidays in the year in which a feature, for
        example auto attendants, can perform a specific action.
        Updating a schedule event requires a full administrator auth token with a scope of
        spark-admin:telephony_config_write.
        NOTE: The schedule event ID will change upon modification of the schedule event name.

        :param location_id: Location in which this schedule event exists.
        :type location_id: str
        :param type_: Type of schedule. * businessHours - Business hours schedule type. * holidays - Holidays schedule
            type.
        :type type_: str
        :param schedule_id: Update schedule event with the matching schedule ID.
        :type schedule_id: str
        :param event_id: Update the schedule event with the matching schedule event ID.
        :type event_id: str
        :param name: Name for the event.
        :type name: str
        :param start_date: Start date of event.
        :type start_date: str
        :param end_date: End date of event.
        :type end_date: str
        :param org_id: Update schedule from this organization.
        :type org_id: str
        :param start_time: Start time of event. Mandatory if the event is not all day.
        :type start_time: str
        :param end_time: End time of event. Mandatory if the event is not all day.
        :type end_time: str
        :param all_day_enabled: An indication of whether given event is an all-day event or not. Mandatory if the
            startTime and endTime are not defined.
        :type all_day_enabled: bool
        :param recurrence: Recurrence definition.
        :type recurrence: RecurrenceObject1

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/update-a-schedule-event
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = ScheduleEventObject()
        if name is not None:
            body.name = name
        if start_date is not None:
            body.start_date = start_date
        if end_date is not None:
            body.end_date = end_date
        if start_time is not None:
            body.start_time = start_time
        if end_time is not None:
            body.end_time = end_time
        if all_day_enabled is not None:
            body.all_day_enabled = all_day_enabled
        if recurrence is not None:
            body.recurrence = recurrence
        url = self.ep(f'locations/{location_id}/schedules/{type}/{schedule_id}/events/{event_id}')
        data = super().put(url=url, params=params, data=body.json())
        return data["id"]

    def delete_schedule_event(self, location_id: str, type_: str, schedule_id: str, event_id: str, org_id: str = None):
        """
        Delete the designated Schedule Event.
        A time schedule establishes a set of times during the day or holidays in the year in which a feature, for
        example auto attendants, can perform a specific action.
        Deleting a schedule event requires a full administrator auth token with a scope of
        spark-admin:telephony_config_write.

        :param location_id: Location from which to delete a schedule.
        :type location_id: str
        :param type_: Type of schedule. * businessHours - Business hours schedule type. * holidays - Holidays schedule
            type.
        :type type_: str
        :param schedule_id: Delete the schedule with the matching ID.
        :type schedule_id: str
        :param event_id: Delete the schedule event with the matching schedule event ID.
        :type event_id: str
        :param org_id: Delete the schedule from this organization.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/delete-a-schedule-event
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/schedules/{type}/{schedule_id}/events/{event_id}')
        super().delete(url=url, params=params)
        return

    def read_list_of_virtual_lines(self, org_id: str = None, location_id: List[str] = None, id: List[str] = None, owner_name: List[str] = None, phone_number: List[str] = None, location_name: List[str] = None, order: List[str] = None, has_device_assigned: bool = None, has_extension_assigned: bool = None, has_dn_assigned: bool = None, **params) -> Generator[ListVirtualLineObject, None, None]:
        """
        List all Virtual Lines for the organization.
        Virtual line is a capability in Webex Calling that allows administrators to configure multiple lines to Webex
        Calling users.
        Retrieving this list requires a full or read-only administrator auth token with a scope of
        spark-admin:telephony_config_read.

        :param org_id: List virtual lines for this organization.
        :type org_id: str
        :param location_id: Return the list of virtual lines matching these location ids. Example for multiple values -
            ?locationId=locId1&locationId=locId2.
        :type location_id: List[str]
        :param id: Return the list of virtual lines matching these virtualLineIds. Example for multiple values -
            ?id=id1&id=id2.
        :type id: List[str]
        :param owner_name: Return the list of virtual lines matching these owner names. Example for multiple values -
            ?ownerName=name1&ownerName=name2.
        :type owner_name: List[str]
        :param phone_number: Return the list of virtual lines matching these phone numbers. Example for multiple values
            - ?phoneNumber=number1&phoneNumber=number2.
        :type phone_number: List[str]
        :param location_name: Return the list of virtual lines matching the location names. Example for multiple values
            - ?locationName=loc1&locationName=loc2.
        :type location_name: List[str]
        :param order: Return the list of virtual lines based on the order. Default sort will be in an Ascending order.
            Maximum 3 orders allowed at a time. Example for multiple values - ?order=order1&order=order2.
        :type order: List[str]
        :param has_device_assigned: If true, includes only virtual lines with devices assigned. When not explicitly
            specified, the default includes both virtual lines with devices assigned and not assigned.
        :type has_device_assigned: bool
        :param has_extension_assigned: If true, includes only virtual lines with an extension assigned. When not
            explicitly specified, the default includes both virtual lines with extension assigned and not assigned.
        :type has_extension_assigned: bool
        :param has_dn_assigned: If true, includes only virtual lines with an assigned directory number, also known as a
            Dn. When not explicitly specified, the default includes both virtual lines with a Dn assigned and not
            assigned.
        :type has_dn_assigned: bool

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/read-the-list-of-virtual-lines
        """
        if org_id is not None:
            params['orgId'] = org_id
        if location_id is not None:
            params['locationId'] = location_id
        if id is not None:
            params['id'] = id
        if owner_name is not None:
            params['ownerName'] = owner_name
        if phone_number is not None:
            params['phoneNumber'] = phone_number
        if location_name is not None:
            params['locationName'] = location_name
        if order is not None:
            params['order'] = order
        if has_device_assigned is not None:
            params['hasDeviceAssigned'] = str(has_device_assigned).lower()
        if has_extension_assigned is not None:
            params['hasExtensionAssigned'] = str(has_extension_assigned).lower()
        if has_dn_assigned is not None:
            params['hasDnAssigned'] = str(has_dn_assigned).lower()
        url = self.ep('virtualLines')
        return self.session.follow_pagination(url=url, model=ListVirtualLineObject, item_key='virtualLines', params=params)

    def voicemail_settings(self, org_id: str = None) -> GetVoicemailSettingsResponse:
        """
        Retrieve the organization's voicemail settings.
        Organizational voicemail settings determines what voicemail features a person can configure and automatic
        message expiration.
        Retrieving organization's voicemail settings requires a full, user or read-only administrator auth token with a
        scope of spark-admin:telephony_config_read.

        :param org_id: Retrieve voicemail settings for this organization.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/get-voicemail-settings
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep('voicemail/settings')
        data = super().get(url=url, params=params)
        return GetVoicemailSettingsResponse.parse_obj(data)

    def update_voicemail_settings(self, org_id: str = None, message_expiry_enabled: bool = None, number_of_days_for_message_expiry: int = None, strict_deletion_enabled: bool = None, voice_message_forwarding_enabled: bool = None):
        """
        Update the organization's voicemail settings.
        Organizational voicemail settings determines what voicemail features a person can configure and automatic
        message expiration.
        Updating an organization's voicemail settings requires a full administrator auth token with a scope of
        spark-admin:telephony_config_write.

        :param org_id: Update voicemail settings for this organization.
        :type org_id: str
        :param message_expiry_enabled: When enabled, you can set the deletion conditions for expired messages.
        :type message_expiry_enabled: bool
        :param number_of_days_for_message_expiry: Number of days after which messages expire.
        :type number_of_days_for_message_expiry: int
        :param strict_deletion_enabled: When enabled, all read and unread voicemail messages will be deleted based on
            the time frame you set. When disabled, all unread voicemail messages will be kept.
        :type strict_deletion_enabled: bool
        :param voice_message_forwarding_enabled: When enabled, people in the organization can configure the email
            forwarding of voicemails.
        :type voice_message_forwarding_enabled: bool

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/update-voicemail-settings
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = GetVoicemailSettingsResponse()
        if message_expiry_enabled is not None:
            body.message_expiry_enabled = message_expiry_enabled
        if number_of_days_for_message_expiry is not None:
            body.number_of_days_for_message_expiry = number_of_days_for_message_expiry
        if strict_deletion_enabled is not None:
            body.strict_deletion_enabled = strict_deletion_enabled
        if voice_message_forwarding_enabled is not None:
            body.voice_message_forwarding_enabled = voice_message_forwarding_enabled
        url = self.ep('voicemail/settings')
        super().put(url=url, params=params, data=body.json())
        return

    def voicemail_rules(self, org_id: str = None) -> GetVoicemailRulesResponse:
        """
        Retrieve the organization's voicemail rules.
        Organizational voicemail rules specify the default passcode requirements. They are provided for informational
        purposes only and cannot be modified.
        Retrieving the organization's voicemail rules requires a full, user or read-only administrator auth token with
        a scope of spark-admin:telephony_config_read.

        :param org_id: Retrieve voicemail rules for this organization.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/get-voicemail-rules
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep('voicemail/rules')
        data = super().get(url=url, params=params)
        return GetVoicemailRulesResponse.parse_obj(data)

    def update_voicemail_rules(self, org_id: str = None, default_voicemail_pin_enabled: bool = None, default_voicemail_pin: str = None, expire_passcode: ExpirePasscode = None, change_passcode: ExpirePasscode = None, block_previous_passcodes: BlockPreviousPasscodes = None):
        """
        Update the organization's default voicemail passcode and/or rules.
        Organizational voicemail rules specify the default passcode requirements.
        If you choose to set a default passcode for new people added to your organization, communicate to your people
        what that passcode is, and that it must be reset before they can access their voicemail. If this feature is not
        turned on, each new person must initially set their own passcode.
        Updating an organization's voicemail passcode and/or rules requires a full administrator auth token with a
        scope of spark-admin:telephony_config_write.

        :param org_id: Update voicemail rules for this organization.
        :type org_id: str
        :param default_voicemail_pin_enabled: Set to true to enable the default voicemail passcode.
        :type default_voicemail_pin_enabled: bool
        :param default_voicemail_pin: Default voicemail passcode.
        :type default_voicemail_pin: str
        :param expire_passcode: Settings for passcode expiry.
        :type expire_passcode: ExpirePasscode
        :param change_passcode: Settings for passcode changes.
        :type change_passcode: ExpirePasscode
        :param block_previous_passcodes: Settings for previous passcode usage.
        :type block_previous_passcodes: BlockPreviousPasscodes

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/update-voicemail-rules
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = UpdateVoicemailRulesBody()
        if default_voicemail_pin_enabled is not None:
            body.default_voicemail_pin_enabled = default_voicemail_pin_enabled
        if default_voicemail_pin is not None:
            body.default_voicemail_pin = default_voicemail_pin
        if expire_passcode is not None:
            body.expire_passcode = expire_passcode
        if change_passcode is not None:
            body.change_passcode = change_passcode
        if block_previous_passcodes is not None:
            body.block_previous_passcodes = block_previous_passcodes
        url = self.ep('voicemail/rules')
        super().put(url=url, params=params, data=body.json())
        return

    def location_voicemail(self, location_id: str, org_id: str = None) -> bool:
        """
        Retrieve voicemail settings for a specific location.
        Location voicemail settings allows you to enable voicemail transcription for a specific location.
        Retrieving a location's voicemail settings requires a full, user or read-only administrator auth token with a
        scope of spark-admin:telephony_config_read.

        :param location_id: Retrieve voicemail settings for this location.
        :type location_id: str
        :param org_id: Retrieve voicemail settings for this organization.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/get-location-voicemail
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/voicemail')
        data = super().get(url=url, params=params)
        return data["voicemailTranscriptionEnabled"]

    def update_location_voicemail(self, location_id: str, voicemail_transcription_enabled: bool, org_id: str = None):
        """
        Update the voicemail settings for a specific location.
        Location voicemail settings allows you to enable voicemail transcription for a specific location.
        Updating a location's voicemail settings requires a full administrator auth token with a scope of
        spark-admin:telephony_config_write.

        :param location_id: Update voicemail settings for this location.
        :type location_id: str
        :param voicemail_transcription_enabled: Set to true to enable voicemail transcription.
        :type voicemail_transcription_enabled: bool
        :param org_id: Update voicemail settings for this organization.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/update-location-voicemail
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = UpdateLocationVoicemailBody()
        if voicemail_transcription_enabled is not None:
            body.voicemail_transcription_enabled = voicemail_transcription_enabled
        url = self.ep(f'locations/{location_id}/voicemail')
        super().put(url=url, params=params, data=body.json())
        return

    def voice_portal(self, location_id: str, org_id: str = None) -> GetVoicePortalResponse:
        """
        Retrieve Voice portal information for the location.
        Voice portals provide an interactive voice response (IVR)
        system so administrators can manage auto attendant announcements.
        Retrieving voice portal information for an organization requires a full read-only administrator auth token with
        a scope of spark-admin:telephony_config_read.

        :param location_id: Location to which the voice portal belongs.
        :type location_id: str
        :param org_id: Organization to which the voice portal belongs.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/get-voiceportal
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/voicePortal')
        data = super().get(url=url, params=params)
        return GetVoicePortalResponse.parse_obj(data)

    def update_voice_portal(self, location_id: str, org_id: str = None, extension: str = None, name: str = None, language_code: str = None, phone_number: str = None, first_name: str = None, last_name: str = None, passcode: Passcode = None):
        """
        Update Voice portal information for the location.
        Voice portals provide an interactive voice response (IVR)
        system so administrators can manage auto attendant anouncements.
        Updating voice portal information for an organization and/or rules requires a full administrator auth token
        with a scope of spark-admin:telephony_config_write.

        :param location_id: Location to which the voice portal belongs.
        :type location_id: str
        :param org_id: Update voicemail rules for this organization.
        :type org_id: str
        :param extension: The extension for the call park extension.
        :type extension: str
        :param name: Unique name for the call park extension.
        :type name: str
        :param language_code: Language code for voicemail group audio announcement.
        :type language_code: str
        :param phone_number: Phone Number of incoming call.
        :type phone_number: str
        :param first_name: Caller ID First Name.
        :type first_name: str
        :param last_name: Caller ID Last Name.
        :type last_name: str
        :param passcode: Voice Portal Admin Passcode.
        :type passcode: Passcode

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/update-voiceportal
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = UpdateVoicePortalBody()
        if extension is not None:
            body.extension = extension
        if name is not None:
            body.name = name
        if language_code is not None:
            body.language_code = language_code
        if phone_number is not None:
            body.phone_number = phone_number
        if first_name is not None:
            body.first_name = first_name
        if last_name is not None:
            body.last_name = last_name
        if passcode is not None:
            body.passcode = passcode
        url = self.ep(f'locations/{location_id}/voicePortal')
        super().put(url=url, params=params, data=body.json())
        return

    def voice_portal_passcode_rule(self, location_id: str, org_id: str = None) -> GetVoicePortalPasscodeRuleResponse:
        """
        Retrieve the voice portal passcode rule for a location.
        Voice portals provide an interactive voice response (IVR) system so administrators can manage auto attendant
        anouncements
        Retrieving the voice portal passcode rule requires a full read-only administrator auth token with a scope of
        spark-admin:telephony_config_read.

        :param location_id: Retrieve voice portal passcode rules for this location.
        :type location_id: str
        :param org_id: Retrieve voice portal passcode rules for this organization.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/get-voiceportal-passcode-rule
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/voicePortal/passcodeRules')
        data = super().get(url=url, params=params)
        return GetVoicePortalPasscodeRuleResponse.parse_obj(data)

    def music_on_hold(self, location_id: str, org_id: str = None) -> GetMusicOnHoldResponse:
        """
        Retrieve the location's music on hold settings.
        Location music on hold settings allows you to play music when a call is placed on hold or parked.
        Retrieving a location's music on hold settings requires a full, user or read-only administrator auth token with
        a scope of spark-admin:telephony_config_read.

        :param location_id: Retrieve music on hold settings for this location.
        :type location_id: str
        :param org_id: Retrieve music on hold settings for this organization.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/get-music-on-hold
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/musicOnHold')
        data = super().get(url=url, params=params)
        return GetMusicOnHoldResponse.parse_obj(data)

    def update_music_on_hold(self, location_id: str, org_id: str = None, call_hold_enabled: bool = None, call_park_enabled: bool = None, greeting: Greeting29 = None):
        """
        Update the location's music on hold settings.
        Location music on hold settings allows you to play music when a call is placed on hold or parked.
        Updating a location's music on hold settings requires a full administrator auth token with a scope of
        spark-admin:telephony_config_write.

        :param location_id: Update music on hold settings for this location.
        :type location_id: str
        :param org_id: Update music on hold settings for this organization.
        :type org_id: str
        :param call_hold_enabled: If enabled, music will be played when call is placed on hold.
        :type call_hold_enabled: bool
        :param call_park_enabled: If enabled, music will be played when call is parked.
        :type call_park_enabled: bool
        :param greeting: Greeting type for the location.
        :type greeting: Greeting29

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/update-music-on-hold
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = GetMusicOnHoldResponse()
        if call_hold_enabled is not None:
            body.call_hold_enabled = call_hold_enabled
        if call_park_enabled is not None:
            body.call_park_enabled = call_park_enabled
        if greeting is not None:
            body.greeting = greeting
        url = self.ep(f'locations/{location_id}/musicOnHold')
        super().put(url=url, params=params, data=body.json())
        return

    def list_voicemail_group(self, location_id: str = None, org_id: str = None, name: str = None, phone_number: str = None, **params) -> Generator[GetVoicemailGroupObject, None, None]:
        """
        List the voicemail group information for the organization.
        You can create a shared voicemail box and inbound FAX box to
        assign to users or call routing features like an auto attendant, call queue, or hunt group.
        Retrieving a voicemail group for the organization requires a full read-only administrator auth token with a
        scope of spark-admin:telephony_config_read.

        :param location_id: Location to which the voicemail group belongs.
        :type location_id: str
        :param org_id: Organization to which the voicemail group belongs.
        :type org_id: str
        :param name: Search (Contains) based on voicemail group name
        :type name: str
        :param phone_number: Search (Contains) based on number or extension
        :type phone_number: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/list-voicemailgroup
        """
        if location_id is not None:
            params['locationId'] = location_id
        if org_id is not None:
            params['orgId'] = org_id
        if name is not None:
            params['name'] = name
        if phone_number is not None:
            params['phoneNumber'] = phone_number
        url = self.ep('voicemailGroups')
        return self.session.follow_pagination(url=url, model=GetVoicemailGroupObject, item_key='voicemailGroups', params=params)

    def location_voicemail_group(self, location_id: str, voicemail_group_id: str, org_id: str = None) -> GetLocationVoicemailGroupResponse:
        """
        Retrieve voicemail group details for a location.
        Manage your voicemail group settings for a specific location, like when you want your voicemail to be active,
        message storage settings, and how you would like to be notified of new voicemail messages.
        Retrieving voicemail group details requires a full, user or read-only administrator auth token with a scope of
        spark-admin:telephony_config_read.

        :param location_id: Retrieve voicemail group details for this location.
        :type location_id: str
        :param voicemail_group_id: Retrieve voicemail group details for this voicemail group ID.
        :type voicemail_group_id: str
        :param org_id: Retrieve voicemail group details for a customer location.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/get-location-voicemail-group
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/voicemailGroups/{voicemail_group_id}')
        data = super().get(url=url, params=params)
        return GetLocationVoicemailGroupResponse.parse_obj(data)

    def modify_location_voicemail_group(self, location_id: str, voicemail_group_id: str, org_id: str = None, enabled: bool = None, phone_number: str = None, extension: int = None, name: str = None, first_name: str = None, last_name: str = None, passcode: int = None, language_code: str = None, greeting: Greeting = None, greeting_description: str = None, message_storage: MessageStorage = None, notifications: NewNumber = None, fax_message: FaxMessage = None, transfer_to_number: NewNumber = None, email_copy_of_message: EmailCopyOfMessage = None):
        """
        Modifies the voicemail group location details for a particular location for a customer.
        Manage your voicemail settings, like when you want your voicemail to be active, message storage settings, and
        how you would like to be notified of new voicemail messages.
        Modifying the voicemail group location details requires a full, user administrator auth token with a scope of
        spark-admin:telephony_config_write.

        :param location_id: Modifies the voicemail group details for this location.
        :type location_id: str
        :param voicemail_group_id: Modifies the voicemail group details for this voicemail group ID.
        :type voicemail_group_id: str
        :param org_id: Modifies the voicemail group details for a customer location.
        :type org_id: str
        :param enabled: Enable/disable fax messaging.
        :type enabled: bool
        :param phone_number: Phone number to receive fax messages.
        :type phone_number: str
        :param extension: Extension to receive fax messages.
        :type extension: int
        :param name: Set the name of the voicemail group.
        :type name: str
        :param first_name: Set the voicemail group caller ID first name.
        :type first_name: str
        :param last_name: Set the voicemail group called ID last name.
        :type last_name: str
        :param passcode: Set passcode to access voicemail group when calling.
        :type passcode: int
        :param language_code: Language code for the voicemail group audio announcement.
        :type language_code: str
        :param greeting: Voicemail group greeting type.
        :type greeting: Greeting
        :param greeting_description: CUSTOM greeting for previously uploaded.
        :type greeting_description: str
        :param message_storage: Message storage information
        :type message_storage: MessageStorage
        :param notifications: Message notifications
        :type notifications: NewNumber
        :param fax_message: Fax message receive settings
        :type fax_message: FaxMessage
        :param transfer_to_number: Transfer message information
        :type transfer_to_number: NewNumber
        :param email_copy_of_message: Message copy information
        :type email_copy_of_message: EmailCopyOfMessage

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/modify-location-voicemail-group
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = ModifyLocationVoicemailGroupBody()
        if enabled is not None:
            body.enabled = enabled
        if phone_number is not None:
            body.phone_number = phone_number
        if extension is not None:
            body.extension = extension
        if name is not None:
            body.name = name
        if first_name is not None:
            body.first_name = first_name
        if last_name is not None:
            body.last_name = last_name
        if passcode is not None:
            body.passcode = passcode
        if language_code is not None:
            body.language_code = language_code
        if greeting is not None:
            body.greeting = greeting
        if greeting_description is not None:
            body.greeting_description = greeting_description
        if message_storage is not None:
            body.message_storage = message_storage
        if notifications is not None:
            body.notifications = notifications
        if fax_message is not None:
            body.fax_message = fax_message
        if transfer_to_number is not None:
            body.transfer_to_number = transfer_to_number
        if email_copy_of_message is not None:
            body.email_copy_of_message = email_copy_of_message
        url = self.ep(f'locations/{location_id}/voicemailGroups/{voicemail_group_id}')
        super().put(url=url, params=params, data=body.json())
        return

    def createnew_voicemail_group_for_location(self, location_id: str, passcode: int, language_code: str, message_storage: MessageStorage, notifications: NewNumber, fax_message: FaxMessage, transfer_to_number: NewNumber, email_copy_of_message: EmailCopyOfMessage, org_id: str = None, extension: str = None, name: str = None, phone_number: str = None, first_name: str = None, last_name: str = None) -> str:
        """
        Create a new voicemail group for the given location for a customer.
        A voicemail group can be created for given location for a customer.
        Creating a voicemail group for the given location requires a full or user administrator auth token with a scope
        of spark-admin:telephony_config_write.

        :param location_id: Create a new voice mail group for this location.
        :type location_id: str
        :param passcode: Set passcode to access voicemail group when calling.
        :type passcode: int
        :param language_code: Language code for voicemail group audio announcement.
        :type language_code: str
        :param message_storage: Message storage information
        :type message_storage: MessageStorage
        :param notifications: Message notifications
        :type notifications: NewNumber
        :param fax_message: Fax message information
        :type fax_message: FaxMessage
        :param transfer_to_number: Transfer message information
        :type transfer_to_number: NewNumber
        :param email_copy_of_message: Message copy information
        :type email_copy_of_message: EmailCopyOfMessage
        :param org_id: Create a new voice mail group for this organization.
        :type org_id: str
        :param extension: The extension for the call park extension.
        :type extension: str
        :param name: Unique name for the call park extension.
        :type name: str
        :param phone_number: Set voicemail group phone number for this particular location.
        :type phone_number: str
        :param first_name: Set voicemail group caller ID first name.
        :type first_name: str
        :param last_name: Set voicemail group called ID last name.
        :type last_name: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/create-a-new-voicemail-group-for-a-location
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = CreatenewVoicemailGroupForLocationBody()
        if passcode is not None:
            body.passcode = passcode
        if language_code is not None:
            body.language_code = language_code
        if message_storage is not None:
            body.message_storage = message_storage
        if notifications is not None:
            body.notifications = notifications
        if fax_message is not None:
            body.fax_message = fax_message
        if transfer_to_number is not None:
            body.transfer_to_number = transfer_to_number
        if email_copy_of_message is not None:
            body.email_copy_of_message = email_copy_of_message
        if extension is not None:
            body.extension = extension
        if name is not None:
            body.name = name
        if phone_number is not None:
            body.phone_number = phone_number
        if first_name is not None:
            body.first_name = first_name
        if last_name is not None:
            body.last_name = last_name
        url = self.ep(f'locations/{location_id}/voicemailGroups')
        data = super().post(url=url, params=params, data=body.json())
        return data["id"]

    def delete_voicemail_group_for_location(self, location_id: str, voicemail_group_id: str, org_id: str = None):
        """
        Delete the designated voicemail group.
        Deleting a voicemail group requires a full administrator auth token with a scope of
        spark-admin:telephony_config_write.

        :param location_id: Location from which to delete a voicemail group.
        :type location_id: str
        :param voicemail_group_id: Delete the voicemail group with the matching ID.
        :type voicemail_group_id: str
        :param org_id: Delete the voicemail group from this organization.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/delete-a-voicemail-group-for-a-location
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/voicemailGroups/{voicemail_group_id}')
        super().delete(url=url, params=params)
        return

    def read_list_of_uc_manager_profiles(self, org_id: str = None) -> list[Role]:
        """
        List all calling UC Manager Profiles for the organization.
        UC Manager Profiles are applicable if your organization uses Jabber in Team Messaging mode or Calling in Webex
        (Unified CM).
        The UC Manager Profile has an organization-wide default and may be overridden for individual persons, although
        currently only setting at a user level is supported by Webex APIs.
        Retrieving this list requires a full or read-only administrator auth token with a scope of
        spark-admin:people_read as this API is designed to be used in conjunction with calling behavior at the user
        level.

        :param org_id: List manager profiles in this organization.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/read-the-list-of-uc-manager-profiles
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep('callingProfiles')
        data = super().get(url=url, params=params)
        return parse_obj_as(list[Role], data["callingProfiles"])

    def read_list_of_dial_patterns(self, dial_plan_id: str, org_id: str = None, dial_pattern: str = None, order: str = None, **params) -> Generator[str, None, None]:
        """
        List all Dial Patterns for the organization.
        Dial plans route calls to on-premises destinations by use of trunks or route groups.
        They are configured globally for an enterprise and apply to all users, regardless of location.
        A dial plan also specifies the routing choice (trunk or route group) for calls that match any of its dial
        patterns.
        Specific dial patterns can be defined as part of your dial plan.
        Retrieving this list requires a full or read-only administrator auth token with a scope of
        spark-admin:telephony_config_read.

        :param dial_plan_id: ID of the dial plan.
        :type dial_plan_id: str
        :param org_id: ID of the organization to which the dial patterns belong.
        :type org_id: str
        :param dial_pattern: An enterprise dial pattern is represented by a sequence of digits (1-9), followed by
            optional wildcard characters. Valid wildcard characters are ! (matches any sequence of digits) and X
            (matches a single digit, 0-9). The ! wildcard can only occur once at the end and only in an E.164 pattern
        :type dial_pattern: str
        :param order: Order the dial patterns according to the designated fields. Available sort fields: dialPattern.
        :type order: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/read-the-list-of-dial-patterns
        """
        if org_id is not None:
            params['orgId'] = org_id
        if dial_pattern is not None:
            params['dialPattern'] = dial_pattern
        if order is not None:
            params['order'] = order
        url = self.ep(f'premisePstn/dialPlans/{dial_plan_id}/dialPatterns')
        return self.session.follow_pagination(url=url, model=str, item_key='dialPatterns', params=params)

    def modify_dial_patterns(self, dial_plan_id: str, org_id: str = None, dial_patterns: DialPattern = None, delete_all_dial_patterns: bool = None):
        """
        Modify dial patterns for the Dial Plan.
        Dial plans route calls to on-premises destinations by use of trunks or route groups.
        They are configured globally for an enterprise and apply to all users, regardless of location.
        A dial plan also specifies the routing choice (trunk or route group) for calls that match any of its dial
        patterns.
        Specific dial patterns can be defined as part of your dial plan.
        Modifying a dial pattern requires a full administrator auth token with a scope of
        spark-admin:telephony_config_write.

        :param dial_plan_id: ID of the dial plan being modified.
        :type dial_plan_id: str
        :param org_id: Organization to which dial plan belongs.
        :type org_id: str
        :param dial_patterns: Array of dial patterns to add or delete. Dial Pattern that is not present in the request
            is not modified.
        :type dial_patterns: DialPattern
        :param delete_all_dial_patterns: Delete all the dial patterns for a dial plan.
        :type delete_all_dial_patterns: bool

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/modify-dial-patterns
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = ModifyDialPatternsBody()
        if dial_patterns is not None:
            body.dial_patterns = dial_patterns
        if delete_all_dial_patterns is not None:
            body.delete_all_dial_patterns = delete_all_dial_patterns
        url = self.ep(f'premisePstn/dialPlans/{dial_plan_id}/dialPatterns')
        super().put(url=url, params=params, data=body.json())
        return

    def validate_dial_pattern(self, dial_patterns: List[str], org_id: str = None) -> ValidateDialPatternResponse:
        """
        Validate a Dial Pattern.
        Dial plans route calls to on-premises destinations by use of trunks or route groups.
        They are configured globally for an enterprise and apply to all users, regardless of location.
        A dial plan also specifies the routing choice (trunk or route group) for calls that match any of its dial
        patterns.
        Specific dial patterns can be defined as part of your dial plan.
        Validating a dial pattern requires a full administrator auth token with a scope of
        spark-admin:telephony_config_write.

        :param dial_patterns: Array of dial patterns. Possible values: +5555,7777
        :type dial_patterns: List[str]
        :param org_id: Organization to which dial plan belongs.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/validate-a-dial-pattern
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = ValidateDialPatternBody()
        if dial_patterns is not None:
            body.dial_patterns = dial_patterns
        url = self.ep('premisePstn/actions/validateDialPatterns/invoke')
        data = super().post(url=url, params=params, data=body.json())
        return ValidateDialPatternResponse.parse_obj(data)

    def read_list_of_dial_plans(self, org_id: str = None, dial_plan_name: str = None, route_group_name: str = None, trunk_name: str = None, order: str = None, **params) -> Generator[DialPlan, None, None]:
        """
        List all Dial Plans for the organization.
        Dial plans route calls to on-premises destinations by use of the trunks or route groups with which the dial
        plan is associated. Multiple dial patterns can be defined as part of your dial plan. Dial plans are configured
        globally for an enterprise and apply to all users, regardless of location.
        Retrieving this list requires a full or read-only administrator auth token with a scope of
        spark-admin:telephony_config_read.

        :param org_id: List dial plans for this organization.
        :type org_id: str
        :param dial_plan_name: Return the list of dial plans matching the dial plan name.
        :type dial_plan_name: str
        :param route_group_name: Return the list of dial plans matching the Route group name..
        :type route_group_name: str
        :param trunk_name: Return the list of dial plans matching the Trunk name..
        :type trunk_name: str
        :param order: Order the dial plans according to the designated fields. Available sort fields: name, routeName,
            routeType. Sort order is ascending by default
        :type order: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/read-the-list-of-dial-plans
        """
        if org_id is not None:
            params['orgId'] = org_id
        if dial_plan_name is not None:
            params['dialPlanName'] = dial_plan_name
        if route_group_name is not None:
            params['routeGroupName'] = route_group_name
        if trunk_name is not None:
            params['trunkName'] = trunk_name
        if order is not None:
            params['order'] = order
        url = self.ep('premisePstn/dialPlans')
        return self.session.follow_pagination(url=url, model=DialPlan, item_key='dialPlans', params=params)

    def create_dial_plan(self, name: str, route_id: str, route_type: RouteType, org_id: str = None, dial_patterns: List[str] = None) -> str:
        """
        Create a Dial Plan for the organization.
        Dial plans route calls to on-premises destinations by use of trunks or route groups.
        They are configured globally for an enterprise and apply to all users, regardless of location.
        A dial plan also specifies the routing choice (trunk or route group) for calls that match any of its dial
        patterns.
        Specific dial patterns can be defined as part of your dial plan.
        Creating a dial plan requires a full administrator auth token with a scope of
        spark-admin:telephony_config_write.

        :param name: A unique name for the dial plan.
        :type name: str
        :param route_id: ID of route type associated with the dial plan.
        :type route_id: str
        :param route_type: Route Type associated with the dial plan.
        :type route_type: RouteType
        :param org_id: Organization to which dial plan belongs.
        :type org_id: str
        :param dial_patterns: An Array of dial patterns. Possible values: +5555,+5556
        :type dial_patterns: List[str]

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/create-a-dial-plan
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = CreateDialPlanBody()
        if name is not None:
            body.name = name
        if route_id is not None:
            body.route_id = route_id
        if route_type is not None:
            body.route_type = route_type
        if dial_patterns is not None:
            body.dial_patterns = dial_patterns
        url = self.ep('premisePstn/dialPlans')
        data = super().post(url=url, params=params, data=body.json())
        return data["id"]

    def dial_plan(self, dial_plan_id: str, org_id: str = None) -> GetDialPlanResponse:
        """
        Get a Dial Plan for the organization.
        Dial plans route calls to on-premises destinations by use of trunks or route groups.
        They are configured globally for an enterprise and apply to all users, regardless of location.
        A dial plan also specifies the routing choice (trunk or route group) for calls that match any of its dial
        patterns.
        Specific dial patterns can be defined as part of your dial plan.
        Retrieving a dial plan requires a full or read-only administrator auth token with a scope of
        spark-admin:telephony_config_read.

        :param dial_plan_id: ID of the dial plan.
        :type dial_plan_id: str
        :param org_id: Organization to which dial plan belongs.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/get-a-dial-plan
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'premisePstn/dialPlans/{dial_plan_id}')
        data = super().get(url=url, params=params)
        return GetDialPlanResponse.parse_obj(data)

    def modify_dial_plan(self, dial_plan_id: str, name: str, route_id: str, route_type: RouteType, org_id: str = None):
        """
        Modify a Dial Plan for the organization.
        Dial plans route calls to on-premises destinations by use of trunks or route groups.
        They are configured globally for an enterprise and apply to all users, regardless of location.
        A dial plan also specifies the routing choice (trunk or route group) for calls that match any of its dial
        patterns.
        Specific dial patterns can be defined as part of your dial plan.
        Modifying a dial plan requires a full administrator auth token with a scope of
        spark-admin:telephony_config_write.

        :param dial_plan_id: ID of the dial plan being modified.
        :type dial_plan_id: str
        :param name: A unique name for the dial plan.
        :type name: str
        :param route_id: ID of route type associated with the dial plan.
        :type route_id: str
        :param route_type: Route Type associated with the dial plan.
        :type route_type: RouteType
        :param org_id: Organization to which dial plan belongs.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/modify-a-dial-plan
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = ModifyDialPlanBody()
        if name is not None:
            body.name = name
        if route_id is not None:
            body.route_id = route_id
        if route_type is not None:
            body.route_type = route_type
        url = self.ep(f'premisePstn/dialPlans/{dial_plan_id}')
        super().put(url=url, params=params, data=body.json())
        return

    def delete_dial_plan(self, dial_plan_id: str, org_id: str = None):
        """
        Delete a Dial Plan for the organization.
        Dial plans route calls to on-premises destinations by use of trunks or route groups.
        They are configured globally for an enterprise and apply to all users, regardless of location.
        A dial plan also specifies the routing choice (trunk or route group) for calls that match any of its dial
        patterns.
        Specific dial patterns can be defined as part of your dial plan.
        Deleting a dial plan requires a full administrator auth token with a scope of
        spark-admin:telephony_config_write.

        :param dial_plan_id: ID of the dial plan.
        :type dial_plan_id: str
        :param org_id: Organization to which dial plan belongs.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/delete-a-dial-plan
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'premisePstn/dialPlans/{dial_plan_id}')
        super().delete(url=url, params=params)
        return

    def validate_local_gateway_fqdn_and_domain_for_trunk(self, org_id: str = None, address: str = None, domain: str = None, port: int = None):
        """
        Validate Local Gateway FQDN and Domain for the organization trunks.
        A Trunk is a connection between Webex Calling and the premises, which terminates on the premises with a local
        gateway or other supported device.
        The trunk can be assigned to a Route Group - a group of trunks that allow Webex Calling to distribute calls
        over multiple trunks or to provide redundancy.
        Validating Local Gateway FQDN and Domain requires a full administrator auth token with a scope of
        spark-admin:telephony_config_write.

        :param org_id: Organization to which trunk types belongs.
        :type org_id: str
        :param address: FQDN or SRV address of the trunk.
        :type address: str
        :param domain: Domain name of the trunk.
        :type domain: str
        :param port: FQDN port of the trunk.
        :type port: int

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/validate-local-gateway-fqdn-and-domain-for-a-trunk
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = ValidateLocalGatewayFQDNAndDomainForTrunkBody()
        if address is not None:
            body.address = address
        if domain is not None:
            body.domain = domain
        if port is not None:
            body.port = port
        url = self.ep('premisePstn/trunks/actions/fqdnValidation/invoke')
        super().post(url=url, params=params, data=body.json())
        return

    def read_list_of_trunks(self, org_id: str = None, name: List[str] = None, location_name: List[str] = None, trunk_type: str = None, order: str = None, **params) -> Generator[Trunk, None, None]:
        """
        List all Trunks for the organization.
        A Trunk is a connection between Webex Calling and the premises, which terminates on the premises with a local
        gateway or other supported device.
        The trunk can be assigned to a Route Group - a group of trunks that allow Webex Calling to distribute calls
        over multiple trunks or to provide redundancy.
        Retrieving this list requires a full or read-only administrator auth token with a scope of
        spark-admin:telephony_config_read.

        :param org_id: List trunks for this organization.
        :type org_id: str
        :param name: Return the list of trunks matching the local gateway names.
        :type name: List[str]
        :param location_name: Return the list of trunks matching the location names.
        :type location_name: List[str]
        :param trunk_type: Return the list of trunks matching the trunk type.
        :type trunk_type: str
        :param order: Order the trunks according to the designated fields. Available sort fields: name, locationName.
            Sort order is ascending by default
        :type order: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/read-the-list-of-trunks
        """
        if org_id is not None:
            params['orgId'] = org_id
        if name is not None:
            params['name'] = name
        if location_name is not None:
            params['locationName'] = location_name
        if trunk_type is not None:
            params['trunkType'] = trunk_type
        if order is not None:
            params['order'] = order
        url = self.ep('premisePstn/trunks')
        return self.session.follow_pagination(url=url, model=Trunk, item_key='trunks', params=params)

    def create_trunk(self, name: str, password: str, location_id: str, trunk_type: TrunkType, org_id: str = None, dual_identity_support_enabled: bool = None, max_concurrent_calls: int = None, device_type: str = None, address: str = None, domain: str = None, port: int = None) -> str:
        """
        Create a Trunk for the organization.
        A Trunk is a connection between Webex Calling and the premises, which terminates on the premises with a local
        gateway or other supported device.
        The trunk can be assigned to a Route Group which is a group of trunks that allow Webex Calling to distribute
        calls over multiple trunks or to provide redundancy.
        Creating a trunk requires a full administrator auth token with a scope of spark-admin:telephony_config_write.

        :param name: A unique name for the dial plan.
        :type name: str
        :param password: A password to use on the trunk.
        :type password: str
        :param location_id: ID of location associated with the trunk.
        :type location_id: str
        :param trunk_type: Trunk Type associated with the trunk.
        :type trunk_type: TrunkType
        :param org_id: Organization to which trunk belongs.
        :type org_id: str
        :param dual_identity_support_enabled: Determines the behavior of the From and PAI headers on outbound calls.
        :type dual_identity_support_enabled: bool
        :param max_concurrent_calls: Max Concurrent call. Required to create a static certificate-based trunk.
        :type max_concurrent_calls: int
        :param device_type: Device type assosiated with trunk.
        :type device_type: str
        :param address: FQDN or SRV address. Required to create a static certificate-based trunk.
        :type address: str
        :param domain: Domain name. Required to create a static certificate based trunk.
        :type domain: str
        :param port: FQDN port. Required to create a static certificate-based trunk.
        :type port: int

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/create-a-trunk
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = CreateTrunkBody()
        if name is not None:
            body.name = name
        if password is not None:
            body.password = password
        if location_id is not None:
            body.location_id = location_id
        if trunk_type is not None:
            body.trunk_type = trunk_type
        if dual_identity_support_enabled is not None:
            body.dual_identity_support_enabled = dual_identity_support_enabled
        if max_concurrent_calls is not None:
            body.max_concurrent_calls = max_concurrent_calls
        if device_type is not None:
            body.device_type = device_type
        if address is not None:
            body.address = address
        if domain is not None:
            body.domain = domain
        if port is not None:
            body.port = port
        url = self.ep('premisePstn/trunks')
        data = super().post(url=url, params=params, data=body.json())
        return data["id"]

    def trunk(self, trunk_id: str, org_id: str = None) -> GetTrunkResponse:
        """
        Get a Trunk for the organization.
        A Trunk is a connection between Webex Calling and the premises, which terminates on the premises with a local
        gateway or other supported device.
        The trunk can be assigned to a Route Group - a group of trunks that allow Webex Calling to distribute calls
        over multiple trunks or to provide redundancy.
        Retrieving a trunk requires a full or read-only administrator auth token with a scope of
        spark-admin:telephony_config_read.

        :param trunk_id: ID of the trunk.
        :type trunk_id: str
        :param org_id: Organization to which trunk belongs.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/get-a-trunk
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'premisePstn/trunks/{trunk_id}')
        data = super().get(url=url, params=params)
        return GetTrunkResponse.parse_obj(data)

    def modify_trunk(self, trunk_id: str, name: str, password: str, org_id: str = None, dual_identity_support_enabled: bool = None, max_concurrent_calls: int = None):
        """
        Modify a Trunk for the organization.
        A Trunk is a connection between Webex Calling and the premises, which terminates on the premises with a local
        gateway or other supported device.
        The trunk can be assigned to a Route Group - a group of trunks that allow Webex Calling to distribute calls
        over multiple trunks or to provide redundancy.
        Modifying a trunk requires a full administrator auth token with a scope of spark-admin:telephony_config_write.

        :param trunk_id: ID of the trunk being modified.
        :type trunk_id: str
        :param name: A unique name for the dial plan.
        :type name: str
        :param password: A password to use on the trunk.
        :type password: str
        :param org_id: Organization to which trunk belongs.
        :type org_id: str
        :param dual_identity_support_enabled: Determines the behavior of the From and PAI headers on outbound calls.
        :type dual_identity_support_enabled: bool
        :param max_concurrent_calls: Max Concurrent call. Required to create a static certificate-based trunk.
        :type max_concurrent_calls: int

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/modify-a-trunk
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = ModifyTrunkBody()
        if name is not None:
            body.name = name
        if password is not None:
            body.password = password
        if dual_identity_support_enabled is not None:
            body.dual_identity_support_enabled = dual_identity_support_enabled
        if max_concurrent_calls is not None:
            body.max_concurrent_calls = max_concurrent_calls
        url = self.ep(f'premisePstn/trunks/{trunk_id}')
        super().put(url=url, params=params, data=body.json())
        return

    def delete_trunk(self, trunk_id: str, org_id: str = None):
        """
        Delete a Trunk for the organization.
        A Trunk is a connection between Webex Calling and the premises, which terminates on the premises with a local
        gateway or other supported device.
        The trunk can be assigned to a Route Group - a group of trunks that allow Webex Calling to distribute calls
        over multiple trunks or to provide redundancy.
        Deleting a trunk requires a full administrator auth token with a scope of spark-admin:telephony_config_write.

        :param trunk_id: ID of the trunk.
        :type trunk_id: str
        :param org_id: Organization to which trunk belongs.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/delete-a-trunk
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'premisePstn/trunks/{trunk_id}')
        super().delete(url=url, params=params)
        return

    def read_list_of_trunk_types(self, org_id: str = None) -> list[TrunkTypeWithDeviceType]:
        """
        List all Trunk Types with Device Types for the organization.
        A Trunk is a connection between Webex Calling and the premises, which terminates on the premises with a local
        gateway or other supported device.
        The trunk can be assigned to a Route Group which is a group of trunks that allow Webex Calling to distribute
        calls over multiple trunks or to provide redundancy. Trunk Types are Registering or Certificate Based and are
        configured in Call Manager.
        Retrieving trunk types requires a full or read-only administrator auth token with a scope of
        spark-admin:telephony_config_read.

        :param org_id: Organization to which the trunk types belong.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/read-the-list-of-trunk-types
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep('premisePstn/trunks/trunkTypes')
        data = super().get(url=url, params=params)
        return parse_obj_as(list[TrunkTypeWithDeviceType], data["trunkTypes"])

    def read_list_of_routing_groups(self, org_id: str = None, name: str = None, order: str = None, **params) -> Generator[RouteGroup, None, None]:
        """
        List all Route Groups for an organization. A Route Group is a group of trunks that allows further scale and
        redundancy with the connection to the premises.
        Retrieving this route group list requires a full or read-only administrator auth token with a scope of
        spark-admin:telephony_config_read.

        :param org_id: List route groups for this organization.
        :type org_id: str
        :param name: Return the list of route groups matching the Route group name..
        :type name: str
        :param order: Order the route groups according to designated fields. Available sort orders are asc and desc.
        :type order: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/read-the-list-of-routing-groups
        """
        if org_id is not None:
            params['orgId'] = org_id
        if name is not None:
            params['name'] = name
        if order is not None:
            params['order'] = order
        url = self.ep('premisePstn/routeGroups')
        return self.session.follow_pagination(url=url, model=RouteGroup, item_key='routeGroups', params=params)

    def create_route_group_for_organization(self, name: str, local_gateways: LocalGateways, org_id: str = None) -> str:
        """
        Creates a Route Group for the organization.
        A Route Group is a collection of trunks that allows further scale and redundancy with the connection to the
        premises. Route groups can include up to 10 trunks from different locations.
        Creating a Route Group requires a full administrator auth token with a scope of
        spark-admin:telephony_config_write.

        :param name: A unique name for the Route Group.
        :type name: str
        :param local_gateways: Local Gateways that are part of this Route Group.
        :type local_gateways: LocalGateways
        :param org_id: Organization to which the Route Group belongs.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/create-route-group-for-a-organization
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = CreateRouteGroupForOrganizationBody()
        if name is not None:
            body.name = name
        if local_gateways is not None:
            body.local_gateways = local_gateways
        url = self.ep('premisePstn/routeGroups')
        data = super().post(url=url, params=params, data=body.json())
        return data["id"]

    def read_route_group_for_organization(self, route_group_id: str, org_id: str = None) -> ReadRouteGroupForOrganizationResponse:
        """
        Reads a Route Group for the organization based on id.
        A Route Group is a collection of trunks that allows further scale and redundancy with the connection to the
        premises. Route groups can include up to 10 trunks from different locations.
        Reading a Route Group requires a full or read-only administrator auth token with a scope of
        spark-admin:telephony_config_read.

        :param route_group_id: Route Group for which details are being requested.
        :type route_group_id: str
        :param org_id: Organization of the Route Group.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/read-a-route-group-for-a-organization
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'premisePstn/routeGroups/{route_group_id}')
        data = super().get(url=url, params=params)
        return ReadRouteGroupForOrganizationResponse.parse_obj(data)

    def modify_route_group_for_organization(self, route_group_id: str, name: str, local_gateways: LocalGateways, org_id: str = None):
        """
        Modifies an existing Route Group for an organization based on id.
        A Route Group is a collection of trunks that allows further scale and redundancy with the connection to the
        premises. Route groups can include up to 10 trunks from different locations.
        Modifying a Route Group requires a full administrator auth token with a scope of
        spark-admin:telephony_config_write.

        :param route_group_id: Route Group for which details are being requested.
        :type route_group_id: str
        :param name: A unique name for the Route Group.
        :type name: str
        :param local_gateways: Local Gateways that are part of this Route Group.
        :type local_gateways: LocalGateways
        :param org_id: Organization of the Route Group.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/modify-a-route-group-for-a-organization
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = CreateRouteGroupForOrganizationBody()
        if name is not None:
            body.name = name
        if local_gateways is not None:
            body.local_gateways = local_gateways
        url = self.ep(f'premisePstn/routeGroups/{route_group_id}')
        super().put(url=url, params=params, data=body.json())
        return

    def remove_route_group_from_organization(self, route_group_id: str, org_id: str = None):
        """
        Remove a Route Group from an Organization based on id.
        A Route Group is a collection of trunks that allows further scale and redundancy with the connection to the
        premises. Route groups can include up to 10 trunks from different locations.
        Removing a Route Group requires a full administrator auth token with a scope of
        spark-admin:telephony_config_write.

        :param route_group_id: Route Group for which details are being requested.
        :type route_group_id: str
        :param org_id: Organization of the Route Group.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/remove-a-route-group-from-an-organization
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'premisePstn/routeGroups/{route_group_id}')
        super().delete(url=url, params=params)
        return

    def read_usage_of_routing_group(self, route_group_id: str, org_id: str = None) -> ReadUsageOfRoutingGroupResponse:
        """
        List the number of "Call to" on-premises Extensions, Dial Plans, PSTN Connections, and Route Lists used by a
        specific Route Group.
        Users within Call to Extension locations are registered to a PBX which allows you to route unknown extensions
        (calling number length of 2-6 digits) to the PBX using an existing Trunk or Route Group.
        PSTN Connections may be a Cisco PSTN, a cloud-connected PSTN, or a premises-based PSTN (local gateway).
        Dial Plans allow you to route calls to on-premises extensions via your trunk or route group.
        Route Lists are a list of numbers that can be reached via a route group and can be used to provide cloud PSTN
        connectivity to Webex Calling Dedicated Instance.
        Retrieving usage information requires a full or read-only administrator auth token with a scope of
        spark-admin:telephony_config_read.

        :param route_group_id: ID of the requested Route group.
        :type route_group_id: str
        :param org_id: Organization associated with the specific route group.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/read-the-usage-of-a-routing-group
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'premisePstn/routeGroups/{route_group_id}/usage')
        data = super().get(url=url, params=params)
        return ReadUsageOfRoutingGroupResponse.parse_obj(data)

    def read_to_extension_locations_of_routing_group(self, route_group_id: str, org_id: str = None, location_name: str = None, order: str = None, **params) -> Generator[Role, None, None]:
        """
        List "Call to" on-premises Extension Locations for a specific route group. Users within these locations are
        registered to a PBX which allows you to route unknown extensions (calling number length of 2-6 digits) to the
        PBX using an existing trunk or route group.
        Retrieving this location list requires a full or read-only administrator auth token with a scope of
        spark-admin:telephony_config_read.

        :param route_group_id: ID of the requested Route group.
        :type route_group_id: str
        :param org_id: Organization associated with specific route group.
        :type org_id: str
        :param location_name: Return the list of locations matching the location name.
        :type location_name: str
        :param order: Order the locations according to designated fields. Available sort orders are asc, and desc.
        :type order: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/read-the-call-to-extension-locations-of-a-routing-group
        """
        if org_id is not None:
            params['orgId'] = org_id
        if location_name is not None:
            params['locationName'] = location_name
        if order is not None:
            params['order'] = order
        url = self.ep(f'premisePstn/routeGroups/{route_group_id}/usageCallToExtension')
        return self.session.follow_pagination(url=url, model=Role, item_key='locations', params=params)

    def read_dial_plan_locations_of_routing_group(self, route_group_id: str, org_id: str = None, location_name: str = None, order: str = None, **params) -> Generator[Role, None, None]:
        """
        List Dial Plan Locations for a specific route group.
        Dial Plans allow you to route calls to on-premises destinations by use of trunks or route groups. They are
        configured globally for an enterprise and apply to all users, regardless of location.
        A Dial Plan also specifies the routing choice (trunk or route group) for calls that match any of its dial
        patterns. Specific dial patterns can be defined as part of your dial plan.
        Retrieving this location list requires a full or read-only administrator auth token with a scope of
        spark-admin:telephony_config_read.

        :param route_group_id: ID of the requested Route group.
        :type route_group_id: str
        :param org_id: Organization associated with specific route group.
        :type org_id: str
        :param location_name: Return the list of locations matching the location name.
        :type location_name: str
        :param order: Order the locations according to designated fields. Available sort orders are asc, and desc.
        :type order: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/read-the-dial-plan-locations-of-a-routing-group
        """
        if org_id is not None:
            params['orgId'] = org_id
        if location_name is not None:
            params['locationName'] = location_name
        if order is not None:
            params['order'] = order
        url = self.ep(f'premisePstn/routeGroups/{route_group_id}/usageDialPlan')
        return self.session.follow_pagination(url=url, model=Role, item_key='locations', params=params)

    def read_pstn_connection_locations_of_routing_group(self, route_group_id: str, org_id: str = None, location_name: str = None, order: str = None, **params) -> Generator[Role, None, None]:
        """
        List PSTN Connection Locations for a specific route group. This solution lets you configure users to use Cloud
        PSTN (CCP or Cisco PSTN) or Premises-based PSTN.
        Retrieving this Location list requires a full or read-only administrator auth token with a scope of
        spark-admin:telephony_config_read.

        :param route_group_id: ID of the requested Route group.
        :type route_group_id: str
        :param org_id: Organization associated with specific route group.
        :type org_id: str
        :param location_name: Return the list of locations matching the location name.
        :type location_name: str
        :param order: Order the locations according to designated fields. Available sort orders are asc, and desc.
        :type order: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/read-the-pstn-connection-locations-of-a-routing-group
        """
        if org_id is not None:
            params['orgId'] = org_id
        if location_name is not None:
            params['locationName'] = location_name
        if order is not None:
            params['order'] = order
        url = self.ep(f'premisePstn/routeGroups/{route_group_id}/usagePstnConnection')
        return self.session.follow_pagination(url=url, model=Role, item_key='locations', params=params)

    def read_route_lists_of_routing_group(self, route_group_id: str, org_id: str = None, name: str = None, order: str = None, **params) -> Generator[RouteGroupUsageRouteListGet, None, None]:
        """
        List Route Lists for a specific route group. Route Lists are a list of numbers that can be reached via a Route
        Group. It can be used to provide cloud PSTN connectivity to Webex Calling Dedicated Instance.
        Retrieving this list of Route Lists requires a full or read-only administrator auth token with a scope of
        spark-admin:telephony_config_read.

        :param route_group_id: ID of the requested Route group.
        :type route_group_id: str
        :param org_id: Organization associated with specific route group.
        :type org_id: str
        :param name: Return the list of locations matching the location name.
        :type name: str
        :param order: Order the locations according to designated fields. Available sort orders are asc, and desc.
        :type order: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/read-the-route-lists-of-a-routing-group
        """
        if org_id is not None:
            params['orgId'] = org_id
        if name is not None:
            params['name'] = name
        if order is not None:
            params['order'] = order
        url = self.ep(f'premisePstn/routeGroups/{route_group_id}/usageRouteList')
        return self.session.follow_pagination(url=url, model=RouteGroupUsageRouteListGet, item_key='routeGroupUsageRouteListGet', params=params)

    def read_list_of_route_lists(self, org_id: str = None, name: List[str] = None, location_id: List[str] = None, order: str = None, **params) -> Generator[RouteList, None, None]:
        """
        List all Route Lists for the organization.
        A Route List is a list of numbers that can be reached via a Route Group. It can be used to provide cloud PSTN
        connectivity to Webex Calling Dedicated Instance.
        Retrieving the Route List requires a full or read-only administrator auth token with a scope of
        spark-admin:telephony_config_read.

        :param org_id: List all Route List for this organization.
        :type org_id: str
        :param name: Return the list of Route List matching the route list name.
        :type name: List[str]
        :param location_id: Return the list of Route Lists matching the location id.
        :type location_id: List[str]
        :param order: Order the Route List according to the designated fields. Available sort fields are name, and
            locationId. Sort order is ascending by default
        :type order: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/read-the-list-of-route-lists
        """
        if org_id is not None:
            params['orgId'] = org_id
        if name is not None:
            params['name'] = name
        if location_id is not None:
            params['locationId'] = location_id
        if order is not None:
            params['order'] = order
        url = self.ep('premisePstn/routeLists')
        return self.session.follow_pagination(url=url, model=RouteList, item_key='routeLists', params=params)

    def create_route_list(self, location_id: str, org_id: str = None, name: str = None, route_group_id: str = None) -> str:
        """
        Create a Route List for the organization.
        A Route List is a list of numbers that can be reached via a Route Group. It can be used to provide cloud PSTN
        connectivity to Webex Calling Dedicated Instance.
        Creating a Route List requires a full administrator auth token with a scope of
        spark-admin:telephony_config_write.

        :param location_id: Location associated with the Route List.
        :type location_id: str
        :param org_id: Organization to which the Route List belongs.
        :type org_id: str
        :param name: Route List new name.
        :type name: str
        :param route_group_id: New route group ID.
        :type route_group_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/create-a-route-list
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = CreateRouteListBody()
        if location_id is not None:
            body.location_id = location_id
        if name is not None:
            body.name = name
        if route_group_id is not None:
            body.route_group_id = route_group_id
        url = self.ep('premisePstn/routeLists')
        data = super().post(url=url, params=params, data=body.json())
        return data["id"]

    def delete_route_list(self, route_list_id: str, org_id: str = None):
        """
        Delete a route list for a customer.
        A Route List is a list of numbers that can be reached via a Route Group. It can be used to provide cloud PSTN
        connectivity to Webex Calling Dedicated Instance.
        Deleting a Route List requires a full administrator auth token with a scope of
        spark-admin:telephony_config_write.

        :param route_list_id: ID of the Route List.
        :type route_list_id: str
        :param org_id: Organization to which the Route List belongs.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/delete-a-route-list
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'premisePstn/routeLists/{route_list_id}')
        super().delete(url=url, params=params)
        return

    def route_list(self, route_list_id: str, org_id: str = None) -> GetRouteListResponse:
        """
        Get a rout list details.
        A Route List is a list of numbers that can be reached via a Route Group. It can be used to provide cloud PSTN
        connectivity to Webex Calling Dedicated Instance.
        Retrieving a Route List requires a full or read-only administrator auth token with a scope of
        spark-admin:telephony_config_read.

        :param route_list_id: ID of the Route List.
        :type route_list_id: str
        :param org_id: Organization to which the Route List belongs.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/get-a-route-list
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'premisePstn/routeLists/{route_list_id}')
        data = super().get(url=url, params=params)
        return GetRouteListResponse.parse_obj(data)

    def modify_route_list(self, route_list_id: str, org_id: str = None, name: str = None, route_group_id: str = None):
        """
        Modify the details for a Route List.
        A Route List is a list of numbers that can be reached via a Route Group. It can be used to provide cloud PSTN
        connectivity to Webex Calling Dedicated Instance.
        Retrieving a Route List requires a full or read-only administrator auth token with a scope of
        spark-admin:telephony_config_write.

        :param route_list_id: ID of the Route List.
        :type route_list_id: str
        :param org_id: Organization to which the Route List belongs.
        :type org_id: str
        :param name: Route List new name.
        :type name: str
        :param route_group_id: New route group ID.
        :type route_group_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/modify-a-route-list
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = ModifyRouteListBody()
        if name is not None:
            body.name = name
        if route_group_id is not None:
            body.route_group_id = route_group_id
        url = self.ep(f'premisePstn/routeLists/{route_list_id}')
        super().put(url=url, params=params, data=body.json())
        return

    def modify_numbers_for_route_list(self, route_list_id: str, org_id: str = None, numbers: RouteListNumberPatch = None, delete_all_numbers: bool = None) -> list[RouteListNumberPatchResponse]:
        """
        Modify numbers for a specific Route List of a Customer.
        A Route List is a list of numbers that can be reached via a Route Group. It can be used to provide cloud PSTN
        connectivity to Webex Calling Dedicated Instance.
        Retrieving a Route List requires a full or read-only administrator auth token with a scope of
        spark-admin:telephony_config_write.

        :param route_list_id: ID of the Route List.
        :type route_list_id: str
        :param org_id: Organization to which the Route List belongs.
        :type org_id: str
        :param numbers: Array of the numbers to be deleted/added.
        :type numbers: RouteListNumberPatch
        :param delete_all_numbers: If present, the numbers array is ignored and all numbers in the route list are
            deleted.
        :type delete_all_numbers: bool

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/modify-numbers-for-route-list
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = ModifyNumbersForRouteListBody()
        if numbers is not None:
            body.numbers = numbers
        if delete_all_numbers is not None:
            body.delete_all_numbers = delete_all_numbers
        url = self.ep(f'premisePstn/routeLists/{route_list_id}/numbers')
        data = super().put(url=url, params=params, data=body.json())
        return parse_obj_as(list[RouteListNumberPatchResponse], data["numberStatus"])

    def numbers_assigned_to_route_list(self, route_list_id: str, org_id: str = None, max: int = None, start: int = None, order: str = None, number: str = None) -> str:
        """
        Get numbers assigned to a Route List
        A Route List is a list of numbers that can be reached via a Route Group. It can be used to provide cloud PSTN
        connectivity to Webex Calling Dedicated Instance.
        Retrieving a Route List requires a full or read-only administrator auth token with a scope of
        spark-admin:telephony_config_write.

        :param route_list_id: ID of the Route List.
        :type route_list_id: str
        :param org_id: Organization to which the Route List belongs.
        :type org_id: str
        :param max: Limit the number of objects returned to this maximum count.
        :type max: int
        :param start: Start at the zero-based offset in the list of matching objects.
        :type start: int
        :param order: Order the Route Lists according to number, ascending or descending.
        :type order: str
        :param number: Number assigned to the route list.
        :type number: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/get-numbers-assigned-to-a-route-list
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        if max is not None:
            params['max'] = max
        if start is not None:
            params['start'] = start
        if order is not None:
            params['order'] = order
        if number is not None:
            params['number'] = number
        url = self.ep(f'premisePstn/routeLists/{route_list_id}/numbers')
        data = super().get(url=url, params=params)
        return data["phoneNumbers"]

    def local_gateway_to_on_premises_extension_usage_for_trunk(self, trunk_id: str, org_id: str = None, max: int = None, start: int = None, order: str = None, name: List[str] = None) -> Role:
        """
        Get local gateway call to on-premises extension usage for a trunk.
        A trunk is a connection between Webex Calling and the premises, which terminates on the premises with a local
        gateway or other supported device.
        The trunk can be assigned to a Route Group which is a group of trunks that allow Webex Calling to distribute
        calls over multiple trunks or to provide redundancy.
        Retrieving this information requires a full administrator auth token with a scope of
        spark-admin:telephony_config_read.

        :param trunk_id: ID of the trunk.
        :type trunk_id: str
        :param org_id: Organization to which the trunk belongs.
        :type org_id: str
        :param max: Limit the number of objects returned to this maximum count.
        :type max: int
        :param start: Start at the zero-based offset in the list of matching objects.
        :type start: int
        :param order: Order the trunks according to the designated fields. Available sort fields are name, and
            locationName. Sort order is ascending by default
        :type order: str
        :param name: Return the list of trunks matching the local gateway names
        :type name: List[str]

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/get-local-gateway-call-to-on-premises-extension-usage-for-a-trunk
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        if max is not None:
            params['max'] = max
        if start is not None:
            params['start'] = start
        if order is not None:
            params['order'] = order
        if name is not None:
            params['name'] = name
        url = self.ep(f'premisePstn/trunks/{trunk_id}/usageCallToExtension')
        data = super().get(url=url, params=params)
        return Role.parse_obj(data["location"])

    def local_gateway_dial_plan_usage_for_trunk(self, trunk_id: str, org_id: str = None, order: str = None, name: List[str] = None, **params) -> Generator[Role, None, None]:
        """
        Get Local Gateway Dial Plan Usage for a Trunk.
        A trunk is a connection between Webex Calling and the premises, which terminates on the premises with a local
        gateway or other supported device.
        The trunk can be assigned to a Route Group which is a group of trunks that allow Webex Calling to distribute
        calls over multiple trunks or to provide redundancy.
        Retrieving this information requires a full administrator auth token with a scope of
        spark-admin:telephony_config_read.

        :param trunk_id: ID of the trunk.
        :type trunk_id: str
        :param org_id: Organization to which the trunk belongs.
        :type org_id: str
        :param order: Order the trunks according to the designated fields. Available sort fields are name, and
            locationName. Sort order is ascending by default
        :type order: str
        :param name: Return the list of trunks matching the local gateway names
        :type name: List[str]

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/get-local-gateway-dial-plan-usage-for-a-trunk
        """
        if org_id is not None:
            params['orgId'] = org_id
        if order is not None:
            params['order'] = order
        if name is not None:
            params['name'] = name
        url = self.ep(f'premisePstn/trunks/{trunk_id}/usageDialPlan')
        return self.session.follow_pagination(url=url, model=Role, item_key='dialPlans', params=params)

    def locations_using_local_gateway_as_pstn_connection_routing(self, trunk_id: str, org_id: str = None) -> Role:
        """
        Get Locations Using the Local Gateway as PSTN Connection Routing.
        A trunk is a connection between Webex Calling and the premises, which terminates on the premises with a local
        gateway or other supported device.
        The trunk can be assigned to a Route Group which is a group of trunks that allow Webex Calling to distribute
        calls over multiple trunks or to provide redundancy.
        Retrieving this information requires a full administrator auth token with a scope of
        spark-admin:telephony_config_read.

        :param trunk_id: ID of the trunk.
        :type trunk_id: str
        :param org_id: Organization to which the trunk belongs.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/get-locations-using-the-local-gateway-as-pstn-connection-routing
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'premisePstn/trunks/{trunk_id}/usagePstnConnection')
        data = super().get(url=url, params=params)
        return Role.parse_obj(data["location"])

    def route_groups_using_local_gateway(self, trunk_id: str, org_id: str = None) -> list[RouteGroup]:
        """
        Get Route Groups Using the Local Gateway.
        A trunk is a connection between Webex Calling and the premises, which terminates on the premises with a local
        gateway or other supported device.
        The trunk can be assigned to a Route Group which is a group of trunks that allow Webex Calling to distribute
        calls over multiple trunks or to provide redundancy.
        Retrieving this information requires a full administrator auth token with a scope of
        spark-admin:telephony_config_read.

        :param trunk_id: ID of the trunk.
        :type trunk_id: str
        :param org_id: Organization to which the trunk belongs.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/get-route-groups-using-the-local-gateway
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'premisePstn/trunks/{trunk_id}/usageRouteGroup')
        data = super().get(url=url, params=params)
        return parse_obj_as(list[RouteGroup], data["routeGroup"])

    def local_gateway_usage_count(self, trunk_id: str, org_id: str = None) -> GetLocalGatewayUsageCountResponse:
        """
        Get Local Gateway Usage Count
        A trunk is a connection between Webex Calling and the premises, which terminates on the premises with a local
        gateway or other supported device.
        The trunk can be assigned to a Route Group which is a group of trunks that allow Webex Calling to distribute
        calls over multiple trunks or to provide redundancy.
        Retrieving this information requires a full administrator auth token with a scope of
        spark-admin:telephony_config_read.

        :param trunk_id: ID of the trunk.
        :type trunk_id: str
        :param org_id: Organization to which the trunk belongs.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/get-local-gateway-usage-count
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'premisePstn/trunks/{trunk_id}/usage')
        data = super().get(url=url, params=params)
        return GetLocalGatewayUsageCountResponse.parse_obj(data)

    def details_for_queue_holiday_service(self, location_id: str, queue_id: str, org_id: str = None) -> GetDetailsForCallQueueHolidayServiceResponse:
        """
        Retrieve Call Queue Holiday Service details.
        Configure the call queue to route calls differently during the holidays.
        Retrieving call queue holiday service details requires a full or read-only administrator auth token with a
        scope of spark-admin:telephony_config_read.

        :param location_id: Retrieve settings for a call queue in this location.
        :type location_id: str
        :param queue_id: Retrieve settings for the call queue with this identifier.
        :type queue_id: str
        :param org_id: Retrieve call queue settings from this organization.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/get-details-for-a-call-queue-holiday-service
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/queues/{queue_id}/holidayService')
        data = super().get(url=url, params=params)
        return GetDetailsForCallQueueHolidayServiceResponse.parse_obj(data)

    def update_queue_holiday_service(self, location_id: str, queue_id: str, holiday_service_enabled: bool, holiday_schedule_level: HolidayScheduleLevel, play_announcement_before_enabled: bool, org_id: str = None, action: Action15 = None, transfer_phone_number: str = None, audio_message_selection: Greeting = None, audio_files: CallQueueAudioFilesObject = None, holiday_schedule_name: str = None):
        """
        Update the designated Call Queue Holiday Service.
        Configure the call queue to route calls differently during the holidays.
        Updating a call queue holiday service requires a full administrator auth token with a scope of
        spark-admin:telephony_config_write.

        :param location_id: Location in which this call queue exists.
        :type location_id: str
        :param queue_id: Update setting for the call queue with the matching ID.
        :type queue_id: str
        :param holiday_service_enabled: Enable or Disable the call queue holiday service routing policy.
        :type holiday_service_enabled: bool
        :param holiday_schedule_level: Specifies whether the schedule mentioned in holidayScheduleName is org or
            location specific. (Must be from holidaySchedules list)
        :type holiday_schedule_level: HolidayScheduleLevel
        :param play_announcement_before_enabled: Specifies if an announcement plays to callers before applying the
            action.
        :type play_announcement_before_enabled: bool
        :param org_id: Update call queue settings from this organization.
        :type org_id: str
        :param action: Specifies call processing action type.
        :type action: Action15
        :param transfer_phone_number: Call gets transferred to this number when action is set to TRANSFER. This can
            also be an extension.
        :type transfer_phone_number: str
        :param audio_message_selection: Specifies what type of announcement to be played.
        :type audio_message_selection: Greeting
        :param audio_files: List of Announcement Audio Files when audioMessageSelection is CUSTOM.
        :type audio_files: CallQueueAudioFilesObject
        :param holiday_schedule_name: Name of the schedule configured for a holiday service as one of from
            holidaySchedules list.
        :type holiday_schedule_name: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/update-a-call-queue-holiday-service
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = UpdateCallQueueHolidayServiceBody()
        if holiday_service_enabled is not None:
            body.holiday_service_enabled = holiday_service_enabled
        if holiday_schedule_level is not None:
            body.holiday_schedule_level = holiday_schedule_level
        if play_announcement_before_enabled is not None:
            body.play_announcement_before_enabled = play_announcement_before_enabled
        if action is not None:
            body.action = action
        if transfer_phone_number is not None:
            body.transfer_phone_number = transfer_phone_number
        if audio_message_selection is not None:
            body.audio_message_selection = audio_message_selection
        if audio_files is not None:
            body.audio_files = audio_files
        if holiday_schedule_name is not None:
            body.holiday_schedule_name = holiday_schedule_name
        url = self.ep(f'locations/{location_id}/queues/{queue_id}/holidayService')
        super().put(url=url, params=params, data=body.json())
        return

    def details_for_queue_night_service(self, location_id: str, queue_id: str, org_id: str = None) -> GetDetailsForCallQueueNightServiceResponse:
        """
        Retrieve Call Queue Night service details.
        Configure the call queue to route calls differently during the hours when the queue is not in service. This is
        determined by a schedule that defines the business hours of the queue.
        Retrieving call queue details requires a full or read-only administrator auth token with a scope of
        spark-admin:telephony_config_read.

        :param location_id: Retrieve settings for a call queue in this location.
        :type location_id: str
        :param queue_id: Retrieve settings for the call queue night service with this identifier.
        :type queue_id: str
        :param org_id: Retrieve call queue night service settings from this organization.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/get-details-for-a-call-queue-night-service
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/queues/{queue_id}/nightService')
        data = super().get(url=url, params=params)
        return GetDetailsForCallQueueNightServiceResponse.parse_obj(data)

    def update_queue_night_service(self, location_id: str, queue_id: str, night_service_enabled: bool, play_announcement_before_enabled: bool, announcement_mode: AnnouncementMode, force_night_service_enabled: bool, manual_audio_message_selection: Greeting, org_id: str = None, action: Action15 = None, transfer_phone_number: str = None, audio_message_selection: Greeting = None, audio_files: CallQueueAudioFilesObject = None, business_hours_name: str = None, business_hours_level: HolidayScheduleLevel = None, manual_audio_files: CallQueueAudioFilesObject = None):
        """
        Update Call Queue Night Service details.
        Configure the call queue to route calls differently during the hours when the queue is not in service. This is
        determined by a schedule that defines the business hours of the queue.
        Updating call queue night service details requires a full administrator auth token with a scope of
        spark-admin:telephony_config_write.

        :param location_id: Retrieve settings for a call queue in this location.
        :type location_id: str
        :param queue_id: Retrieve settings for the call queue night service with this identifier.
        :type queue_id: str
        :param night_service_enabled: Enable or disable call queue night service routing policy.
        :type night_service_enabled: bool
        :param play_announcement_before_enabled: Specifies if an announcement plays to callers before applying the
            action.
        :type play_announcement_before_enabled: bool
        :param announcement_mode: Specifies the type of announcements to played.
        :type announcement_mode: AnnouncementMode
        :param force_night_service_enabled: Force night service regardless of business hour schedule.
        :type force_night_service_enabled: bool
        :param manual_audio_message_selection: Specifies what type of announcement to be played when announcementMode
            is MANUAL.
        :type manual_audio_message_selection: Greeting
        :param org_id: Retrieve call queue night service settings from this organization.
        :type org_id: str
        :param action: Specifies call processing action type.
        :type action: Action15
        :param transfer_phone_number: Call gets transferred to this number when action is set to TRANSFER. This can
            also be an extension.
        :type transfer_phone_number: str
        :param audio_message_selection: Specifies what type of announcement to be played.
        :type audio_message_selection: Greeting
        :param audio_files: List of Announcement Audio Files when audioMessageSelection is CUSTOM.
        :type audio_files: CallQueueAudioFilesObject
        :param business_hours_name: Name of the schedule configured for a night service as one of from
            businessHourSchedules list.
        :type business_hours_name: str
        :param business_hours_level: Specifies whether the above mentioned schedule is org or location specific. (Must
            be from businessHourSchedules list)
        :type business_hours_level: HolidayScheduleLevel
        :param manual_audio_files: List Of pre-configured Audio Files.
        :type manual_audio_files: CallQueueAudioFilesObject

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/update-a-call-queue-night-service
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = UpdateCallQueueNightServiceBody()
        if night_service_enabled is not None:
            body.night_service_enabled = night_service_enabled
        if play_announcement_before_enabled is not None:
            body.play_announcement_before_enabled = play_announcement_before_enabled
        if announcement_mode is not None:
            body.announcement_mode = announcement_mode
        if force_night_service_enabled is not None:
            body.force_night_service_enabled = force_night_service_enabled
        if manual_audio_message_selection is not None:
            body.manual_audio_message_selection = manual_audio_message_selection
        if action is not None:
            body.action = action
        if transfer_phone_number is not None:
            body.transfer_phone_number = transfer_phone_number
        if audio_message_selection is not None:
            body.audio_message_selection = audio_message_selection
        if audio_files is not None:
            body.audio_files = audio_files
        if business_hours_name is not None:
            body.business_hours_name = business_hours_name
        if business_hours_level is not None:
            body.business_hours_level = business_hours_level
        if manual_audio_files is not None:
            body.manual_audio_files = manual_audio_files
        url = self.ep(f'locations/{location_id}/queues/{queue_id}/nightService')
        super().put(url=url, params=params, data=body.json())
        return

    def details_for_queue_forced_forward(self, location_id: str, queue_id: str, org_id: str = None) -> GetDetailsForCallQueueForcedForwardResponse:
        """
        Retrieve Call Queue policy Forced Forward details.
        This policy allows calls to be temporarily diverted to a configured destination.
        Retrieving call queue Forced Forward details requires a full or read-only administrator auth token with a scope
        of spark-admin:telephony_config_read.

        :param location_id: Retrieve settings for a call queue in this location.
        :type location_id: str
        :param queue_id: Retrieve settings for the call queue with this identifier.
        :type queue_id: str
        :param org_id: Retrieve call queue settings from this organization.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/get-details-for-a-call-queue-forced-forward
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/queues/{queue_id}/forcedForward')
        data = super().get(url=url, params=params)
        return GetDetailsForCallQueueForcedForwardResponse.parse_obj(data)

    def update_queue_forced_forward_service(self, location_id: str, queue_id: str, org_id: str = None, forced_forward_enabled: bool = None, transfer_phone_number: str = None, play_announcement_before_enabled: bool = None, audio_message_selection: Greeting = None, audio_files: CallQueueAudioFilesObject = None):
        """
        Update the designated Forced Forward Service.
        If the option is enabled, then incoming calls to the queue are forwarded to the configured destination. Calls
        that are already in the queue remain queued.
        The policy can be configured to play an announcement prior to proceeding with the forward.
        Updating a call queue Forced Forward service requires a full administrator auth token with a scope of
        spark-admin:telephony_config_write.

        :param location_id: Location in which this call queue exists.
        :type location_id: str
        :param queue_id: Update setting for the call queue with the matching ID.
        :type queue_id: str
        :param org_id: Update call queue settings from this organization.
        :type org_id: str
        :param forced_forward_enabled: Whether or not the call queue forced forward routing policy setting is enabled.
        :type forced_forward_enabled: bool
        :param transfer_phone_number: Call gets transferred to this number when action is set to TRANSFER. This can
            also be an extension.
        :type transfer_phone_number: str
        :param play_announcement_before_enabled: Specifies if an announcement plays to callers before applying the
            action.
        :type play_announcement_before_enabled: bool
        :param audio_message_selection: Specifies what type of announcement to be played.
        :type audio_message_selection: Greeting
        :param audio_files: List of Announcement Audio Files when audioMessageSelection is CUSTOM.
        :type audio_files: CallQueueAudioFilesObject

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/update-a-call-queue-forced-forward-service
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = GetDetailsForCallQueueForcedForwardResponse()
        if forced_forward_enabled is not None:
            body.forced_forward_enabled = forced_forward_enabled
        if transfer_phone_number is not None:
            body.transfer_phone_number = transfer_phone_number
        if play_announcement_before_enabled is not None:
            body.play_announcement_before_enabled = play_announcement_before_enabled
        if audio_message_selection is not None:
            body.audio_message_selection = audio_message_selection
        if audio_files is not None:
            body.audio_files = audio_files
        url = self.ep(f'locations/{location_id}/queues/{queue_id}/forcedForward')
        super().put(url=url, params=params, data=body.json())
        return

    def details_for_queue_stranded(self, location_id: str, queue_id: str, org_id: str = None) -> GetDetailsForCallQueueStrandedCallsResponse:
        """
        Allow admin to view default/configured Stranded Calls settings.
        Stranded-All agents logoff Policy: If the last agent staffing a queue “unjoins” the queue or signs out, then
        all calls in the queue become stranded.
        Stranded-Unavailable Policy: This policy allows for the configuration of the processing of calls that are in a
        staffed queue when all agents are unavailable.
        Retrieving call queue Stranded Calls details requires a full or read-only administrator auth token with a scope
        of spark-admin:telephony_config_read.

        :param location_id: Retrieve settings for a call queue in this location.
        :type location_id: str
        :param queue_id: Retrieve settings for the call queue with this identifier.
        :type queue_id: str
        :param org_id: Retrieve call queue settings from this organization.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/get-details-for-a-call-queue-stranded-calls
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/queues/{queue_id}/strandedCalls')
        data = super().get(url=url, params=params)
        return GetDetailsForCallQueueStrandedCallsResponse.parse_obj(data)

    def update_queue_stranded_service(self, location_id: str, queue_id: str, org_id: str = None, action: Action15 = None, transfer_phone_number: str = None, audio_message_selection: Greeting = None, audio_files: CallQueueAudioFilesObject = None):
        """
        Update the designated Call Stranded Calls Service.
        Allow admin to modify configured Stranded Calls settings.
        Updating a call queue stranded calls requires a full administrator auth token with a scope of
        spark-admin:telephony_config_write.

        :param location_id: Location in which this call queue exists.
        :type location_id: str
        :param queue_id: Update setting for the call queue with the matching ID.
        :type queue_id: str
        :param org_id: Update call queue settings from this organization.
        :type org_id: str
        :param action: Specifies call processing action type.
        :type action: Action15
        :param transfer_phone_number: Call gets transferred to this number when action is set to TRANSFER. This can
            also be an extension.
        :type transfer_phone_number: str
        :param audio_message_selection: Specifies what type of announcement to be played.
        :type audio_message_selection: Greeting
        :param audio_files: List of Announcement Audio Files when audioMessageSelection is CUSTOM.
        :type audio_files: CallQueueAudioFilesObject

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/update-a-call-queue-stranded-calls-service
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = GetDetailsForCallQueueStrandedCallsResponse()
        if action is not None:
            body.action = action
        if transfer_phone_number is not None:
            body.transfer_phone_number = transfer_phone_number
        if audio_message_selection is not None:
            body.audio_message_selection = audio_message_selection
        if audio_files is not None:
            body.audio_files = audio_files
        url = self.ep(f'locations/{location_id}/queues/{queue_id}/strandedCalls')
        super().put(url=url, params=params, data=body.json())
        return

    def location_device_settings(self, location_id: str, org_id: str = None) -> GetDeviceSettingsResponse:
        """
        Get device override settings for a location.
        This requires a full or read-only administrator auth token with a scope of spark-admin:telephony_config_read.

        :param location_id: Unique identifier for the location.
        :type location_id: str
        :param org_id: Organization in which the device resides.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/get-location-device-settings
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/devices/settings')
        data = super().get(url=url, params=params)
        return GetDeviceSettingsResponse.parse_obj(data)

    def read_list_of_supported_devices(self, org_id: str = None) -> list[DeviceObject]:
        """
        Gets the list of supported devices for an organization.
        Retrieving this list requires a full or read-only administrator auth token with a scope of
        spark-admin:telephony_config_read.

        :param org_id: List supported devices for an organization.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/read-the-list-of-supported-devices
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep('supportedDevices')
        data = super().get(url=url, params=params)
        return parse_obj_as(list[DeviceObject], data["devices"])

    def readdevice_override_settings_fororganization(self, org_id: str = None) -> ReaddeviceOverrideSettingsFororganizationResponse:
        """
        Get device override settings for an organization.
        Retrieving this list requires a full or read-only administrator auth token with a scope of
        spark-admin:telephony_config_read.

        :param org_id: List supported devices for an organization.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/read-the-device-override-settings-for-a-organization
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep('devices/settings')
        data = super().get(url=url, params=params)
        return ReaddeviceOverrideSettingsFororganizationResponse.parse_obj(data)

    def read_dect_device_type_list(self, org_id: str = None) -> list[DectDeviceList]:
        """
        Get DECT device type list with base stations and line ports supported count. This is a static list.
        Retrieving this list requires a full or read-only administrator auth token with a scope of
        spark-admin:telephony_config_read.

        :param org_id: 
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/read-the-dect-device-type-list
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep('devices/dects/supportedDevices')
        data = super().get(url=url, params=params)
        return parse_obj_as(list[DectDeviceList], data["devices"])

    def validatelist_of_mac_address(self, macs: List[str], org_id: str = None) -> ValidatelistOfMACAddressResponse:
        """
        Validate a list of MAC addresses.
        Validating this list requires a full or read-only administrator auth token with a scope of
        spark-admin:telephony_config_write.

        :param macs: MAC addresses to be validated. Possible values: {["ab125678cdef", "00005E0053B4"]}
        :type macs: List[str]
        :param org_id: Validate the mac address(es) for this organization.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/validate-a-list-of-mac-address
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = ValidatelistOfMACAddressBody()
        if macs is not None:
            body.macs = macs
        url = self.ep('devices/actions/validateMacs/invoke')
        data = super().post(url=url, params=params, data=body.json())
        return ValidatelistOfMACAddressResponse.parse_obj(data)

    def change_device_settings_across_organization_or_location_job(self, org_id: str = None, location_id: str = None, location_customizations_enabled: bool = None, customizations: CustomizationObject = None) -> StartJobResponse:
        """
        Change device settings across organization or locations jobs.
        Performs bulk and asynchronous processing for all types of device settings initiated by organization and system
        admins in a stateful persistent manner. This job will modify the requested device settings across all the
        devices. Whenever a location ID is specified in the request, it will modify the requested device settings only
        for the devices that are part of the provided location within an organization.
        Returns a unique job ID which can then be utilized further to retrieve status and errors for the same.
        Only one job per customer can be running at any given time within the same organization. An attempt to run
        multiple jobs at the same time will result in a 409 error response.
        Running a job requires a full or read-only administrator auth token with a scope of
        spark-admin:telephony_config_write.

        :param org_id: Apply change device settings for all the devices under this organization.
        :type org_id: str
        :param location_id: Location within an organization where changes of device setings will be applied to all the
            devices within it.
        :type location_id: str
        :param location_customizations_enabled: Indicates if all the devices within this location will be customized
            with new requested customizations(if set to true) or will be overridden with the one at organization level
            (if set to false or any other value). This field has no effect when the job is being triggered at
            organization level.
        :type location_customizations_enabled: bool
        :param customizations: Indicates the settings for ATA devices, DECT devices and MPP devices.
        :type customizations: CustomizationObject

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/change-device-settings-across-organization-or-location-job
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = ChangeDeviceSettingsAcrossOrganizationOrLocationJobBody()
        if location_id is not None:
            body.location_id = location_id
        if location_customizations_enabled is not None:
            body.location_customizations_enabled = location_customizations_enabled
        if customizations is not None:
            body.customizations = customizations
        url = self.ep('jobs/devices/callDeviceSettings')
        data = super().post(url=url, params=params, data=body.json())
        return StartJobResponse.parse_obj(data)

    def list_change_device_settings_jobs(self, org_id: str = None, **params) -> Generator[StartJobResponse, None, None]:
        """
        List change device settings jobs.
        Lists all the jobs for jobType calldevicesettings for the given organization in order of most recent one to
        oldest one irrespective of its status.
        This API requires a full or read-only administrator auth token with a scope of
        spark-admin:telephony_config_read.

        :param org_id: Retrieve list of 'calldevicesettings' jobs for this organization.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/list-change-device-settings-jobs
        """
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep('jobs/devices/callDeviceSettings')
        return self.session.follow_pagination(url=url, model=StartJobResponse, params=params)

    def change_device_settings_job_status(self, job_id: str) -> GetManageNumbersJobStatusResponse:
        """
        Get change device settings job status.
        Provides details of the job with jobId of jobType calldevicesettings.
        This API requires a full or read-only administrator auth token with a scope of
        spark-admin:telephony_config_read.

        :param job_id: Retrieve job details for this jobId.
        :type job_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/get-change-device-settings-job-status
        """
        url = self.ep(f'jobs/devices/callDeviceSettings/{job_id}')
        data = super().get(url=url)
        return GetManageNumbersJobStatusResponse.parse_obj(data)

    def list_change_device_settings_job_errors(self, job_id: str, org_id: str = None, **params) -> Generator[ItemObject, None, None]:
        """
        List change device settings job errors.
        Lists all error details of the job with jobId of jobType calldevicesettings.
        This API requires a full or read-only administrator auth token with a scope of
        spark-admin:telephony_config_read.

        :param job_id: Retrieve job details for this jobId.
        :type job_id: str
        :param org_id: Retrieve list of jobs for this organization.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/list-change-device-settings-job-errors
        """
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'jobs/devices/callDeviceSettings/{job_id}/errors')
        return self.session.follow_pagination(url=url, model=ItemObject, params=params)

    def read_list_of_announcement_languages(self) -> list[FeatureAccessCode]:
        """
        List all languages supported by Webex Calling for announcements and voice prompts.
        Retrieving announcement languages requires a full or read-only administrator auth token with a scope of
        spark-admin:telephony_config_read.

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/read-the-list-of-announcement-languages
        """
        url = self.ep('announcementLanguages')
        data = super().get(url=url)
        return parse_obj_as(list[FeatureAccessCode], data["languages"])

    def create_receptionist_contact_directory(self, location_id: str, contacts: List[PersonId], org_id: str = None, name: str = None) -> str:
        """
        Creates a new Receptionist Contact Directory for a location.
        Receptionist Contact Directories can be used to create named directories of users.
        Adding a directory requires a full or write-only administrator auth token with a scope of
        spark-admin:telephony_config_write.

        :param location_id: Add a Receptionist Contact Directory to this location.
        :type location_id: str
        :param contacts: Array of users assigned to this Receptionist Contact Directory. Person ID.
        :type contacts: List[PersonId]
        :param org_id: Add a Receptionist Contact Directory to this organization.
        :type org_id: str
        :param name: Receptionist Contact Directory name.
        :type name: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/create-a-receptionist-contact-directory
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = CreateReceptionistContactDirectoryBody()
        if contacts is not None:
            body.contacts = contacts
        if name is not None:
            body.name = name
        url = self.ep(f'locations/{location_id}/receptionistContacts/directories')
        data = super().post(url=url, params=params, data=body.json())
        return data["id"]

    def read_list_of_receptionist_contact_directories(self, location_id: str, org_id: str = None) -> list[Role]:
        """
        List all Receptionist Contact Directories for a location.
        Receptionist Contact Directories can be used to create named directories of users.
        Retrieving this list requires a full or read-only administrator auth token with a scope of
        spark-admin:telephony_config_read.

        :param location_id: List Receptionist Contact Directories for this location.
        :type location_id: str
        :param org_id: List Receptionist Contact Directories for this organization.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/read-list-of-receptionist-contact-directories
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/receptionistContacts/directories')
        data = super().get(url=url, params=params)
        return parse_obj_as(list[Role], data["directories"])

    def delete_receptionist_contact_directory(self, location_id: str, directory_id: optional, org_id: str = None):
        """
        Delete a Receptionist Contact Directory from a location.
        Receptionist Contact Directories can be used to create named directories of users.
        Deleting a directory requires a full or write-only administrator auth token with a scope of
        spark-admin:telephony_config_write.

        :param location_id: Delete a Receptionist Contact Directory from this location.
        :type location_id: str
        :param directory_id: Add a Receptionist Contact Directory ID.
        :type directory_id: optional
        :param org_id: Delete a Receptionist Contact Directory from this organization.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-organization-settings/delete-a-receptionist-contact-directory
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/receptionistContacts/directories/{directory_id}')
        super().delete(url=url, params=params)
        return

class AvailableSharedLineMemberItem(ApiModel):
    #: A unique member identifier.
    id: Optional[str]
    #: First name of member.
    first_name: Optional[str]
    #: Last name of member.
    last_name: Optional[str]
    #: Phone number of member. Currently, E.164 format is not supported.
    phone_number: Optional[str]
    #: Phone extension of member.
    extension: Optional[str]
    #: Indicates if the line is acting as a primary line or a shared line for this device.
    line_type: Optional[LineType]
    #: Location object having a unique identifier for the location and its name.
    location: Optional[Role]


class PutSharedLineMemberItem(ApiModel):
    #: Unique identifier for the person or workspace.
    id: Optional[str]
    #: Device port number assigned to person or workspace.
    port: Optional[int]
    #: T.38 Fax Compression setting. Valid only for ATA Devices. Overrides user level compression options.
    t38_fax_compression_enabled: Optional[bool]
    #: If true the person or the workspace is the owner of the device. Points to primary line/port of the device.
    primary_owner: Optional[str]
    #: Indicates if the line is acting as a primary line or a shared line for this device.
    line_type: Optional[LineType]
    #: Number of lines that have been configured for the person on the device.
    line_weight: Optional[int]
    #: Configure this line to automatically call a predefined number whenever taken off-hook. Once enabled, the line
    #: can only make calls to the predefined number set in hotlineDestination.
    hotline_enabled: Optional[bool]
    #: Preconfigured number for the hotline. Required only if hotlineEnabled is set to true.
    hotline_destination: Optional[str]
    #: Set how a device behaves when a call is declined. When set to true, a call decline request is extended to all
    #: the endpoints on the device. When set to false, a call decline request is only declined at the current endpoint.
    allow_call_decline_enabled: Optional[bool]
    #: Device line label.
    line_label: Optional[str]


class GetSharedLineMemberItem(PutSharedLineMemberItem):
    #: First name of person or workspace.
    first_name: Optional[str]
    #: Last name of person or workspace.
    last_name: Optional[str]
    #: Phone number of a person or workspace. Currently, E.164 format is not supported. This will be supported in the
    #: future update.
    phone_number: Optional[str]
    #: Phone extension of a person or workspace.
    extension: Optional[str]
    #: Registration home IP for the line port.
    host_ip: Optional[str]
    #: Registration remote IP for the line port.
    remote_ip: Optional[str]
    #: Indicates if the member is of type PEOPLE or PLACE.
    member_type: Optional[MemberType]
    #: Location object having a unique identifier for the location and its name.
    location: Optional[Role]


class EffectiveBehaviorType(str, Enum):
    #: Calling in Webex or Hybrid Calling.
    native_webex_teams_calling = 'NATIVE_WEBEX_TEAMS_CALLING'
    #: Cisco Jabber app
    call_with_app_registered_for_ciscotel = 'CALL_WITH_APP_REGISTERED_FOR_CISCOTEL'
    #: Third-Party app
    call_with_app_registered_for_tel = 'CALL_WITH_APP_REGISTERED_FOR_TEL'
    #: Webex Calling app
    call_with_app_registered_for_webexcalltel = 'CALL_WITH_APP_REGISTERED_FOR_WEBEXCALLTEL'
    #: Calling in Webex (Unified CM)
    native_sip_call_to_ucm = 'NATIVE_SIP_CALL_TO_UCM'


class BehaviorType(EffectiveBehaviorType):
    #: Using the non-string value of null results in the organization-wide default calling behavior being in effect.
    null = 'null'


class ConfigurepersonsCallingBehaviorBody(ApiModel):
    #: The new Calling Behavior setting for the person (case-insensitive). If null, the effective Calling Behavior will
    #: be the Organization's current default.
    behavior_type: Optional[BehaviorType]
    #: The UC Manager Profile ID. Specifying null results in the organizational default being applied.
    profile_id: Optional[str]


class ReadBargeInSettingsForPersonResponse(ApiModel):
    #: Indicates if the Barge In feature is enabled.
    enabled: Optional[bool]
    #: Indicates that a stutter dial tone will be played when a person is barging in on the active call.
    tone_enabled: Optional[bool]


class NoAnswer3(BusinessContinuity):
    #: Number of rings before the call will be forwarded if unanswered.
    number_of_rings: Optional[int]
    #: System-wide maximum number of rings allowed for numberOfRings setting.
    system_max_number_of_rings: Optional[int]


class CallForwarding4(ApiModel):
    #: Settings for forwarding all incoming calls to the destination you choose.
    always: Optional[Always]
    #: Settings for forwarding all incoming calls to the destination you chose while the phone is in use or the person
    #: is busy.
    busy: Optional[BusinessContinuity]
    #: Settings for forwarding which only occurs when you are away or not answering your phone.
    no_answer: Optional[NoAnswer3]


class ReadForwardingSettingsForPersonResponse(ApiModel):
    #: Settings related to "Always", "Busy", and "No Answer" call forwarding.
    call_forwarding: Optional[CallForwarding4]
    #: Settings for sending calls to a destination of your choice if your phone is not connected to the network for any
    #: reason, such as power outage, failed Internet connection, or wiring problem.
    business_continuity: Optional[BusinessContinuity]


class DeviceOwner(ApiModel):
    #: Unique identifier of a person or a workspace.
    id: Optional[str]
    #: Enumeration that indicates if the member is of type PEOPLE or PLACE.
    type: Optional[MemberType]
    #: First name of device owner.
    first_name: Optional[str]
    #: Last name of device owner.
    last_name: Optional[str]


class ActivationStates(ApiModel):
    #: Indicates a device is activating.
    activating: Optional[str]
    #: Indicates a device is activated.
    activated: Optional[str]
    #: Indicates a device is deactivated.
    deactivated: Optional[str]


class Devices(ApiModel):
    #: Unique identifier for a device.
    id: Optional[str]
    #: Comma separated array of tags used to describe device.
    description: Optional[list[str]]
    #: Identifier for device model.
    model: Optional[str]
    #: MAC address of device.
    mac: Optional[str]
    #: IP address of device.
    ip_address: Optional[str]
    #: Indicates whether the person or the workspace is the owner of the device, and points to a primary Line/Port of
    #: the device.
    primary_owner: Optional[bool]
    #: Indicates if the line is acting as a primary line or a shared line for this device.
    type: Optional[LineType]
    #: Owner of device.
    owner: Optional[DeviceOwner]
    #: Activation state of device.
    activation_state: Optional[ActivationStates]


class Record(str, Enum):
    #: Incoming and outgoing calls will be recorded with no control to start, stop, pause, or resume.
    always = 'Always'
    #: Calls will not be recorded.
    never = 'Never'
    #: Calls are always recorded, but user can pause or resume the recording. Stop recording is not supported.
    always_with_pause_resume = 'Always with Pause/Resume'
    #: Records only the portion of the call after the recording start (*44) has been entered. Pause, resume, and stop
    #: controls are supported.
    on_demand_with_user_initiated_start = 'On Demand with User Initiated Start'


class Type62(str, Enum):
    #: A beep sound is played when call recording is paused or resumed.
    beep = 'Beep'
    #: A verbal announcement is played when call recording is paused or resumed.
    play_announcement = 'Play Announcement'


class Type61(Type62):
    #: No notification sound played when call recording is paused or resumed.
    none = 'None'


class Notification(ApiModel):
    #: Type of pause/resume notification.
    type: Optional[Type61]
    #: true when the notification feature is in effect. false indicates notification is disabled.
    enabled: Optional[bool]


class Repeat(ApiModel):
    #: Interval at which warning tone "beep" will be played. This interval is an integer from 10 to 1800 seconds
    interval: Optional[int]
    #: true when ongoing call recording tone will be played at the designated interval. false indicates no warning tone
    #: will be played.
    enabled: Optional[bool]


class ConfigureCallRecordingSettingsForPersonBody(ApiModel):
    #: true if call recording is enabled.
    enabled: Optional[bool]
    #: Call recording scenario.
    record: Optional[Record]
    #: When true, voicemail messages are also recorded.
    record_voicemail_enabled: Optional[bool]
    #: When enabled, an announcement is played when call recording starts and an announcement is played when call
    #: recording ends.
    start_stop_announcement_enabled: Optional[bool]
    #: Pause/resume notification settings.
    notification: Optional[Notification]
    #: Beep sound plays periodically.
    repeat: Optional[Repeat]


class CLIDPolicySelection(ApiModel):
    #: Outgoing caller ID will show the caller's direct line number and/or extension.
    direct_line: Optional[str]
    #: Outgoing caller ID will show the main number for the location.
    location_number: Optional[str]
    #: Outgoing caller ID will show the value from the customNumber field.
    custom: Optional[str]


class CallerIdSelectedType(CLIDPolicySelection):
    #: Outgoing caller ID will show the mobile number for this person.
    mobile_number: Optional[str]


class ConfigureCallerIDSettingsForPersonBody(ApiModel):
    #: Which type of outgoing Caller ID will be used.
    #: Possible values: DIRECT_LINE
    selected: Optional[CallerIdSelectedType]
    #: This value must be an assigned number from the person's location.
    custom_number: Optional[str]
    #: Person's Caller ID first name. Characters of %, +, ``, " and Unicode characters are not allowed.
    first_name: Optional[str]
    #: Person's Caller ID last name. Characters of %, +, ``, " and Unicode characters are not allowed.
    last_name: Optional[str]
    #: true if person's identity has to be blocked when receiving a transferred or forwarded call.
    block_in_forward_calls_enabled: Optional[bool]
    #: Designates which type of External Caller Id Name policy is used. Default is DIRECT_LINE.
    external_caller_id_name_policy: Optional[ExternalCallerIdNamePolicy]
    #: Person's custom External Caller ID last name. Characters of %, +, ``, " and Unicode characters are not allowed.
    custom_external_caller_id_name: Optional[str]


class ReadDoNotDisturbSettingsForPersonResponse(ApiModel):
    #: true if the Do Not Disturb feature is enabled.
    enabled: Optional[bool]
    #: Enables a Ring Reminder to play a brief tone on your desktop phone when you receive incoming calls.
    ring_splash_enabled: Optional[bool]


class SendAllCalls(ApiModel):
    #: All calls will be sent to voicemail.
    enabled: Optional[bool]


class SendBusyCalls(SendBusyCalls1):
    #: Indicates a custom greeting has been uploaded.
    greeting_uploaded: Optional[bool]


class SendUnansweredCalls(SendBusyCalls):
    #: Number of rings before unanswered call will be sent to voicemail.
    number_of_rings: Optional[int]
    #: System-wide maximum number of rings allowed for numberOfRings setting.
    system_max_number_of_rings: Optional[int]


class MessageStorage3(MessageStorage):
    #: When true desktop phone will indicate there are new voicemails.
    mwi_enabled: Optional[bool]


class ReadVoicemailSettingsForPersonResponse(ApiModel):
    #: Voicemail is enabled or disabled.
    enabled: Optional[bool]
    #: Settings for sending all calls to voicemail.
    send_all_calls: Optional[SendAllCalls]
    #: Settings for sending calls to voicemail when the line is busy.
    send_busy_calls: Optional[SendBusyCalls]
    send_unanswered_calls: Optional[SendUnansweredCalls]
    #: Settings for notifications when there are any new voicemails.
    notifications: Optional[NewNumber]
    #: Settings for voicemail caller to transfer to a different number by pressing zero (0).
    transfer_to_number: Optional[NewNumber]
    #: Settings for sending a copy of new voicemail message audio via email.
    email_copy_of_message: Optional[EmailCopyOfMessage]
    message_storage: Optional[MessageStorage3]
    fax_message: Optional[FaxMessage]


class ScheduleShortDetails(Role):
    #: Indicates the schedule type whether businessHours or holidays.
    type: Optional[Type54]


class RecurWeekly2(RecurWeeklyObject):
    #: Specifies the number of weeks between the start of each recurrence.
    recur_interval: Optional[int]


class Recurrence(ApiModel):
    #: True if the event repeats forever. Requires either recurDaily or recurWeekly to be specified.
    recur_for_ever: Optional[bool]
    #: End date for the recurring event in the format of YYYY-MM-DD. Requires either recurDaily or recurWeekly to be
    #: specified.
    recur_end_date: Optional[str]
    #: End recurrence after the event has repeated the specified number of times. Requires either recurDaily or
    #: recurWeekly to be specified.
    recur_end_occurrence: Optional[int]
    #: Specifies the number of days between the start of each recurrence. Not allowed with recurWeekly.
    #: Recurring interval in days. The number of days after the start when an event will repeat. Repetitions cannot
    #: overlap.
    recur_daily: Optional[object]
    #: Specifies the event recur weekly on the designated days of the week. Not allowed with recurDaily.
    recur_weekly: Optional[RecurWeekly2]


class EventLongDetails(ApiModel):
    #: Name for the event.
    name: Optional[str]
    #: Start date of the event, or first occurrence if repeating, in the format of YYYY-MM-DD. This field is required
    #: if the allDayEnabled field is present.
    start_date: Optional[str]
    #: End date of the event, or first occurrence if repeating, in the format of YYYY-MM-DD. This field is required if
    #: the allDayEnabled field is present.
    end_date: Optional[str]
    #: Start time of the event in the format of HH:MM (24 hours format). This field is required if the allDayEnabled
    #: field is false or omitted.
    start_time: Optional[str]
    #: End time of the event in the format of HH:MM (24 hours format). This field is required if the allDayEnabled
    #: field is false or omitted.
    end_time: Optional[str]
    #: True if it is all-day event.
    all_day_enabled: Optional[bool]
    #: Recurrance scheme for an event.
    recurrence: Optional[Recurrence]


class CreateScheduleForPersonBody(ApiModel):
    #: Name for the schedule.
    name: Optional[str]
    #: Indicates the schedule type whether businessHours or holidays.
    type: Optional[Type54]
    #: Indicates a list of events.
    events: Optional[list[EventLongDetails]]


class Member5(CoHosts):
    #: The identifier of the monitored person.
    id: Optional[str]
    #: The last name of the monitored person, place or virtual line.
    last_name: Optional[str]
    #: The first name of the monitored person, place or virtual line.
    first_name: Optional[str]
    #: Indicates whether the type is PEOPLE, PLACE or VIRTUAL_LINE.
    type: Optional[Type37]
    #: The list of phone numbers of the monitored person, place or virtual line.
    numbers: Optional[list[GetUserNumberItemObject]]
    #: The location name where the call park extension is.
    location: Optional[str]
    #: The ID for the location.
    location_id: Optional[str]


class Callparkextension(ListCPCallParkExtensionObject):
    #: The location name where the call park extension is.
    location: Optional[str]
    #: The ID for the location.
    location_id: Optional[str]


class GetMonitoredElementsObject(ApiModel):
    member: Optional[Member5]
    callparkextension: Optional[Callparkextension]


class PhoneNumbers7(ApiModel):
    #: Flag to indicate if the number is primary or not.
    #: Possible values:
    primary: Optional[bool]
    #: Phone number.
    #: Possible values: 2143456789
    direct_number: Optional[str]
    #: Extension.
    #: Possible values: 1234
    extension: Optional[str]
    #: Optional ring pattern. Applicable only for alternate numbers.
    #: Possible values: NORMAL, LONG_LONG, SHORT_SHORT_LONG, SHORT_LONG_SHORT
    ring_pattern: Optional[str]


class ModifypersonsApplicationServicesSettingsBody(ApiModel):
    #: When true, indicates to ring devices for outbound Click to Dial calls.
    ring_devices_for_click_to_dial_calls_enabled: Optional[bool]
    #: When true, indicates to ring devices for inbound Group Pages.
    ring_devices_for_group_page_enabled: Optional[bool]
    #: When true, indicates to ring devices for Call Park recalled.
    ring_devices_for_call_park_enabled: Optional[bool]
    #: Indicates that the browser Webex Calling application is enabled for use.
    browser_client_enabled: Optional[bool]
    #: Indicates that the desktop Webex Calling application is enabled for use.
    desktop_client_enabled: Optional[bool]
    #: Indicates that the tablet Webex Calling application is enabled for use.
    tablet_client_enabled: Optional[bool]
    #: Indicates that the mobile Webex Calling application is enabled for use.
    mobile_client_enabled: Optional[bool]


class MonitoredPersonObject(CoHosts):
    #: Unique identifier of the person.
    id: Optional[str]
    #: Last name of the person.
    last_name: Optional[str]
    #: First name of the person.
    first_name: Optional[str]
    #: Type usually indicates PEOPLE, PLACE or VIRTUAL_LINE. Push-to-Talk and Privacy features only supports PEOPLE.
    type: Optional[Type37]
    #: List of phone numbers of the person.
    numbers: Optional[list[GetUserNumberItemObject]]


class Type63(str, Enum):
    #: Indicates the feature is not enabled.
    unassigned = 'UNASSIGNED'
    #: Indicates the feature is enabled and the person is an Executive.
    executive = 'EXECUTIVE'
    #: Indicates the feature is enabled and the person is an Executive Assistant.
    executive_assistant = 'EXECUTIVE_ASSISTANT'


class MonitoredMemberObject(CoHosts):
    #: Unique identifier of the person, workspace or virtual line to be monitored.
    id: Optional[str]
    #: Last name of the monitored person, workspace or virtual line.
    last_name: Optional[str]
    #: First name of the monitored person, workspace or virtual line.
    first_name: Optional[str]
    #: Indicates whether type is person, workspace or virtual line.
    type: Optional[Type37]
    #: List of phone numbers of the monitored person, workspace or virtual line.
    numbers: Optional[list[GetUserNumberItemObject]]


class PushToTalkConnectionType(ApiModel):
    #: Push-to-Talk initiators can chat with this person but only in one direction. The person you enable Push-to-Talk
    #: for cannot respond.
    one_way: Optional[str]
    #: Push-to-Talk initiators can chat with this person in a two-way conversation. The person you enable Push-to-Talk
    #: for can respond.
    two_way: Optional[str]


class PushToTalkAccessType(ApiModel):
    #: List of people that are allowed to use the Push-to-Talk feature to interact with the person being configured.
    allow_members: Optional[str]
    #: List of people that are disallowed to interact using the Push-to-Talk feature with the person being configured.
    block_members: Optional[str]


class ExternalTransfer(str, Enum):
    #: Allow transfer and forward for all external calls including those which were transferred.
    allow_all_external = 'ALLOW_ALL_EXTERNAL'
    #: Only allow transferred calls to be transferred or forwarded and disallow transfer of other external calls.
    allow_only_transferred_external = 'ALLOW_ONLY_TRANSFERRED_EXTERNAL'
    #: Block all external calls from being transferred or forwarded.
    block_all_external = 'BLOCK_ALL_EXTERNAL'


class ReadIncomingPermissionSettingsForPersonResponse(ApiModel):
    #: When true, indicates that this person uses the specified calling permissions for receiving inbound calls rather
    #: than the organizational defaults.
    use_custom_enabled: Optional[bool]
    #: Specifies the transfer behavior for incoming, external calls.
    external_transfer: Optional[ExternalTransfer]
    #: Internal calls are allowed to be received.
    internal_calls_enabled: Optional[bool]
    #: Collect calls are allowed to be received.
    collect_calls_enabled: Optional[bool]


class CallingPermissions(ApiModel):
    #: Designates the action to be taken for each call type and if transferring the call type is allowed.
    #: Possible values: INTERNAL_CALL, TOLL_FREE, INTERNATIONAL, OPERATOR_ASSISTED, CHARGEABLE_DIRECTORY_ASSISTED,
    #: SPECIAL_SERVICES_I, SPECIAL_SERVICES_II, PREMIUM_SERVICES_I, PREMIUM_SERVICES_II, NATIONAL
    call_type: Optional[str]
    #: Action on the given callType.
    #: Possible values: ALLOW, BLOCK, AUTH_CODE, TRANSFER_NUMBER_1, TRANSFER_NUMBER_2, TRANSFER_NUMBER_3
    action: Optional[str]
    #: Allow the person to transfer or forward a call of the specified call type.
    #: Possible values:
    transfer_enabled: Optional[bool]


class RetrievepersonsOutgoingCallingPermissionsSettingsResponse(ApiModel):
    #: When true, indicates that this user uses the specified calling permissions when placing outbound calls.
    use_custom_enabled: Optional[bool]
    #: Specifies the outbound calling permissions settings.
    calling_permissions: Optional[list[CallingPermissions]]


class PhoneNumber(ApiModel):
    #: If true marks the phone number as primary.
    primary: Optional[bool]
    #: Either 'ADD' to add phone numbers or 'DELETE' to remove phone numbers.
    action: Optional[DialPatternAction]
    #: Phone numbers that are assigned.
    direct_number: Optional[str]
    #: Extension that is assigned.
    extension: Optional[str]
    #: Ring Pattern of this number.
    ring_pattern: Optional[RingPattern]


class CallQueueObject(ListCPCallParkExtensionObject):
    #: When not null, indicates the Call Queue's phone number.
    phone_number: Optional[str]


class SearchSharedLineAppearanceMembersBody(GetDetailsForCallParkExtensionResponse):
    #: Number of records per page.
    max: Optional[int]
    #: Page number.
    start: Optional[int]
    #: Location ID for the user.
    location: Optional[str]
    #: Search for users with numbers that match the query.
    number: Optional[str]
    #: Sort by first name (fname) or last name (lname).
    order: Optional[str]


class SearchSharedLineAppearanceMembersResponse(ApiModel):
    members: Optional[list[AvailableSharedLineMemberItem]]


class GetSharedLineAppearanceMembersResponse(ApiModel):
    #: Model name of device.
    model: Optional[str]
    #: List of members.
    members: Optional[list[GetSharedLineMemberItem]]
    #: Maximum number of device ports.
    max_line_count: Optional[int]


class PutSharedLineAppearanceMembersBody(ApiModel):
    members: Optional[list[PutSharedLineMemberItem]]


class ReadPersonsCallingBehaviorResponse(ConfigurepersonsCallingBehaviorBody):
    #: The effective Calling Behavior setting for the person, will be the organization's default Calling Behavior if
    #: the user's behaviorType is set to null.
    effective_behavior_type: Optional[EffectiveBehaviorType]


class GetUserDevicesResponse(ApiModel):
    #: Array of devices available to person.
    devices: Optional[list[Devices]]
    #: Maximum number of devices a person can be assigned to.
    max_device_count: Optional[int]


class ReadCallRecordingSettingsForPersonResponse(ConfigureCallRecordingSettingsForPersonBody):
    #: Name of the service provider providing call recording service.
    service_provider: Optional[str]
    #: Group utilized by the service provider providing call recording service.
    external_group: Optional[str]
    #: Unique person identifier utilized by the service provider providing call recording service.
    external_identifier: Optional[str]


class ReadCallerIDSettingsForPersonResponse(ConfigureCallerIDSettingsForPersonBody):
    #: Allowed types for the selected field.
    types: Optional[list[CallerIdSelectedType]]
    #: Direct number which will be shown if DIRECT_LINE is selected.
    direct_number: Optional[str]
    #: Extension number which will be shown if DIRECT_LINE is selected.
    extension_number: Optional[str]
    #: Location number which will be shown if LOCATION_NUMBER is selected.
    location_number: Optional[str]
    #: Mobile number which will be shown if MOBILE_NUMBER is selected.
    mobile_number: Optional[str]
    #: Flag to indicate if the location number is toll-free number.
    toll_free_location_number: Optional[bool]
    #: Location's caller ID.
    location_external_caller_id_name: Optional[str]


class ListOfSchedulesForPersonResponse(ApiModel):
    #: Indicates a list of schedules.
    schedules: Optional[list[ScheduleShortDetails]]


class CreateScheduleForPersonResponse(ApiModel):
    #: Identifier for a schedule.
    id: Optional[str]


class GetScheduleDetailsResponse(ScheduleShortDetails):
    #: Indicates a list of events.
    events: Optional[list[EventLongDetails]]


class UpdateScheduleBody1(CreateScheduleForPersonBody):
    #: New name for the schedule.
    new_name: Optional[str]


class UpdateScheduleResponse1(ApiModel):
    #: Identifier for a schedule.
    id: Optional[str]


class FetchEventForpersonsScheduleResponse(EventLongDetails):
    #: Identifier for a event.
    id: Optional[str]


class AddNewEventForPersonsScheduleResponse(ApiModel):
    #: Identifier for a event.
    id: Optional[str]


class UpdateEventForpersonsScheduleBody(EventLongDetails):
    #: New name for the event.
    new_name: Optional[str]


class UpdateEventForpersonsScheduleResponse(ApiModel):
    #: Identifier for a event.
    id: Optional[str]


class ReadCallWaitingSettingsForPersonResponse(ApiModel):
    #: true if the Call Waiting feature is enabled.
    enabled: Optional[bool]


class ConfigureCallWaitingSettingsForPersonBody(ApiModel):
    #: true if the Call Waiting feature is enabled.
    enabled: Optional[bool]


class RetrievepersonsMonitoringSettingsResponse(ApiModel):
    #: Call park notification is enabled or disabled.
    call_park_notification_enabled: Optional[bool]
    #: Settings of monitored elements which can be person, place, virtual line or call park extension.
    monitored_elements: Optional[list[GetMonitoredElementsObject]]


class ModifypersonsMonitoringSettingsBody(ApiModel):
    #: Enable or disable call park notification.
    enable_call_park_notification: Optional[bool]
    #: Identifiers of monitored elements whose monitoring settings will be modified.
    #: Possible values: Y2lzY29zcGFyazovL3VzL1BFT1BMRS85OWNlZjRmYS03YTM5LTQ1ZDItOTNmNi1jNjA5YTRiMjgzODY
    monitored_elements: Optional[list[str]]


class GetListOfPhoneNumbersForPersonResponse(ApiModel):
    #: Enable/disable a distinctive ring pattern that identifies calls coming from a specific phone number.
    distinctive_ring_enabled: Optional[bool]
    #: Information about the number.
    phone_numbers: Optional[list[PhoneNumbers7]]


class RetrievepersonsApplicationServicesSettingsResponse(ModifypersonsApplicationServicesSettingsBody):
    #: Device ID of WebRTC client. Returns only if browserClientEnabled is true.
    browser_client_id: Optional[str]
    #: Device ID of Desktop client. Returns only if desktopClientEnabled is true.
    desktop_client_id: Optional[str]
    #: Number of available device licenses for assigning devices/apps.
    available_line_count: Optional[int]


class GetpersonsPrivacySettingsResponse(ApiModel):
    #: When true auto attendant extension dialing will be enabled.
    aa_extension_dialing_enabled: Optional[bool]
    #: When true auto attendant dailing by first or last name will be enabled.
    aa_naming_dialing_enabled: Optional[bool]
    #: When true phone status directory privacy will be enabled.
    enable_phone_status_directory_privacy: Optional[bool]
    #: List of people that are being monitored.
    monitoring_agents: Optional[list[MonitoredPersonObject]]


class ConfigurepersonsPrivacySettingsBody(ApiModel):
    #: When true auto attendant extension dialing is enabled.
    aa_extension_dialing_enabled: Optional[bool]
    #: When true auto attendant dailing by first or last name is enabled.
    aa_naming_dialing_enabled: Optional[bool]
    #: When true phone status directory privacy is enabled.
    enable_phone_status_directory_privacy: Optional[bool]
    #: List of monitoring person IDs.
    monitoring_agents: Optional[list[str]]


class RetrieveExecutiveAssistantSettingsForPersonResponse(ApiModel):
    #: Indicates the Executive Assistant type.
    type: Optional[Type63]


class ModifyExecutiveAssistantSettingsForPersonBody(ApiModel):
    #: executive assistant type
    type: Optional[Type63]


class ReadReceptionistClientSettingsForPersonResponse(ApiModel):
    #: Set to true to enable the Receptionist Client feature.
    reception_enabled: Optional[bool]
    #: List of people, workspaces or virtual lines to monitor.
    monitored_members: Optional[list[MonitoredMemberObject]]


class ConfigureReceptionistClientSettingsForPersonBody(ApiModel):
    #: true if the Receptionist Client feature is enabled.
    reception_enabled: Optional[bool]
    #: List of members' unique identifiers to monitor.
    #: Possible values: Y2lzY29zcGFyazovL3VzL1BFT1BMRS82MWU3MDlkNy1hM2IxLTQ2MDctOTBiOC04NmE5MDgxYWFkNmE
    monitored_members: Optional[list[str]]


class ReadPushtoTalkSettingsForPersonResponse(ApiModel):
    #: Set to true to enable the Push-to-Talk feature. When enabled, a person receives a Push-to-Talk call and answers
    #: the call automatically.
    allow_auto_answer: Optional[bool]
    #: Specifies the connection type to be used.
    connection_type: Optional[PushToTalkConnectionType]
    #: Specifies the access type to be applied when evaluating the member list.
    access_type: Optional[PushToTalkAccessType]
    #: List of people that are allowed or disallowed to interact using the Push-to-Talk feature.
    members: Optional[list[MonitoredPersonObject]]


class ConfigurePushtoTalkSettingsForPersonBody(ApiModel):
    #: true if Push-to-Talk feature is enabled.
    allow_auto_answer: Optional[bool]
    #: Specifies the connection type to be used.
    connection_type: Optional[PushToTalkConnectionType]
    #: Specifies the access type to be applied when evaluating the member list.
    access_type: Optional[PushToTalkAccessType]
    #: List of people that are allowed or disallowed to interact using the Push-to-Talk feature.
    #: Possible values: Y2lzY29zcGFyazovL3VzL1BFT1BMRS82MWU3MDlkNy1hM2IxLTQ2MDctOTBiOC04NmE5MDgxYWFkNmE
    members: Optional[list[str]]


class ReadHotelingSettingsForPersonResponse(ApiModel):
    #: When true, allow this person to connect to a Hoteling host device.
    enabled: Optional[bool]


class ConfigureHotelingSettingsForPersonBody(ApiModel):
    #: When true, allow this person to connect to a Hoteling host device.
    enabled: Optional[bool]


class AssignOrUnassignNumbersTopersonBody(ApiModel):
    #: Enables a distinctive ring pattern for the person.
    enable_distinctive_ring_pattern: Optional[bool]
    #: List of phone numbers that are assigned to a person.
    phone_numbers: Optional[list[PhoneNumber]]


class RetrieveListOfCallQueueCallerIDInformationResponse(ApiModel):
    #: Indicates a list of Call Queues that the agent belongs and are available to be selected as the Caller ID for
    #: outgoing calls. It is empty when the agent's Call Queues have disabled the Call Queue outgoing phone number
    #: setting to be used as Caller ID. In the case where this setting is enabled the array will be populated.
    available_queues: Optional[list[CallQueueObject]]


class RetrieveCallQueueAgentsCallerIDInformationResponse(ApiModel):
    #: When true, indicates that this agent is using the selectedQueue for its Caller ID. When false, indicates that it
    #: is using the agent's configured Caller ID.
    queue_caller_id_enabled: Optional[bool]
    #: Indicates agent's choice of using this queue's Caller ID for outgoing calls. It is empty object when
    #: queueCallerIdEnabled is false. When queueCallerIdEnabled is true this data must be populated.
    selected_queue: Optional[CallQueueObject]


class ModifyCallQueueAgentsCallerIDInformationBody(ApiModel):
    #: When true, indicates that this agent is using the selectedQueue for its Caller ID. When false, indicates that it
    #: is using the agent's configured Caller ID.
    queue_caller_id_enabled: Optional[bool]
    #: Indicates agent's choice of using this queue's Caller ID for outgoing calls. It is empty object when
    #: queueCallerIdEnabled is false. When queueCallerIdEnabled is true this data must be populated.
    selected_queue: Optional[Role]


class WebexCallingPersonSettingsApi(ApiChild, base=''):
    """
    Not supported for Webex for Government (FedRAMP)
    Webex Calling Person Settings supports modifying Webex Calling settings for a specific person.
    Viewing People requires a full, user, or read-only administrator auth token with a scope of spark-admin:people_read
    or, for select APIs, a user auth token with spark:people_read scope can be used by a person to read their own
    settings.
    Configuring People settings requires a full or user administrator auth token with the spark-admin:people_write
    scope or, for select APIs, a user auth token with spark:people_write scope can be used by a person to update their
    own settings.
    """

    def search_shared_line_appearance_members(self, person_id: str, application_id: str, extension: str = None, name: str = None, max: int = None, start: int = None, location: str = None, number: str = None, order: str = None) -> list[AvailableSharedLineMemberItem]:
        """
        Get members available for shared-line assignment to a Webex Calling Apps Desktop device.
        This API requires a full or user administrator auth token with the spark-admin:people_read scope.

        :param person_id: A unique identifier for the person.
        :type person_id: str
        :param application_id: A unique identifier for the application.
        :type application_id: str
        :param extension: The extension for the call park extension.
        :type extension: str
        :param name: Unique name for the call park extension.
        :type name: str
        :param max: Number of records per page.
        :type max: int
        :param start: Page number.
        :type start: int
        :param location: Location ID for the user.
        :type location: str
        :param number: Search for users with numbers that match the query.
        :type number: str
        :param order: Sort by first name (fname) or last name (lname).
        :type order: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-person-settings/search-shared-line-appearance-members
        """
        body = SearchSharedLineAppearanceMembersBody()
        if extension is not None:
            body.extension = extension
        if name is not None:
            body.name = name
        if max is not None:
            body.max = max
        if start is not None:
            body.start = start
        if location is not None:
            body.location = location
        if number is not None:
            body.number = number
        if order is not None:
            body.order = order
        url = self.ep(f'telephony/config/people/{person_id}/applications/{application_id}/availableMembers')
        data = super().get(url=url, data=body.json())
        return parse_obj_as(list[AvailableSharedLineMemberItem], data["members"])

    def shared_line_appearance_members(self, person_id: str, application_id: str) -> GetSharedLineAppearanceMembersResponse:
        """
        Get primary and secondary members assigned to a shared line on a Webex Calling Apps Desktop device.
        This API requires a full or user administrator auth token with the spark-admin:people_read scope.

        :param person_id: A unique identifier for the person.
        :type person_id: str
        :param application_id: A unique identifier for the application.
        :type application_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-person-settings/get-shared-line-appearance-members
        """
        url = self.ep(f'telephony/config/people/{person_id}/applications/{application_id}/members')
        data = super().get(url=url)
        return GetSharedLineAppearanceMembersResponse.parse_obj(data)

    def put_shared_line_appearance_members(self, person_id: str, application_id: str, members: PutSharedLineMemberItem = None):
        """
        Add or modify primary and secondary users assigned to shared-lines on a Webex Calling Apps Desktop device.
        This API requires a full or user administrator auth token with the spark-admin:people_write scope.

        :param person_id: A unique identifier for the person.
        :type person_id: str
        :param application_id: A unique identifier for the application.
        :type application_id: str
        :param members: 
        :type members: PutSharedLineMemberItem

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-person-settings/put-shared-line-appearance-members
        """
        body = PutSharedLineAppearanceMembersBody()
        if members is not None:
            body.members = members
        url = self.ep(f'telephony/config/people/{person_id}/applications/{application_id}/members')
        super().put(url=url, data=body.json())
        return

    def read_persons_calling_behavior(self, person_id: str, org_id: str = None) -> ReadPersonsCallingBehaviorResponse:
        """
        Retrieves the calling behavior and UC Manager Profile settings for the person which includes overall calling
        behavior and calling UC Manager Profile ID.
        Webex Calling Behavior controls which Webex telephony application and which UC Manager Profile is to be used
        for a person.
        An organization has an organization-wide default Calling Behavior that may be overridden for individual
        persons.
        UC Manager Profiles are applicable if your organization uses Jabber in Team Messaging mode or Calling in Webex
        (Unified CM).
        The UC Manager Profile also has an organization-wide default and may be overridden for individual persons.
        This API requires a full, user, or read-only administrator auth token with a scope of spark-admin:people_read.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-person-settings/read-person's-calling-behavior
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'people/{person_id}/features/callingBehavior')
        data = super().get(url=url, params=params)
        return ReadPersonsCallingBehaviorResponse.parse_obj(data)

    def configurepersons_calling_behavior(self, person_id: str, org_id: str = None, behavior_type: BehaviorType = None, profile_id: str = None):
        """
        Modifies the calling behavior settings for the person which includes calling behavior and UC Manager Profile
        ID.
        Webex Calling Behavior controls which Webex telephony application and which UC Manager Profile is to be used
        for a person.
        An organization has an organization-wide default Calling Behavior that may be overridden for individual
        persons.
        UC Manager Profiles are applicable if your organization uses Jabber in Team Messaging mode or Calling in Webex
        (Unified CM).
        The UC Manager Profile also has an organization-wide default and may be overridden for individual persons.
        This API requires a full or user administrator auth token with the spark-admin:people_write scope.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :param behavior_type: The new Calling Behavior setting for the person (case-insensitive). If null, the
            effective Calling Behavior will be the Organization's current default.
        :type behavior_type: BehaviorType
        :param profile_id: The UC Manager Profile ID. Specifying null results in the organizational default being
            applied.
        :type profile_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-person-settings/configure-a-person's-calling-behavior
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = ConfigurepersonsCallingBehaviorBody()
        if behavior_type is not None:
            body.behavior_type = behavior_type
        if profile_id is not None:
            body.profile_id = profile_id
        url = self.ep(f'people/{person_id}/features/callingBehavior')
        super().put(url=url, params=params, data=body.json())
        return

    def read_barge_in_for_person(self, person_id: str, org_id: str = None) -> ReadBargeInSettingsForPersonResponse:
        """
        Retrieve a person's Barge In settings.
        The Barge In feature enables you to use a Feature Access Code (FAC) to answer a call that was directed to
        another subscriber, or barge-in on the call if it was already answered. Barge In can be used across locations.
        This API requires a full, user, or read-only administrator auth token with a scope of spark-admin:people_read
        or a user auth token with spark:people_read scope can be used by a person to read their own settings.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-person-settings/read-barge-in-settings-for-a-person
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'people/{person_id}/features/bargeIn')
        data = super().get(url=url, params=params)
        return ReadBargeInSettingsForPersonResponse.parse_obj(data)

    def configure_barge_in_for_person(self, person_id: str, org_id: str = None, enabled: bool = None, tone_enabled: bool = None):
        """
        Configure a person's Barge In settings.
        The Barge In feature enables you to use a Feature Access Code (FAC) to answer a call that was directed to
        another subscriber, or barge-in on the call if it was already answered. Barge In can be used across locations.
        This API requires a full or user administrator auth token with the spark-admin:people_write scope or a user
        auth token with spark:people_write scope can be used by a person to update their own settings.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :param enabled: Indicates if the Barge In feature is enabled.
        :type enabled: bool
        :param tone_enabled: Indicates that a stutter dial tone will be played when a person is barging in on the
            active call.
        :type tone_enabled: bool

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-person-settings/configure-barge-in-settings-for-a-person
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = ReadBargeInSettingsForPersonResponse()
        if enabled is not None:
            body.enabled = enabled
        if tone_enabled is not None:
            body.tone_enabled = tone_enabled
        url = self.ep(f'people/{person_id}/features/bargeIn')
        super().put(url=url, params=params, data=body.json())
        return

    def read_forwarding_for_person(self, person_id: str, org_id: str = None) -> ReadForwardingSettingsForPersonResponse:
        """
        Retrieve a person's Call Forwarding settings.
        Three types of call forwarding are supported:
        In addition, the Business Continuity feature will send calls to a destination of your choice if your phone is
        not connected to the network for any reason, such as a power outage, failed Internet connection, or wiring
        problem.
        This API requires a full, user, or read-only administrator auth token with a scope of spark-admin:people_read
        or a user auth token with spark:people_read scope can be used by a person to read their own settings.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-person-settings/read-forwarding-settings-for-a-person
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'people/{person_id}/features/callForwarding')
        data = super().get(url=url, params=params)
        return ReadForwardingSettingsForPersonResponse.parse_obj(data)

    def configure_call_forwarding_for_person(self, person_id: str, org_id: str = None, call_forwarding: CallForwarding4 = None, business_continuity: BusinessContinuity = None):
        """
        Configure a person's Call Forwarding settings.
        Three types of call forwarding are supported:
        In addition, the Business Continuity feature will send calls to a destination of your choice if your phone is
        not connected to the network for any reason, such as a power outage, failed Internet connection, or wiring
        problem.
        This API requires a full or user administrator auth token with the spark-admin:people_write scope or a user
        auth token with spark:people_write scope can be used by a person to update their settings.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :param call_forwarding: Settings related to "Always", "Busy", and "No Answer" call forwarding.
        :type call_forwarding: CallForwarding4
        :param business_continuity: Settings for sending calls to a destination of your choice if your phone is not
            connected to the network for any reason, such as power outage, failed Internet connection, or wiring
            problem.
        :type business_continuity: BusinessContinuity

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-person-settings/configure-call-forwarding-settings-for-a-person
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = ReadForwardingSettingsForPersonResponse()
        if call_forwarding is not None:
            body.call_forwarding = call_forwarding
        if business_continuity is not None:
            body.business_continuity = business_continuity
        url = self.ep(f'people/{person_id}/features/callForwarding')
        super().put(url=url, params=params, data=body.json())
        return

    def user_devices(self, person_id: str, org_id: str = None) -> GetUserDevicesResponse:
        """
        Get all devices for a person.
        This requires a full or read-only administrator auth token with a scope of spark-admin:telephony_config_read.

        :param person_id: Person for whom to retrieve devices.
        :type person_id: str
        :param org_id: Organization to which the person belongs.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-person-settings/get-user-devices
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'telephony/config/people/{person_id}/devices')
        data = super().get(url=url, params=params)
        return GetUserDevicesResponse.parse_obj(data)

    def read_call_intercept_for_person(self, person_id: str, org_id: str = None) -> GetLocationInterceptResponse:
        """
        Retrieves Person's Call Intercept settings.
        The intercept feature gracefully takes a person's phone out of service, while providing callers with
        informative announcements and alternative routing options. Depending on the service configuration, none, some,
        or all incoming calls to the specified person are intercepted. Also depending on the service configuration,
        outgoing calls are intercepted or rerouted to another location.
        This API requires a full, user, or read-only administrator auth token with a scope of spark-admin:people_read.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-person-settings/read-call-intercept-settings-for-a-person
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'people/{person_id}/features/intercept')
        data = super().get(url=url, params=params)
        return GetLocationInterceptResponse.parse_obj(data)

    def configure_call_intercept_for_person(self, person_id: str, org_id: str = None, enabled: bool = None, incoming: Incoming = None, outgoing: Outgoing = None):
        """
        Configures a person's Call Intercept settings.
        The intercept feature gracefully takes a person's phone out of service, while providing callers with
        informative announcements and alternative routing options. Depending on the service configuration, none, some,
        or all incoming calls to the specified person are intercepted. Also depending on the service configuration,
        outgoing calls are intercepted or rerouted to another location.
        This API requires a full or user administrator auth token with the spark-admin:people_write scope.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :param enabled: Enable/disable location intercept. Enable this feature to override any Location's Call
            Intercept settings that person configures.
        :type enabled: bool
        :param incoming: Inbound call details.
        :type incoming: Incoming
        :param outgoing: Outbound Call details
        :type outgoing: Outgoing

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-person-settings/configure-call-intercept-settings-for-a-person
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = GetLocationInterceptResponse()
        if enabled is not None:
            body.enabled = enabled
        if incoming is not None:
            body.incoming = incoming
        if outgoing is not None:
            body.outgoing = outgoing
        url = self.ep(f'people/{person_id}/features/intercept')
        super().put(url=url, params=params, data=body.json())
        return

    def configure_call_intercept_greeting_for_person(self, person_id: str, org_id: str = None):
        """
        Configure a person's Call Intercept Greeting by uploading a Waveform Audio File Format, .wav, encoded audio
        file.
        Your request will need to be a multipart/form-data request rather than JSON, using the audio/wav Content-Type.
        This API requires a full or user administrator auth token with the spark-admin:people_write scope or a user
        auth token with spark:people_write scope can be used by a person to update their settings.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-person-settings/configure-call-intercept-greeting-for-a-person
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'people/{person_id}/features/intercept/actions/announcementUpload/invoke')
        super().post(url=url, params=params)
        return

    def read_call_recording_for_person(self, person_id: str, org_id: str = None) -> ReadCallRecordingSettingsForPersonResponse:
        """
        Retrieve a person's Call Recording settings.
        The Call Recording feature provides a hosted mechanism to record the calls placed and received on the Carrier
        platform for replay and archival. This feature is helpful for quality assurance, security, training, and more.
        This API requires a full or user administrator auth token with the spark-admin:people_write scope.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-person-settings/read-call-recording-settings-for-a-person
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'people/{person_id}/features/callRecording')
        data = super().get(url=url, params=params)
        return ReadCallRecordingSettingsForPersonResponse.parse_obj(data)

    def configure_call_recording_for_person(self, person_id: str, org_id: str = None, enabled: bool = None, record: Record = None, record_voicemail_enabled: bool = None, start_stop_announcement_enabled: bool = None, notification: Notification = None, repeat: Repeat = None):
        """
        Configure a person's Call Recording settings.
        The Call Recording feature provides a hosted mechanism to record the calls placed and received on the Carrier
        platform for replay and archival. This feature is helpful for quality assurance, security, training, and more.
        This API requires a full or user administrator auth token with the spark-admin:people_write scope.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :param enabled: true if call recording is enabled.
        :type enabled: bool
        :param record: Call recording scenario.
        :type record: Record
        :param record_voicemail_enabled: When true, voicemail messages are also recorded.
        :type record_voicemail_enabled: bool
        :param start_stop_announcement_enabled: When enabled, an announcement is played when call recording starts and
            an announcement is played when call recording ends.
        :type start_stop_announcement_enabled: bool
        :param notification: Pause/resume notification settings.
        :type notification: Notification
        :param repeat: Beep sound plays periodically.
        :type repeat: Repeat

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-person-settings/configure-call-recording-settings-for-a-person
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = ConfigureCallRecordingSettingsForPersonBody()
        if enabled is not None:
            body.enabled = enabled
        if record is not None:
            body.record = record
        if record_voicemail_enabled is not None:
            body.record_voicemail_enabled = record_voicemail_enabled
        if start_stop_announcement_enabled is not None:
            body.start_stop_announcement_enabled = start_stop_announcement_enabled
        if notification is not None:
            body.notification = notification
        if repeat is not None:
            body.repeat = repeat
        url = self.ep(f'people/{person_id}/features/callRecording')
        super().put(url=url, params=params, data=body.json())
        return

    def read_caller_id_for_person(self, person_id: str, org_id: str = None) -> ReadCallerIDSettingsForPersonResponse:
        """
        Retrieve a person's Caller ID settings.
        Caller ID settings control how a person's information is displayed when making outgoing calls.
        This API requires a full, user, or read-only administrator auth token with a scope of spark-admin:people_read.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-person-settings/read-caller-id-settings-for-a-person
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'people/{person_id}/features/callerId')
        data = super().get(url=url, params=params)
        return ReadCallerIDSettingsForPersonResponse.parse_obj(data)

    def configure_caller_id_for_person(self, person_id: str, org_id: str = None, selected: CallerIdSelectedType = None, custom_number: str = None, first_name: str = None, last_name: str = None, block_in_forward_calls_enabled: bool = None, external_caller_id_name_policy: ExternalCallerIdNamePolicy = None, custom_external_caller_id_name: str = None):
        """
        Configure a person's Caller ID settings.
        Caller ID settings control how a person's information is displayed when making outgoing calls.
        This API requires a full or user administrator auth token with the spark-admin:people_write scope.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :param selected: Which type of outgoing Caller ID will be used. Possible values: DIRECT_LINE
        :type selected: CallerIdSelectedType
        :param custom_number: This value must be an assigned number from the person's location.
        :type custom_number: str
        :param first_name: Person's Caller ID first name. Characters of %, +, ``, " and Unicode characters are not
            allowed.
        :type first_name: str
        :param last_name: Person's Caller ID last name. Characters of %, +, ``, " and Unicode characters are not
            allowed.
        :type last_name: str
        :param block_in_forward_calls_enabled: true if person's identity has to be blocked when receiving a transferred
            or forwarded call.
        :type block_in_forward_calls_enabled: bool
        :param external_caller_id_name_policy: Designates which type of External Caller Id Name policy is used. Default
            is DIRECT_LINE.
        :type external_caller_id_name_policy: ExternalCallerIdNamePolicy
        :param custom_external_caller_id_name: Person's custom External Caller ID last name. Characters of %, +, ``, "
            and Unicode characters are not allowed.
        :type custom_external_caller_id_name: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-person-settings/configure-caller-id-settings-for-a-person
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = ConfigureCallerIDSettingsForPersonBody()
        if selected is not None:
            body.selected = selected
        if custom_number is not None:
            body.custom_number = custom_number
        if first_name is not None:
            body.first_name = first_name
        if last_name is not None:
            body.last_name = last_name
        if block_in_forward_calls_enabled is not None:
            body.block_in_forward_calls_enabled = block_in_forward_calls_enabled
        if external_caller_id_name_policy is not None:
            body.external_caller_id_name_policy = external_caller_id_name_policy
        if custom_external_caller_id_name is not None:
            body.custom_external_caller_id_name = custom_external_caller_id_name
        url = self.ep(f'people/{person_id}/features/callerId')
        super().put(url=url, params=params, data=body.json())
        return

    def read_do_not_disturb_for_person(self, person_id: str, org_id: str = None) -> ReadDoNotDisturbSettingsForPersonResponse:
        """
        Retrieve a person's Do Not Disturb settings.
        When enabled, this feature will give all incoming calls the busy treatment. Optionally, you can enable a Ring
        Reminder to play a brief tone on your desktop phone when you receive incoming calls.
        This API requires a full, user, or read-only administrator auth token with a scope of spark-admin:people_read
        or a user auth token with spark:people_read scope can be used by a person to read their settings.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-person-settings/read-do-not-disturb-settings-for-a-person
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'people/{person_id}/features/doNotDisturb')
        data = super().get(url=url, params=params)
        return ReadDoNotDisturbSettingsForPersonResponse.parse_obj(data)

    def configure_do_not_disturb_for_person(self, person_id: str, org_id: str = None, enabled: bool = None, ring_splash_enabled: bool = None):
        """
        Configure a person's Do Not Disturb settings.
        When enabled, this feature will give all incoming calls the busy treatment. Optionally, you can enable a Ring
        Reminder to play a brief tone on your desktop phone when you receive incoming calls.
        This API requires a full or user administrator auth token with the spark-admin:people_write scope or a user
        auth token with spark:people_write scope can be used by a person to update their settings.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :param enabled: true if the Do Not Disturb feature is enabled.
        :type enabled: bool
        :param ring_splash_enabled: Enables a Ring Reminder to play a brief tone on your desktop phone when you receive
            incoming calls.
        :type ring_splash_enabled: bool

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-person-settings/configure-do-not-disturb-settings-for-a-person
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = ReadDoNotDisturbSettingsForPersonResponse()
        if enabled is not None:
            body.enabled = enabled
        if ring_splash_enabled is not None:
            body.ring_splash_enabled = ring_splash_enabled
        url = self.ep(f'people/{person_id}/features/doNotDisturb')
        super().put(url=url, params=params, data=body.json())
        return

    def read_voicemail_for_person(self, person_id: str, org_id: str = None) -> ReadVoicemailSettingsForPersonResponse:
        """
        Retrieve a person's Voicemail settings.
        The voicemail feature transfers callers to voicemail based on your settings. You can then retrieve voice
        messages via Voicemail. Voicemail audio is sent in Waveform Audio File Format, .wav, format.
        Optionally, notifications can be sent to a mobile phone via text or email. These notifications will not include
        the voicemail files.
        This API requires a full, user, or read-only administrator auth token with a scope of spark-admin:people_read
        or a user auth token with spark:people_read scope can be used by a person to read their settings.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-person-settings/read-voicemail-settings-for-a-person
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'people/{person_id}/features/voicemail')
        data = super().get(url=url, params=params)
        return ReadVoicemailSettingsForPersonResponse.parse_obj(data)

    def configure_voicemail_for_person(self, person_id: str, org_id: str = None, enabled: bool = None, send_all_calls: SendAllCalls = None, send_busy_calls: SendBusyCalls = None, send_unanswered_calls: SendUnansweredCalls = None, notifications: NewNumber = None, transfer_to_number: NewNumber = None, email_copy_of_message: EmailCopyOfMessage = None, message_storage: MessageStorage3 = None, fax_message: FaxMessage = None):
        """
        Configure a person's Voicemail settings.
        The voicemail feature transfers callers to voicemail based on your settings. You can then retrieve voice
        messages via Voicemail. Voicemail audio is sent in Waveform Audio File Format, .wav, format.
        Optionally, notifications can be sent to a mobile phone via text or email. These notifications will not include
        the voicemail files.
        This API requires a full or user administrator auth token with the spark-admin:people_write scope or a user
        auth token with spark:people_write scope can be used by a person to update their settings.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :param enabled: Voicemail is enabled or disabled.
        :type enabled: bool
        :param send_all_calls: Settings for sending all calls to voicemail.
        :type send_all_calls: SendAllCalls
        :param send_busy_calls: Settings for sending calls to voicemail when the line is busy.
        :type send_busy_calls: SendBusyCalls
        :param send_unanswered_calls: 
        :type send_unanswered_calls: SendUnansweredCalls
        :param notifications: Settings for notifications when there are any new voicemails.
        :type notifications: NewNumber
        :param transfer_to_number: Settings for voicemail caller to transfer to a different number by pressing zero
            (0).
        :type transfer_to_number: NewNumber
        :param email_copy_of_message: Settings for sending a copy of new voicemail message audio via email.
        :type email_copy_of_message: EmailCopyOfMessage
        :param message_storage: 
        :type message_storage: MessageStorage3
        :param fax_message: 
        :type fax_message: FaxMessage

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-person-settings/configure-voicemail-settings-for-a-person
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = ReadVoicemailSettingsForPersonResponse()
        if enabled is not None:
            body.enabled = enabled
        if send_all_calls is not None:
            body.send_all_calls = send_all_calls
        if send_busy_calls is not None:
            body.send_busy_calls = send_busy_calls
        if send_unanswered_calls is not None:
            body.send_unanswered_calls = send_unanswered_calls
        if notifications is not None:
            body.notifications = notifications
        if transfer_to_number is not None:
            body.transfer_to_number = transfer_to_number
        if email_copy_of_message is not None:
            body.email_copy_of_message = email_copy_of_message
        if message_storage is not None:
            body.message_storage = message_storage
        if fax_message is not None:
            body.fax_message = fax_message
        url = self.ep(f'people/{person_id}/features/voicemail')
        super().put(url=url, params=params, data=body.json())
        return

    def configure_busy_voicemail_greeting_for_person(self, person_id: str, org_id: str = None):
        """
        Configure a person's Busy Voicemail Greeting by uploading a Waveform Audio File Format, .wav, encoded audio
        file.
        Your request will need to be a multipart/form-data request rather than JSON, using the audio/wav Content-Type.
        This API requires a full or user administrator auth token with the spark-admin:people_write scope or a user
        auth token with spark:people_write scope can be used by a person to update their settings.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-person-settings/configure-busy-voicemail-greeting-for-a-person
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'people/{person_id}/features/voicemail/actions/uploadBusyGreeting/invoke')
        super().post(url=url, params=params)
        return

    def configure_no_answer_voicemail_greeting_for_person(self, person_id: str, org_id: str = None):
        """
        Configure a person's No Answer Voicemail Greeting by uploading a Waveform Audio File Format, .wav, encoded
        audio file.
        Your request will need to be a multipart/form-data request rather than JSON, using the audio/wav Content-Type.
        This API requires a full or user administrator auth token with the spark-admin:people_write scope or a user
        auth token with spark:people_write scope can be used by a person to update their settings.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-person-settings/configure-no-answer-voicemail-greeting-for-a-person
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'people/{person_id}/features/voicemail/actions/uploadNoAnswerGreeting/invoke')
        super().post(url=url, params=params)
        return

    def list_of_schedules_for_person(self, person_id: str, org_id: str = None, name: str = None, type_: str = None, **params) -> Generator[ScheduleShortDetails, None, None]:
        """
        List schedules for a person in an organization.
        Schedules are used to support calling features and can be defined at the location or person level.
        businessHours schedules allow you to apply specific call settings at different times of the day or week by
        defining one or more events. holidays schedules define exceptions to normal business hours by defining one or
        more events.
        This API requires a full, user, or read-only administrator auth token with a scope of spark-admin:people_read.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :param name: Specifies the case insensitive substring to be matched against the schedule names. The maximum
            length is 40.
        :type name: str
        :param type_: Specifies the schedule event type to be matched on the given type.
        :type type_: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-person-settings/list-of-schedules-for-a-person
        """
        if org_id is not None:
            params['orgId'] = org_id
        if name is not None:
            params['name'] = name
        if type_ is not None:
            params['type'] = type_
        url = self.ep(f'people/{person_id}/features/schedules')
        return self.session.follow_pagination(url=url, model=ScheduleShortDetails, item_key='schedules', params=params)

    def create_schedule_for_person(self, person_id: str, name: str, type_: Type54, org_id: str = None, events: EventLongDetails = None) -> str:
        """
        Create a new schedule for a person.
        Schedules are used to support calling features and can be defined at the location or person level.
        businessHours schedules allow you to apply specific call settings at different times of the day or week by
        defining one or more events. holidays schedules define exceptions to normal business hours by defining one or
        more events.
        This API requires a full or user administrator auth token with the spark-admin:people_write scope.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param name: Name for the schedule.
        :type name: str
        :param type_: Indicates the schedule type whether businessHours or holidays.
        :type type_: Type54
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :param events: Indicates a list of events.
        :type events: EventLongDetails

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-person-settings/create-schedule-for-a-person
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = CreateScheduleForPersonBody()
        if name is not None:
            body.name = name
        if type_ is not None:
            body.type_ = type_
        if events is not None:
            body.events = events
        url = self.ep(f'people/{person_id}/features/schedules')
        data = super().post(url=url, params=params, data=body.json())
        return data["id"]

    def schedule_details(self, person_id: str, schedule_type: Type54, schedule_id: str, org_id: str = None) -> GetScheduleDetailsResponse:
        """
        Retrieve a schedule by its schedule ID.
        Schedules are used to support calling features and can be defined at the location or person level.
        businessHours schedules allow you to apply specific call settings at different times of the day or week by
        defining one or more events. holidays schedules define exceptions to normal business hours by defining one or
        more events.
        This API requires a full, user, or read-only administrator auth token with a scope of spark-admin:people_read.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param schedule_type: Type of schedule, either businessHours or holidays.
        :type schedule_type: Type54
        :param schedule_id: Unique identifier for the schedule.
        :type schedule_id: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-person-settings/get-a-schedule-details
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'people/{person_id}/features/schedules/{schedule_type}/{schedule_id}')
        data = super().get(url=url, params=params)
        return GetScheduleDetailsResponse.parse_obj(data)

    def update_schedule(self, person_id: str, schedule_type: Type54, schedule_id: str, name: str, type_: Type54, new_name: str, org_id: str = None, events: EventLongDetails = None) -> str:
        """
        Modify a schedule by its schedule ID.
        Schedules are used to support calling features and can be defined at the location or person level.
        businessHours schedules allow you to apply specific call settings at different times of the day or week by
        defining one or more events. holidays schedules define exceptions to normal business hours by defining one or
        more events.
        This API requires a full or user administrator auth token with the spark-admin:people_write scope.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param schedule_type: Type of schedule, either businessHours or holidays.
        :type schedule_type: Type54
        :param schedule_id: Unique identifier for the schedule.
        :type schedule_id: str
        :param name: Name for the schedule.
        :type name: str
        :param type_: Indicates the schedule type whether businessHours or holidays.
        :type type_: Type54
        :param new_name: New name for the schedule.
        :type new_name: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :param events: Indicates a list of events.
        :type events: EventLongDetails

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-person-settings/update-a-schedule
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = UpdateScheduleBody1()
        if name is not None:
            body.name = name
        if type_ is not None:
            body.type_ = type_
        if new_name is not None:
            body.new_name = new_name
        if events is not None:
            body.events = events
        url = self.ep(f'people/{person_id}/features/schedules/{schedule_type}/{schedule_id}')
        data = super().put(url=url, params=params, data=body.json())
        return data["id"]

    def delete_schedule(self, person_id: str, schedule_type: Type54, schedule_id: str, org_id: str = None):
        """
        Delete a schedule by its schedule ID.
        Schedules are used to support calling features and can be defined at the location or person level.
        businessHours schedules allow you to apply specific call settings at different times of the day or week by
        defining one or more events. holidays schedules define exceptions to normal business hours by defining one or
        more events.
        This API requires a full or user administrator auth token with the spark-admin:people_write scope.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param schedule_type: Type of schedule, either businessHours or holidays.
        :type schedule_type: Type54
        :param schedule_id: Unique identifier for the schedule.
        :type schedule_id: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-person-settings/delete-a-schedule
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'people/{person_id}/features/schedules/{schedule_type}/{schedule_id}')
        super().delete(url=url, params=params)
        return

    def fetch_event_forpersons_schedule(self, person_id: str, schedule_type: Type54, schedule_id: str, event_id: str, org_id: str = None) -> FetchEventForpersonsScheduleResponse:
        """
        People can use shared location schedules or define personal schedules containing events.
        businessHours schedules allow you to apply specific call settings at different times of the day or week by
        defining one or more events. holidays schedules define exceptions to normal business hours by defining one or
        more events.
        This API requires a full, user, or read-only administrator auth token with a scope of spark-admin:people_read.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param schedule_type: Type of schedule, either businessHours or holidays.
        :type schedule_type: Type54
        :param schedule_id: Unique identifier for the schedule.
        :type schedule_id: str
        :param event_id: Unique identifier for the event.
        :type event_id: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-person-settings/fetch-event-for-a-person's-schedule
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'people/{person_id}/features/schedules/{schedule_type}/{schedule_id}/events/{event_id}')
        data = super().get(url=url, params=params)
        return FetchEventForpersonsScheduleResponse.parse_obj(data)

    def add_new_event_for_persons_schedule(self, person_id: str, schedule_type: Type54, schedule_id: str, name: str, start_date: str, end_date: str, start_time: str, end_time: str, org_id: str = None, all_day_enabled: bool = None, recurrence: Recurrence = None) -> str:
        """
        People can use shared location schedules or define personal schedules containing events.
        businessHours schedules allow you to apply specific call settings at different times of the day or week by
        defining one or more events. holidays schedules define exceptions to normal business hours by defining one or
        more events.
        This API requires a full or user administrator auth token with the spark-admin:people_write scope.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param schedule_type: Type of schedule, either businessHours or holidays.
        :type schedule_type: Type54
        :param schedule_id: Unique identifier for the schedule.
        :type schedule_id: str
        :param name: Name for the event.
        :type name: str
        :param start_date: Start date of the event, or first occurrence if repeating, in the format of YYYY-MM-DD. This
            field is required if the allDayEnabled field is present.
        :type start_date: str
        :param end_date: End date of the event, or first occurrence if repeating, in the format of YYYY-MM-DD. This
            field is required if the allDayEnabled field is present.
        :type end_date: str
        :param start_time: Start time of the event in the format of HH:MM (24 hours format). This field is required if
            the allDayEnabled field is false or omitted.
        :type start_time: str
        :param end_time: End time of the event in the format of HH:MM (24 hours format). This field is required if the
            allDayEnabled field is false or omitted.
        :type end_time: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :param all_day_enabled: True if it is all-day event.
        :type all_day_enabled: bool
        :param recurrence: Recurrance scheme for an event.
        :type recurrence: Recurrence

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-person-settings/add-a-new-event-for-person's-schedule
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = EventLongDetails()
        if name is not None:
            body.name = name
        if start_date is not None:
            body.start_date = start_date
        if end_date is not None:
            body.end_date = end_date
        if start_time is not None:
            body.start_time = start_time
        if end_time is not None:
            body.end_time = end_time
        if all_day_enabled is not None:
            body.all_day_enabled = all_day_enabled
        if recurrence is not None:
            body.recurrence = recurrence
        url = self.ep(f'people/{person_id}/features/schedules/{schedule_type}/{schedule_id}/events')
        data = super().post(url=url, params=params, data=body.json())
        return data["id"]

    def update_event_forpersons_schedule(self, person_id: str, schedule_type: Type54, schedule_id: str, event_id: str, name: str, start_date: str, end_date: str, start_time: str, end_time: str, new_name: str, org_id: str = None, all_day_enabled: bool = None, recurrence: Recurrence = None) -> str:
        """
        People can use shared location schedules or define personal schedules containing events.
        businessHours schedules allow you to apply specific call settings at different times of the day or week by
        defining one or more events. holidays schedules define exceptions to normal business hours by defining one or
        more events.
        This API requires a full or user administrator auth token with the spark-admin:people_write scope.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param schedule_type: Type of schedule, either businessHours or holidays.
        :type schedule_type: Type54
        :param schedule_id: Unique identifier for the schedule.
        :type schedule_id: str
        :param event_id: Unique identifier for the event.
        :type event_id: str
        :param name: Name for the event.
        :type name: str
        :param start_date: Start date of the event, or first occurrence if repeating, in the format of YYYY-MM-DD. This
            field is required if the allDayEnabled field is present.
        :type start_date: str
        :param end_date: End date of the event, or first occurrence if repeating, in the format of YYYY-MM-DD. This
            field is required if the allDayEnabled field is present.
        :type end_date: str
        :param start_time: Start time of the event in the format of HH:MM (24 hours format). This field is required if
            the allDayEnabled field is false or omitted.
        :type start_time: str
        :param end_time: End time of the event in the format of HH:MM (24 hours format). This field is required if the
            allDayEnabled field is false or omitted.
        :type end_time: str
        :param new_name: New name for the event.
        :type new_name: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :param all_day_enabled: True if it is all-day event.
        :type all_day_enabled: bool
        :param recurrence: Recurrance scheme for an event.
        :type recurrence: Recurrence

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-person-settings/update-an-event-for-a-person's-schedule
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = UpdateEventForpersonsScheduleBody()
        if name is not None:
            body.name = name
        if start_date is not None:
            body.start_date = start_date
        if end_date is not None:
            body.end_date = end_date
        if start_time is not None:
            body.start_time = start_time
        if end_time is not None:
            body.end_time = end_time
        if new_name is not None:
            body.new_name = new_name
        if all_day_enabled is not None:
            body.all_day_enabled = all_day_enabled
        if recurrence is not None:
            body.recurrence = recurrence
        url = self.ep(f'people/{person_id}/features/schedules/{schedule_type}/{schedule_id}/events/{event_id}')
        data = super().put(url=url, params=params, data=body.json())
        return data["id"]

    def delete_event_forpersons_schedule(self, person_id: str, schedule_type: Type54, schedule_id: str, event_id: str, org_id: str = None):
        """
        People can use shared location schedules or define personal schedules containing events.
        businessHours schedules allow you to apply specific call settings at different times of the day or week by
        defining one or more events. holidays schedules define exceptions to normal business hours by defining one or
        more events.
        This API requires a full or user administrator auth token with the spark-admin:people_write scope.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param schedule_type: Type of schedule, either businessHours or holidays.
        :type schedule_type: Type54
        :param schedule_id: Unique identifier for the schedule.
        :type schedule_id: str
        :param event_id: Unique identifier for the event.
        :type event_id: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-person-settings/delete-an-event-for-a-person's-schedule
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'people/{person_id}/features/schedules/{schedule_type}/{schedule_id}/events/{event_id}')
        super().delete(url=url, params=params)
        return

    def read_call_waiting_for_person(self, person_id: str, org_id: str = None) -> bool:
        """
        Retrieve a person's Call Waiting settings.
        With this feature, a person can place an active call on hold and answer an incoming call. When enabled, while
        you are on an active call, a tone alerts you of an incoming call and you can choose to answer or ignore the
        call.
        This API requires a full, user, or read-only administrator auth token with a scope of spark-admin:people_read.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-person-settings/read-call-waiting-settings-for-a-person
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'people/{person_id}/features/callWaiting')
        data = super().get(url=url, params=params)
        return data["enabled"]

    def configure_call_waiting_for_person(self, person_id: str, enabled: bool, org_id: str = None):
        """
        Configure a person's Call Waiting settings.
        With this feature, a person can place an active call on hold and answer an incoming call. When enabled, while
        you are on an active call, a tone alerts you of an incoming call and you can choose to answer or ignore the
        call.
        This API requires a full or user administrator auth token with the spark-admin:people_write scope.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param enabled: true if the Call Waiting feature is enabled.
        :type enabled: bool
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-person-settings/configure-call-waiting-settings-for-a-person
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = ConfigureCallWaitingSettingsForPersonBody()
        if enabled is not None:
            body.enabled = enabled
        url = self.ep(f'people/{person_id}/features/callWaiting')
        super().put(url=url, params=params, data=body.json())
        return

    def retrievepersons_monitoring(self, person_id: str, org_id: str = None) -> RetrievepersonsMonitoringSettingsResponse:
        """
        Retrieves the monitoring settings of the person, which shows specified people, places, virtual lines or call
        park extenions that are being monitored.
        Monitors the line status which indicates if a person, place or virtual line is on a call and if a call has been
        parked on that extension.
        This API requires a full, user, or read-only administrator auth token with a scope of spark-admin:people_read.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-person-settings/retrieve-a-person's-monitoring-settings
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'people/{person_id}/features/monitoring')
        data = super().get(url=url, params=params)
        return RetrievepersonsMonitoringSettingsResponse.parse_obj(data)

    def modifypersons_monitoring(self, person_id: str, enable_call_park_notification: bool, monitored_elements: List[str], org_id: str = None):
        """
        Modifies the monitoring settings of the person.
        Monitors the line status of specified people, places, virtual lines or call park extension. The line status
        indicates if a person, place or virtual line is on a call and if a call has been parked on that extension.
        This API requires a full or user administrator auth token with the spark-admin:people_write scope.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param enable_call_park_notification: Enable or disable call park notification.
        :type enable_call_park_notification: bool
        :param monitored_elements: Identifiers of monitored elements whose monitoring settings will be modified.
            Possible values: Y2lzY29zcGFyazovL3VzL1BFT1BMRS85OWNlZjRmYS03YTM5LTQ1ZDItOTNmNi1jNjA5YTRiMjgzODY
        :type monitored_elements: List[str]
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-person-settings/modify-a-person's-monitoring-settings
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = ModifypersonsMonitoringSettingsBody()
        if enable_call_park_notification is not None:
            body.enable_call_park_notification = enable_call_park_notification
        if monitored_elements is not None:
            body.monitored_elements = monitored_elements
        url = self.ep(f'people/{person_id}/features/monitoring')
        super().put(url=url, params=params, data=body.json())
        return

    def list_of_phone_numbers_for_person(self, person_id: str, org_id: str = None, prefer_e164_format: bool = None) -> GetListOfPhoneNumbersForPersonResponse:
        """
        Get a person's phone numbers including alternate numbers.
        A person can have one or more phone numbers and/or extensions via which they can be called.
        This API requires a full or user administrator auth token with the spark-admin:people_read scope.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :param prefer_e164_format: Return phone numbers in E.164 format.
        :type prefer_e164_format: bool

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-person-settings/get-a-list-of-phone-numbers-for-a-person
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        if prefer_e164_format is not None:
            params['preferE164Format'] = str(prefer_e164_format).lower()
        url = self.ep(f'people/{person_id}/features/numbers')
        data = super().get(url=url, params=params)
        return GetListOfPhoneNumbersForPersonResponse.parse_obj(data)

    def retrievepersons_application_services(self, person_id: str, org_id: str = None) -> RetrievepersonsApplicationServicesSettingsResponse:
        """
        Application services let you determine the ringing behavior for calls made to people in certain scenarios. You
        can also specify which devices can download the Webex Calling app.
        This API requires a full, user, or read-only administrator auth token with a scope of spark-admin:people_read.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-person-settings/retrieve-a-person's-application-services-settings
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'people/{person_id}/features/applications')
        data = super().get(url=url, params=params)
        return RetrievepersonsApplicationServicesSettingsResponse.parse_obj(data)

    def modifypersons_application_services(self, person_id: str, org_id: str = None, ring_devices_for_click_to_dial_calls_enabled: bool = None, ring_devices_for_group_page_enabled: bool = None, ring_devices_for_call_park_enabled: bool = None, browser_client_enabled: bool = None, desktop_client_enabled: bool = None, tablet_client_enabled: bool = None, mobile_client_enabled: bool = None):
        """
        Application services let you determine the ringing behavior for calls made to users in certain scenarios. You
        can also specify which devices users can download the Webex Calling app on.
        This API requires a full or user administrator auth token with the spark-admin:people_write scope.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :param ring_devices_for_click_to_dial_calls_enabled: When true, indicates to ring devices for outbound Click to
            Dial calls.
        :type ring_devices_for_click_to_dial_calls_enabled: bool
        :param ring_devices_for_group_page_enabled: When true, indicates to ring devices for inbound Group Pages.
        :type ring_devices_for_group_page_enabled: bool
        :param ring_devices_for_call_park_enabled: When true, indicates to ring devices for Call Park recalled.
        :type ring_devices_for_call_park_enabled: bool
        :param browser_client_enabled: Indicates that the browser Webex Calling application is enabled for use.
        :type browser_client_enabled: bool
        :param desktop_client_enabled: Indicates that the desktop Webex Calling application is enabled for use.
        :type desktop_client_enabled: bool
        :param tablet_client_enabled: Indicates that the tablet Webex Calling application is enabled for use.
        :type tablet_client_enabled: bool
        :param mobile_client_enabled: Indicates that the mobile Webex Calling application is enabled for use.
        :type mobile_client_enabled: bool

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-person-settings/modify-a-person's-application-services-settings
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = ModifypersonsApplicationServicesSettingsBody()
        if ring_devices_for_click_to_dial_calls_enabled is not None:
            body.ring_devices_for_click_to_dial_calls_enabled = ring_devices_for_click_to_dial_calls_enabled
        if ring_devices_for_group_page_enabled is not None:
            body.ring_devices_for_group_page_enabled = ring_devices_for_group_page_enabled
        if ring_devices_for_call_park_enabled is not None:
            body.ring_devices_for_call_park_enabled = ring_devices_for_call_park_enabled
        if browser_client_enabled is not None:
            body.browser_client_enabled = browser_client_enabled
        if desktop_client_enabled is not None:
            body.desktop_client_enabled = desktop_client_enabled
        if tablet_client_enabled is not None:
            body.tablet_client_enabled = tablet_client_enabled
        if mobile_client_enabled is not None:
            body.mobile_client_enabled = mobile_client_enabled
        url = self.ep(f'people/{person_id}/features/applications')
        super().put(url=url, params=params, data=body.json())
        return

    def getpersons_privacy(self, person_id: str, org_id: str = None) -> GetpersonsPrivacySettingsResponse:
        """
        Get a person's privacy settings for the specified person ID.
        The privacy feature enables the person's line to be monitored by others and determine if they can be reached by
        Auto Attendant services.
        This API requires a full, user, or read-only administrator auth token with a scope of spark-admin:people_read.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-person-settings/get-a-person's-privacy-settings
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'people/{person_id}/features/privacy')
        data = super().get(url=url, params=params)
        return GetpersonsPrivacySettingsResponse.parse_obj(data)

    def configurepersons_privacy(self, person_id: str, org_id: str = None, aa_extension_dialing_enabled: bool = None, aa_naming_dialing_enabled: bool = None, enable_phone_status_directory_privacy: bool = None, monitoring_agents: List[str] = None):
        """
        Configure a person's privacy settings for the specified person ID.
        The privacy feature enables the person's line to be monitored by others and determine if they can be reached by
        Auto Attendant services.
        This API requires a full or user administrator auth token with the spark-admin:people_write scope.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :param aa_extension_dialing_enabled: When true auto attendant extension dialing is enabled.
        :type aa_extension_dialing_enabled: bool
        :param aa_naming_dialing_enabled: When true auto attendant dailing by first or last name is enabled.
        :type aa_naming_dialing_enabled: bool
        :param enable_phone_status_directory_privacy: When true phone status directory privacy is enabled.
        :type enable_phone_status_directory_privacy: bool
        :param monitoring_agents: List of monitoring person IDs.
        :type monitoring_agents: List[str]

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-person-settings/configure-a-person's-privacy-settings
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = ConfigurepersonsPrivacySettingsBody()
        if aa_extension_dialing_enabled is not None:
            body.aa_extension_dialing_enabled = aa_extension_dialing_enabled
        if aa_naming_dialing_enabled is not None:
            body.aa_naming_dialing_enabled = aa_naming_dialing_enabled
        if enable_phone_status_directory_privacy is not None:
            body.enable_phone_status_directory_privacy = enable_phone_status_directory_privacy
        if monitoring_agents is not None:
            body.monitoring_agents = monitoring_agents
        url = self.ep(f'people/{person_id}/features/privacy')
        super().put(url=url, params=params, data=body.json())
        return

    def retrieve_executive_assistant_for_person(self, person_id: str, org_id: str = None) -> Type63:
        """
        Retrieve the executive assistant settings for the specified personId.
        People with the executive service enabled, can select from a pool of assistants who have been assigned the
        executive assistant service and who can answer or place calls on their behalf. Executive assistants can set the
        call forward destination and join or leave an executive's pool.
        This API requires a full, user, or read-only administrator auth token with a scope of spark-admin:people_read.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-person-settings/retrieve-executive-assistant-settings-for-a-person
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'people/{person_id}/features/executiveAssistant')
        data = super().get(url=url, params=params)
        return Type63.parse_obj(data["type"])

    def modify_executive_assistant_for_person(self, person_id: str, org_id: str = None, type_: Type63 = None):
        """
        Modify the executive assistant settings for the specified personId.
        People with the executive service enabled, can select from a pool of assistants who have been assigned the
        executive assistant service and who can answer or place calls on their behalf. Executive assistants can set the
        call forward destination and join or leave an executive's pool.
        This API requires a full or user administrator auth token with the spark-admin:people_write scope.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :param type_: executive assistant type
        :type type_: Type63

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-person-settings/modify-executive-assistant-settings-for-a-person
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = ModifyExecutiveAssistantSettingsForPersonBody()
        if type_ is not None:
            body.type_ = type_
        url = self.ep(f'people/{person_id}/features/executiveAssistant')
        super().put(url=url, params=params, data=body.json())
        return

    def read_receptionist_client_for_person(self, person_id: str, org_id: str = None) -> ReadReceptionistClientSettingsForPersonResponse:
        """
        Retrieve a person's Receptionist Client settings.
        To help support the needs of your front-office personnel, you can set up people, workspaces or virtual lines as
        telephone attendants so that they can screen all incoming calls to certain numbers within your organization.
        This API requires a full, user, or read-only administrator auth token with a scope of spark-admin:people_read.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-person-settings/read-receptionist-client-settings-for-a-person
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'people/{person_id}/features/reception')
        data = super().get(url=url, params=params)
        return ReadReceptionistClientSettingsForPersonResponse.parse_obj(data)

    def configure_receptionist_client_for_person(self, person_id: str, reception_enabled: bool, org_id: str = None, monitored_members: List[str] = None):
        """
        Configure a person's Receptionist Client settings.
        To help support the needs of your front-office personnel, you can set up people, workspaces or virtual lines as
        telephone attendants so that they can screen all incoming calls to certain numbers within your organization.
        This API requires a full or user administrator auth token with the spark-admin:people_write scope.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param reception_enabled: true if the Receptionist Client feature is enabled.
        :type reception_enabled: bool
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :param monitored_members: List of members' unique identifiers to monitor. Possible values:
            Y2lzY29zcGFyazovL3VzL1BFT1BMRS82MWU3MDlkNy1hM2IxLTQ2MDctOTBiOC04NmE5MDgxYWFkNmE
        :type monitored_members: List[str]

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-person-settings/configure-receptionist-client-settings-for-a-person
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = ConfigureReceptionistClientSettingsForPersonBody()
        if reception_enabled is not None:
            body.reception_enabled = reception_enabled
        if monitored_members is not None:
            body.monitored_members = monitored_members
        url = self.ep(f'people/{person_id}/features/reception')
        super().put(url=url, params=params, data=body.json())
        return

    def read_push_to_talk_for_person(self, person_id: str, org_id: str = None) -> ReadPushtoTalkSettingsForPersonResponse:
        """
        Retrieve a person's Push-to-Talk settings.
        Push-to-Talk allows the use of desk phones as either a one-way or two-way intercom that connects people in
        different parts of your organization.
        This API requires a full, user, or read-only administrator auth token with a scope of spark-admin:people_read.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-person-settings/read-push-to-talk-settings-for-a-person
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'people/{person_id}/features/pushToTalk')
        data = super().get(url=url, params=params)
        return ReadPushtoTalkSettingsForPersonResponse.parse_obj(data)

    def configure_push_to_talk_for_person(self, person_id: str, org_id: str = None, allow_auto_answer: bool = None, connection_type: PushToTalkConnectionType = None, access_type: PushToTalkAccessType = None, members: List[str] = None):
        """
        Configure a person's Push-to-Talk settings.
        Push-to-Talk allows the use of desk phones as either a one-way or two-way intercom that connects people in
        different parts of your organization.
        This API requires a full or user administrator auth token with the spark-admin:people_write scope.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :param allow_auto_answer: true if Push-to-Talk feature is enabled.
        :type allow_auto_answer: bool
        :param connection_type: Specifies the connection type to be used.
        :type connection_type: PushToTalkConnectionType
        :param access_type: Specifies the access type to be applied when evaluating the member list.
        :type access_type: PushToTalkAccessType
        :param members: List of people that are allowed or disallowed to interact using the Push-to-Talk feature.
            Possible values: Y2lzY29zcGFyazovL3VzL1BFT1BMRS82MWU3MDlkNy1hM2IxLTQ2MDctOTBiOC04NmE5MDgxYWFkNmE
        :type members: List[str]

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-person-settings/configure-push-to-talk-settings-for-a-person
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = ConfigurePushtoTalkSettingsForPersonBody()
        if allow_auto_answer is not None:
            body.allow_auto_answer = allow_auto_answer
        if connection_type is not None:
            body.connection_type = connection_type
        if access_type is not None:
            body.access_type = access_type
        if members is not None:
            body.members = members
        url = self.ep(f'people/{person_id}/features/pushToTalk')
        super().put(url=url, params=params, data=body.json())
        return

    def read_hoteling_for_person(self, person_id: str, org_id: str = None) -> bool:
        """
        Retrieve a person's hoteling settings.
        As an administrator, you can enable hoteling for people so that their phone profile (phone number, features,
        and calling plan) is temporarily loaded onto a shared (host) phone.
        This API requires a full, user, or read-only administrator auth token with a scope of spark-admin:people_read.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-person-settings/read-hoteling-settings-for-a-person
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'people/{person_id}/features/hoteling')
        data = super().get(url=url, params=params)
        return data["enabled"]

    def configure_hoteling_for_person(self, person_id: str, enabled: bool, org_id: str = None):
        """
        Configure a person's hoteling settings.
        As an administrator, you can enable hoteling for people so that their phone profile (phone number, features,
        and calling plan) is temporarily loaded onto a shared (host) phone.
        This API requires a full or user administrator auth token with the spark-admin:people_write scope.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param enabled: When true, allow this person to connect to a Hoteling host device.
        :type enabled: bool
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-person-settings/configure-hoteling-settings-for-a-person
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = ConfigureHotelingSettingsForPersonBody()
        if enabled is not None:
            body.enabled = enabled
        url = self.ep(f'people/{person_id}/features/hoteling')
        super().put(url=url, params=params, data=body.json())
        return

    def reset_voicemail_pin(self, person_id: str, org_id: str = None):
        """
        Reset a voicemail PIN for a person.
        The voicemail feature transfers callers to voicemail based on your settings. You can then retrieve voice
        messages via Voicemail. A voicemail PIN is used to retrieve your voicemail messages.
        This API requires a full or user administrator auth token with the spark-admin:people_write scope.
        NOTE: This API is expected to have an empty request body and Content-Type header should be set to
        application/json.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-person-settings/reset-voicemail-pin
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'people/{person_id}/features/voicemail/actions/resetPin/invoke')
        super().post(url=url, params=params)
        return

    def read_incoming_permission_for_person(self, person_id: str, org_id: str = None) -> ReadIncomingPermissionSettingsForPersonResponse:
        """
        Retrieve a person's Incoming Permission settings.
        You can change the incoming calling permissions for a person if you want them to be different from your
        organization's default.
        This API requires a full, user, or read-only administrator auth token with a scope of spark-admin:people_read.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-person-settings/read-incoming-permission-settings-for-a-person
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'people/{person_id}/features/incomingPermission')
        data = super().get(url=url, params=params)
        return ReadIncomingPermissionSettingsForPersonResponse.parse_obj(data)

    def configure_incoming_permission_for_person(self, person_id: str, org_id: str = None, use_custom_enabled: bool = None, external_transfer: ExternalTransfer = None, internal_calls_enabled: bool = None, collect_calls_enabled: bool = None):
        """
        Configure a person's Incoming Permission settings.
        You can change the incoming calling permissions for a person if you want them to be different from your
        organization's default.
        This API requires a full or user administrator auth token with the spark-admin:people_write scope.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :param use_custom_enabled: When true, indicates that this person uses the specified calling permissions for
            receiving inbound calls rather than the organizational defaults.
        :type use_custom_enabled: bool
        :param external_transfer: Specifies the transfer behavior for incoming, external calls.
        :type external_transfer: ExternalTransfer
        :param internal_calls_enabled: Internal calls are allowed to be received.
        :type internal_calls_enabled: bool
        :param collect_calls_enabled: Collect calls are allowed to be received.
        :type collect_calls_enabled: bool

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-person-settings/configure-incoming-permission-settings-for-a-person
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = ReadIncomingPermissionSettingsForPersonResponse()
        if use_custom_enabled is not None:
            body.use_custom_enabled = use_custom_enabled
        if external_transfer is not None:
            body.external_transfer = external_transfer
        if internal_calls_enabled is not None:
            body.internal_calls_enabled = internal_calls_enabled
        if collect_calls_enabled is not None:
            body.collect_calls_enabled = collect_calls_enabled
        url = self.ep(f'people/{person_id}/features/incomingPermission')
        super().put(url=url, params=params, data=body.json())
        return

    def retrievepersons_outgoing_calling_permissions(self, person_id: str, org_id: str = None) -> RetrievepersonsOutgoingCallingPermissionsSettingsResponse:
        """
        Retrieve a person's Outgoing Calling Permissions settings.
        You can change the outgoing calling permissions for a person if you want them to be different from your
        organization's default.
        This API requires a full, user, or read-only administrator auth token with a scope of spark-admin:people_read.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-person-settings/retrieve-a-person's-outgoing-calling-permissions-settings
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'people/{person_id}/features/outgoingPermission')
        data = super().get(url=url, params=params)
        return RetrievepersonsOutgoingCallingPermissionsSettingsResponse.parse_obj(data)

    def modifypersons_outgoing_calling_permissions(self, person_id: str, org_id: str = None, use_custom_enabled: bool = None, calling_permissions: CallingPermissions = None):
        """
        Modify a person's Outgoing Calling Permissions settings.
        You can change the outgoing calling permissions for a person if you want them to be different from your
        organization's default.
        This API requires a full or user administrator auth token with the spark-admin:people_write scope.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :param use_custom_enabled: When true, indicates that this user uses the specified calling permissions when
            placing outbound calls.
        :type use_custom_enabled: bool
        :param calling_permissions: Specifies the outbound calling permissions settings.
        :type calling_permissions: CallingPermissions

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-person-settings/modify-a-person's-outgoing-calling-permissions-settings
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = RetrievepersonsOutgoingCallingPermissionsSettingsResponse()
        if use_custom_enabled is not None:
            body.use_custom_enabled = use_custom_enabled
        if calling_permissions is not None:
            body.calling_permissions = calling_permissions
        url = self.ep(f'people/{person_id}/features/outgoingPermission')
        super().put(url=url, params=params, data=body.json())
        return

    def assign_or_unassign_numbers_toperson(self, person_id: str, phone_numbers: PhoneNumber, org_id: str = None, enable_distinctive_ring_pattern: bool = None):
        """
        Assign or unassign alternate phone numbers to a person.
        Each location has a set of phone numbers that can be assigned to people, workspaces, or features. Phone numbers
        must follow the E.164 format for all countries, except for the United States, which can also follow the
        National format. Active phone numbers are in service.
        Assigning or unassigning an alternate phone number to a person requires a full administrator auth token with a
        scope of spark-admin:telephony_config_write.

        :param person_id: Unique identitfier of the person.
        :type person_id: str
        :param phone_numbers: List of phone numbers that are assigned to a person.
        :type phone_numbers: PhoneNumber
        :param org_id: Organization of the Route Group.
        :type org_id: str
        :param enable_distinctive_ring_pattern: Enables a distinctive ring pattern for the person.
        :type enable_distinctive_ring_pattern: bool

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-person-settings/assign-or-unassign-numbers-to-a-person
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = AssignOrUnassignNumbersTopersonBody()
        if phone_numbers is not None:
            body.phone_numbers = phone_numbers
        if enable_distinctive_ring_pattern is not None:
            body.enable_distinctive_ring_pattern = enable_distinctive_ring_pattern
        url = self.ep(f'telephony/config/people/{person_id}/numbers')
        super().put(url=url, params=params, data=body.json())
        return

    def retrieve_list_of_call_queue_caller_id_information(self, person_id: str) -> list[CallQueueObject]:
        """
        Retrieve the list of the person's available call queues and the associated Caller ID information.
        If the Agent is to enable queueCallerIdEnabled, they must choose which queue to use as the source for outgoing
        Caller ID. This API returns a list of Call Queues from which the person must select. If this setting is
        disabled or the Agent does not belong to any queue, this list will be empty.
        This API requires a full admin or read-only administrator auth token with a scope of
        spark-admin:telephony_config_read.

        :param person_id: Unique identifier for the person.
        :type person_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-person-settings/retrieve-list-of-call-queue-caller-id-information
        """
        url = self.ep(f'telephony/config/people/{person_id}/queues/availableCallerIds')
        data = super().get(url=url)
        return parse_obj_as(list[CallQueueObject], data["availableQueues"])

    def retrieve_call_queue_agents_caller_id_information(self, person_id: str) -> RetrieveCallQueueAgentsCallerIDInformationResponse:
        """
        Retrieve a call queue agent's Caller ID information.
        Each agent in the Call Queue will be able to set their outgoing Caller ID as either the Call Queue's phone
        number or their own configured Caller ID. This API fetches the configured Caller ID for the agent in the
        system.
        This API requires a full admin or read-only administrator auth token with a scope of
        spark-admin:telephony_config_read.

        :param person_id: Unique identifier for the person.
        :type person_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-person-settings/retrieve-a-call-queue-agent's-caller-id-information
        """
        url = self.ep(f'telephony/config/people/{person_id}/queues/callerId')
        data = super().get(url=url)
        return RetrieveCallQueueAgentsCallerIDInformationResponse.parse_obj(data)

    def modify_call_queue_agents_caller_id_information(self, person_id: str, queue_caller_id_enabled: bool, selected_queue: Role):
        """
        Modify a call queue agent's Caller ID information.
        Each Agent in the Call Queue will be able to set their outgoing Caller ID as either the designated Call Queue's
        phone number or their own configured Caller ID. This API modifies the configured Caller ID for the agent in the
        system.
        This API requires a full or user administrator auth token with the spark-admin:telephony_config_write scope.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param queue_caller_id_enabled: When true, indicates that this agent is using the selectedQueue for its Caller
            ID. When false, indicates that it is using the agent's configured Caller ID.
        :type queue_caller_id_enabled: bool
        :param selected_queue: Indicates agent's choice of using this queue's Caller ID for outgoing calls. It is empty
            object when queueCallerIdEnabled is false. When queueCallerIdEnabled is true this data must be populated.
        :type selected_queue: Role

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-person-settings/modify-a-call-queue-agent's-caller-id-information
        """
        body = ModifyCallQueueAgentsCallerIDInformationBody()
        if queue_caller_id_enabled is not None:
            body.queue_caller_id_enabled = queue_caller_id_enabled
        if selected_queue is not None:
            body.selected_queue = selected_queue
        url = self.ep(f'telephony/config/people/{person_id}/queues/callerId')
        super().put(url=url, data=body.json())
        return

class VoiceMessageDetails(ApiModel):
    #: The message identifier of the voicemail message.
    id: Optional[str]
    #: The duration (in seconds) of the voicemail message. Duration is not present for a FAX message.
    duration: Optional[int]
    #: The calling party's details. For example, if user A calls user B and leaves a voicemail message, then A is the
    #: calling party.
    calling_party: Optional[VoiceMailPartyInformation]
    #: true if the voicemail message is urgent.
    urgent: Optional[bool]
    #: true if the voicemail message is confidential.
    confidential: Optional[bool]
    #: true if the voicemail message has been read.
    read: Optional[bool]
    #: Number of pages for the FAX. Only set for a FAX.
    fax_page_count: Optional[int]
    #: The date and time the voicemail message was created.
    created: Optional[str]


class GetMessageSummaryResponse(ApiModel):
    #: The number of new (unread) voicemail messages.
    new_messages: Optional[int]
    #: The number of old (read) voicemail messages.
    old_messages: Optional[int]
    #: The number of new (unread) urgent voicemail messages.
    new_urgent_messages: Optional[int]
    #: The number of old (read) urgent voicemail messages.
    old_urgent_messages: Optional[int]


class ListMessagesResponse1(ApiModel):
    items: Optional[list[VoiceMessageDetails]]


class MarkAsReadBody(ApiModel):
    #: The voicemail message identifier of the message to mark as read. If the messageId is not provided, then all
    #: voicemail messages for the user are marked as read.
    message_id: Optional[str]


class MarkAsUnreadBody(ApiModel):
    #: The voicemail message identifier of the message to mark as unread. If the messageId is not provided, then all
    #: voicemail messages for the user are marked as unread.
    message_id: Optional[str]


class WebexCallingVoiceMessagingApi(ApiChild, base='telephony/voiceMessages'):
    """
    Voice Messaging APIs provide support for handling voicemail and message waiting indicators in Webex Calling. The
    APIs are limited to user access (no admin access), and all GET commands require the spark:calls_read scope, while
    the other commands require the spark:calls_write scope.
    """

    def summary(self) -> GetMessageSummaryResponse:
        """
        Get a summary of the voicemail messages for the user.

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-voice-messaging/get-message-summary
        """
        url = self.ep('summary')
        data = super().get(url=url)
        return GetMessageSummaryResponse.parse_obj(data)

    def list(self) -> list[VoiceMessageDetails]:
        """
        Get the list of all voicemail messages for the user.

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-voice-messaging/list-messages
        """
        url = self.ep()
        data = super().get(url=url)
        return parse_obj_as(list[VoiceMessageDetails], data["items"])

    def delete(self, message_id: str):
        """
        Delete a specfic voicemail message for the user.

        :param message_id: The message identifer of the voicemail message to delete
        :type message_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-voice-messaging/delete-message
        """
        url = self.ep(f'{message_id}')
        super().delete(url=url)
        return

    def mark_as_read(self, message_id: str = None):
        """
        Update the voicemail message(s) as read for the user.
        If the messageId is provided, then only mark that message as read. Otherwise, all messages for the user are
        marked as read.

        :param message_id: The voicemail message identifier of the message to mark as read. If the messageId is not
            provided, then all voicemail messages for the user are marked as read.
        :type message_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-voice-messaging/mark-as-read
        """
        body = MarkAsReadBody()
        if message_id is not None:
            body.message_id = message_id
        url = self.ep('markAsRead')
        super().post(url=url, data=body.json())
        return

    def mark_as_unread(self, message_id: str = None):
        """
        Update the voicemail message(s) as unread for the user.
        If the messageId is provided, then only mark that message as unread. Otherwise, all messages for the user are
        marked as unread.

        :param message_id: The voicemail message identifier of the message to mark as unread. If the messageId is not
            provided, then all voicemail messages for the user are marked as unread.
        :type message_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-voice-messaging/mark-as-unread
        """
        body = MarkAsUnreadBody()
        if message_id is not None:
            body.message_id = message_id
        url = self.ep('markAsUnread')
        super().post(url=url, data=body.json())
        return

class CallForwardingPlaceSettingGet(ApiModel):
    #: Settings for forwarding all incoming calls to the destination you chose while the phone is in use or the
    #: workspace is busy.
    busy: Optional[BusinessContinuity]
    #: Settings for forwarding which only occurs when you are away or not answering your phone.
    no_answer: Optional[NoAnswer3]


class CallForwardingPlaceSettingPatch(ApiModel):
    #: Settings for forwarding all incoming calls to the destination you chose while the phone is in use or the
    #: workspace is busy.
    busy: Optional[BusinessContinuity]
    #: Settings for forwarding which only occurs when you are away or not answering your phone.
    no_answer: Optional[NoAnswer3]


class Hoteling(ApiModel):
    #: Enable/Disable hoteling Host. Enabling the device for hoteling means that a guest(end user) can log into this
    #: host(workspace device) and use this device
    #: as if it were their own. This is useful when traveling to a remote office but still needing to place/receive
    #: calls with their telephone number and access features normally available to them on their office phone.
    enabled: Optional[bool]
    #: Enable limiting the time a guest can use the device. The time limit is configured via guestHoursLimit.
    limit_guest_use: Optional[bool]
    #: Time Limit in hours until hoteling is enabled. Mandatory if limitGuestUse is enabled.
    guest_hours_limit: Optional[int]


class PlaceDevices(Devices):
    #: Indicates Hoteling details of a device.
    hoteling: Optional[Hoteling]


class UserNumberItem(GetUserNumberItemObject):
    #: Flag to indicate toll free number.
    toll_free_number: Optional[bool]


class MonitoredElementUser(CoHosts):
    #: ID of person or workspace.
    id: Optional[str]
    #: First name of person or workspace.
    first_name: Optional[str]
    #: Last name of person or workspace.
    last_name: Optional[str]
    #: Type of the person or workspace.
    type: Optional[MemberType]
    #: List of phone numbers of the person or workspace.
    numbers: Optional[list[UserNumberItem]]
    #: Name of location for call park.
    location: Optional[str]
    #: ID of the location for call park.
    location_id: Optional[str]


class MonitoredElementItem(ApiModel):
    #: Monitored Call Park extension.
    callparkextension: Optional[Callparkextension]
    #: Monitored member for this workspace.
    member: Optional[MonitoredElementUser]


class InterceptAnnouncementsGet(ApiModel):
    #: Indicates that a system default message will be placed when incoming calls are intercepted.
    greeting: Optional[Greeting]
    #: Filename of the custom greeting; this is an empty string if no custom greeting has been uploaded.
    filename: Optional[str]
    #: Information about the new number announcement.
    new_number: Optional[NewNumber]
    #: Information about how the call will be handled if zero (0) is pressed.
    zero_transfer: Optional[NewNumber]


class InterceptIncomingGet(ApiModel):
    #: Indicated incoming calls are intercepted.
    type: Optional[Type48]
    #: Indicates enabled or disabled state of sending incoming calls to voicemail when the destination is an internal
    #: phone number and that number has the voicemail service enabled.
    voicemail_enabled: Optional[bool]
    #: Settings related to how incoming calls are handled when the intercept feature is enabled.
    announcements: Optional[InterceptAnnouncementsGet]


class InterceptIncomingPatch(ApiModel):
    #: Indicated incoming calls are intercepted.
    type: Optional[Type48]
    #: Indicates enabled or disabled state of sending incoming calls to voicemail when the destination is an internal
    #: phone number and that number has the voicemail service enabled.
    voicemail_enabled: Optional[bool]
    #: Settings related to how incoming calls are handled when the intercept feature is enabled.
    announcements: Optional[Announcements3]


class RetrieveCallForwardingSettingsForWorkspaceResponse(ApiModel):
    #: Call forwarding settings for a Workspace.
    call_forwarding: Optional[CallForwardingPlaceSettingGet]


class ModifyCallForwardingSettingsForWorkspaceBody(ApiModel):
    #: Call forwarding settings for a Workspace.
    call_forwarding: Optional[CallForwardingPlaceSettingPatch]


class RetrieveCallWaitingSettingsForWorkspaceResponse(ApiModel):
    #: Call Waiting state.
    enabled: Optional[bool]


class ModifyCallWaitingSettingsForWorkspaceBody(ApiModel):
    #: Call Waiting state.
    enabled: Optional[bool]


class RetrieveCallerIDSettingsForWorkspaceResponse(ApiModel):
    #: Allowed types for the selected field.
    types: Optional[list[CLIDPolicySelection]]
    #: Which type of outgoing Caller ID will be used.
    selected: Optional[CLIDPolicySelection]
    #: Direct number which will be shown if DIRECT_LINE is selected.
    direct_number: Optional[str]
    #: Location number which will be shown if LOCATION_NUMBER is selected
    location_number: Optional[str]
    #: Flag for specifying a toll-free number.
    toll_free_location_number: Optional[bool]
    #: This value must be an assigned number from the person's location.
    custom_number: Optional[str]
    #: Workspace's caller ID display name.
    display_name: Optional[str]
    #: Workspace's caller ID display details. Default is ..
    display_detail: Optional[str]
    #: Flag to block call forwarding.
    block_in_forward_calls_enabled: Optional[bool]
    #: Designates which type of External Caller ID Name policy is used. Default is DIRECT_LINE.
    external_caller_id_name_policy: Optional[ExternalCallerIdNamePolicy]
    #: Custom External Caller Name, which will be shown if External Caller ID Name is OTHER.
    custom_external_caller_id_name: Optional[str]
    #: External Caller Name, which will be shown if External Caller ID Name is OTHER.
    location_external_caller_id_name: Optional[str]


class ModifyCallerIDSettingsForWorkspaceBody(ApiModel):
    #: Which type of outgoing Caller ID will be used.
    selected: Optional[CLIDPolicySelection]
    #: This value must be an assigned number from the workspace's location.
    custom_number: Optional[str]
    #: Workspace's caller ID display name.
    display_name: Optional[str]
    #: Workspace's caller ID display details.
    display_detail: Optional[str]
    #: Flag to block call forwarding.
    block_in_forward_calls_enabled: Optional[bool]
    #: Designates which type of External Caller ID Name policy is used. Default is DIRECT_LINE.
    #: Possible values: DIRECT_LINE
    external_caller_id_name_policy: Optional[ExternalCallerIdNamePolicy]
    #: Custom External Caller Name, which will be shown if External Caller ID Name is OTHER.
    custom_external_caller_id_name: Optional[str]
    #: External Caller Name, which will be shown if External Caller ID Name is OTHER.
    location_external_caller_id_name: Optional[str]


class GetWorkspaceDevicesResponse(ApiModel):
    #: Array of devices associated to a workspace.
    devices: Optional[list[PlaceDevices]]
    #: Maximum number of devices a workspace can be assigned to.
    max_device_count: Optional[int]


class RetrieveMonitoringSettingsForWorkspaceResponse(ApiModel):
    #: Call park notification enabled or disabled.
    call_park_notification_enabled: Optional[bool]
    #: Monitored element items.
    monitored_elements: Optional[MonitoredElementItem]


class RetrieveOutgoingPermissionSettingsForWorkspaceResponse(ApiModel):
    #: Outgoing Permission state. If disabled, the default settings are used.
    use_custom_enabled: Optional[bool]
    #: Workspace's list of outgoing permissions.
    calling_permissions: Optional[list[CallingPermissionObject]]


class ModifyOutgoingPermissionSettingsForWorkspaceBody(ApiModel):
    #: Outgoing Permission state. If disabled, the default settings are used.
    use_custom_enabled: Optional[bool]
    #: Workspace's list of outgoing permissions.
    calling_permissions: Optional[list[CallingPermissionObject]]


class RetrieveAccessCodesForWorkspaceResponse(ApiModel):
    #: Indicates the set of activation codes and description.
    access_codes: Optional[list[ReportError]]


class ModifyAccessCodesForWorkspaceBody(ApiModel):
    #: Indicates access codes to delete.
    delete_codes: Optional[list[str]]


class ReadCallInterceptSettingsForWorkspaceResponse(ApiModel):
    #: true if call intercept is enabled.
    enabled: Optional[bool]
    #: Settings related to how incoming calls are handled when the intercept feature is enabled.
    incoming: Optional[InterceptIncomingGet]
    #: Settings related to how outgoing calls are handled when the intercept feature is enabled.
    outgoing: Optional[Outgoing]


class ConfigureCallInterceptSettingsForWorkspaceBody(ApiModel):
    #: true if call interception is enabled.
    enabled: Optional[bool]
    #: Settings related to how incoming calls are handled when the intercept feature is enabled.
    incoming: Optional[InterceptIncomingPatch]
    #: Settings related to how outgoing calls are handled when the intercept feature is enabled.
    outgoing: Optional[Outgoing]


class WebexCallingWorkspaceSettingsApi(ApiChild, base=''):
    """
    Workspaces represent places where people work, such as conference rooms, meeting spaces, lobbies, and lunchrooms.
    Devices may be associated with workspaces.
    Webex Calling Workspace Settings support reading and writing of Webex Calling settings for a specific workspace
    within the organization.
    Viewing the list of settings in a workspace requires an administrator auth token with the
    spark-admin:workspaces_read scope.
    Adding, updating, or deleting settings in a workspace requires an administrator auth token with the
    spark-admin:workspaces_write scope.
    This API can also be used by partner administrators acting as administrators of a different organization than their
    own. In those cases, an orgId must be supplied, as indicated in the reference documentation for the relevant
    endpoints.
    A partner administrator can retrieve or change settings in a customer's organization using the optional OrgId query
    parameter.
    """

    def retrieve_call_forwarding_settings_for(self, workspace_id: str, org_id: str = None) -> CallForwardingPlaceSettingGet:
        """
        Retrieve Call Forwarding Settings for a Workspace.
        Two types of call forwarding are supported:
        This API requires a full or read-only administrator auth token with a scope of spark-admin:workspaces_read or a
        user auth token with spark:workspaces_read scope can be used to read workspace settings.

        :param workspace_id: Unique identifier for the workspace.
        :type workspace_id: str
        :param org_id: ID of the organization within which the workspace resides. Only admin users of another
            organization (such as partners) may use this parameter as the default is the same organization as the token
            used to access API.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-workspace-settings/retrieve-call-forwarding-settings-for-a-workspace
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'workspaces/{workspace_id}/features/callForwarding')
        data = super().get(url=url, params=params)
        return CallForwardingPlaceSettingGet.parse_obj(data["callForwarding"])

    def modify_call_forwarding_settings_for(self, workspace_id: str, call_forwarding: CallForwardingPlaceSettingPatch, org_id: str = None):
        """
        Modify call forwarding settings for a Workspace.
        Two types of call forwarding are supported:
        This API requires a full or user administrator auth token with the spark-admin:workspaces_write scope or a user
        auth token with spark:workspaces_write scope can be used to update workspace settings.

        :param workspace_id: Unique identifier for the workspace.
        :type workspace_id: str
        :param call_forwarding: Call forwarding settings for a Workspace.
        :type call_forwarding: CallForwardingPlaceSettingPatch
        :param org_id: ID of the organization within which the workspace resides. Only admin users of another
            organization (such as partners) may use this parameter as the default is the same organization as the token
            used to access API.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-workspace-settings/modify-call-forwarding-settings-for-a-workspace
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = ModifyCallForwardingSettingsForWorkspaceBody()
        if call_forwarding is not None:
            body.call_forwarding = call_forwarding
        url = self.ep(f'workspaces/{workspace_id}/features/callForwarding')
        super().put(url=url, params=params, data=body.json())
        return

    def retrieve_call_waiting_settings_for(self, workspace_id: str, org_id: str = None) -> bool:
        """
        Retrieve Call Waiting Settings for a Workspace.
        Call Waiting allows workspaces to handle multiple simultaneous calls. Workspaces with Call Waiting enabled can
        place a call on hold to answer or initiate another call.
        This API requires a full or read-only administrator auth token with a scope of spark-admin:workspaces_read or a
        user auth token with spark:workspaces_read scope can be used to read workspace settings.

        :param workspace_id: Unique identifier for the workspace.
        :type workspace_id: str
        :param org_id: ID of the organization within which the workspace resides. Only admin users of another
            organization (such as partners) may use this parameter as the default is the same organization as the token
            used to access API.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-workspace-settings/retrieve-call-waiting-settings-for-a-workspace
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'workspaces/{workspace_id}/features/callWaiting')
        data = super().get(url=url, params=params)
        return data["enabled"]

    def modify_call_waiting_settings_for(self, workspace_id: str, org_id: str = None, enabled: bool = None):
        """
        Modify Call Waiting Settings for a Workspace.
        Call Waiting allows workspaces to handle multiple simultaneous calls. Workspaces with Call Waiting enabled can
        place a call on hold to answer or initiate another call.
        This API requires a full or user administrator auth token with the spark-admin:workspaces_write scope or a user
        auth token with spark:workspaces_write scope can be used to update workspace settings.

        :param workspace_id: Unique identifier for the workspace.
        :type workspace_id: str
        :param org_id: ID of the organization within which the workspace resides. Only admin users of another
            organization (such as partners) may use this parameter as the default is the same organization as the token
            used to access API.
        :type org_id: str
        :param enabled: Call Waiting state.
        :type enabled: bool

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-workspace-settings/modify-call-waiting-settings-for-a-workspace
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = ModifyCallWaitingSettingsForWorkspaceBody()
        if enabled is not None:
            body.enabled = enabled
        url = self.ep(f'workspaces/{workspace_id}/features/callWaiting')
        super().put(url=url, params=params, data=body.json())
        return

    def retrieve_caller_id_settings_for(self, workspace_id: str, org_id: str = None) -> RetrieveCallerIDSettingsForWorkspaceResponse:
        """
        Retrieve Caller ID Settings for a Workspace.
        Caller ID settings control how a workspace's information is displayed when making outgoing calls.
        This API requires a full or read-only administrator auth token with a scope of spark-admin:workspaces_read or a
        user auth token with spark:workspaces_read scope can be used to read workspace settings.

        :param workspace_id: Unique identifier for the workspace.
        :type workspace_id: str
        :param org_id: ID of the organization within which the workspace resides. Only admin users of another
            organization (such as partners) may use this parameter as the default is the same organization as the token
            used to access API.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-workspace-settings/retrieve-caller-id-settings-for-a-workspace
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'workspaces/{workspace_id}/features/callerId')
        data = super().get(url=url, params=params)
        return RetrieveCallerIDSettingsForWorkspaceResponse.parse_obj(data)

    def modify_caller_id_settings_for(self, workspace_id: str, selected: CLIDPolicySelection, org_id: str = None, custom_number: str = None, display_name: str = None, display_detail: str = None, block_in_forward_calls_enabled: bool = None, external_caller_id_name_policy: ExternalCallerIdNamePolicy = None, custom_external_caller_id_name: str = None, location_external_caller_id_name: str = None):
        """
        Modify Caller ID settings for a Workspace.
        Caller ID settings control how a workspace's information is displayed when making outgoing calls.
        This API requires a full or user administrator auth token with the spark-admin:workspaces_write scope or a user
        auth token with spark:workspaces_write scope can be used to update workspace settings.

        :param workspace_id: Unique identifier for the workspace.
        :type workspace_id: str
        :param selected: Which type of outgoing Caller ID will be used.
        :type selected: CLIDPolicySelection
        :param org_id: ID of the organization within which the workspace resides. Only admin users of another
            organization (such as partners) may use this parameter as the default is the same organization as the token
            used to access API.
        :type org_id: str
        :param custom_number: This value must be an assigned number from the workspace's location.
        :type custom_number: str
        :param display_name: Workspace's caller ID display name.
        :type display_name: str
        :param display_detail: Workspace's caller ID display details.
        :type display_detail: str
        :param block_in_forward_calls_enabled: Flag to block call forwarding.
        :type block_in_forward_calls_enabled: bool
        :param external_caller_id_name_policy: Designates which type of External Caller ID Name policy is used. Default
            is DIRECT_LINE. Possible values: DIRECT_LINE
        :type external_caller_id_name_policy: ExternalCallerIdNamePolicy
        :param custom_external_caller_id_name: Custom External Caller Name, which will be shown if External Caller ID
            Name is OTHER.
        :type custom_external_caller_id_name: str
        :param location_external_caller_id_name: External Caller Name, which will be shown if External Caller ID Name
            is OTHER.
        :type location_external_caller_id_name: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-workspace-settings/modify-caller-id-settings-for-a-workspace
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = ModifyCallerIDSettingsForWorkspaceBody()
        if selected is not None:
            body.selected = selected
        if custom_number is not None:
            body.custom_number = custom_number
        if display_name is not None:
            body.display_name = display_name
        if display_detail is not None:
            body.display_detail = display_detail
        if block_in_forward_calls_enabled is not None:
            body.block_in_forward_calls_enabled = block_in_forward_calls_enabled
        if external_caller_id_name_policy is not None:
            body.external_caller_id_name_policy = external_caller_id_name_policy
        if custom_external_caller_id_name is not None:
            body.custom_external_caller_id_name = custom_external_caller_id_name
        if location_external_caller_id_name is not None:
            body.location_external_caller_id_name = location_external_caller_id_name
        url = self.ep(f'workspaces/{workspace_id}/features/callerId')
        super().put(url=url, params=params, data=body.json())
        return

    def devices(self, workspace_id: str, org_id: str = None) -> GetWorkspaceDevicesResponse:
        """
        Get all devices for a workspace.
        This requires a full or read-only administrator auth token with a scope of spark-admin:telephony_config_read.

        :param workspace_id: ID of the workspace for which to retrieve devices.
        :type workspace_id: str
        :param org_id: Organization to which the workspace belongs.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-workspace-settings/get-workspace-devices
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'telephony/config/workspaces/{workspace_id}/devices')
        data = super().get(url=url, params=params)
        return GetWorkspaceDevicesResponse.parse_obj(data)

    def modify_devices(self, workspace_id: str, org_id: str = None, enabled: bool = None, limit_guest_use: bool = None, guest_hours_limit: int = None):
        """
        Modify devices for a workspace.
        Modifying devices for a workspace requires a full administrator auth token with a scope of
        spark-admin:telephony_config_write.

        :param workspace_id: ID of the workspace for which to modify devices.
        :type workspace_id: str
        :param org_id: Organization to which the workspace belongs.
        :type org_id: str
        :param enabled: Enable/Disable hoteling Host. Enabling the device for hoteling means that a guest(end user) can
            log into this host(workspace device) and use this device as if it were their own. This is useful when
            traveling to a remote office but still needing to place/receive calls with their telephone number and
            access features normally available to them on their office phone.
        :type enabled: bool
        :param limit_guest_use: Enable limiting the time a guest can use the device. The time limit is configured via
            guestHoursLimit.
        :type limit_guest_use: bool
        :param guest_hours_limit: Time Limit in hours until hoteling is enabled. Mandatory if limitGuestUse is enabled.
        :type guest_hours_limit: int

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-workspace-settings/modify-workspace-devices
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = Hoteling()
        if enabled is not None:
            body.enabled = enabled
        if limit_guest_use is not None:
            body.limit_guest_use = limit_guest_use
        if guest_hours_limit is not None:
            body.guest_hours_limit = guest_hours_limit
        url = self.ep(f'telephony/config/workspaces/{workspace_id}/devices')
        super().put(url=url, params=params, data=body.json())
        return

    def retrieve_monitoring_settings_for(self, workspace_id: str, org_id: str = None) -> RetrieveMonitoringSettingsForWorkspaceResponse:
        """
        Retrieves Monitoring settings for a Workspace.
        Allow workspaces to monitor the line status of specified agents, workspaces, or call park extensions. The line
        status indicates if a monitored agent or a workspace is on a call, or if a call has been parked on the
        monitored call park extension.
        This API requires a full or read-only administrator auth token with a scope of spark-admin:workspaces_read or a
        user auth token with spark:workspaces_read scope can be used to read workspace settings.

        :param workspace_id: Unique identifier for the workspace.
        :type workspace_id: str
        :param org_id: ID of the organization within which the workspace resides. Only admin users of another
            organization (such as partners) may use this parameter as the default is the same organization as the token
            used to access API.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-workspace-settings/retrieve-monitoring-settings-for-a-workspace
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'workspaces/{workspace_id}/features/monitoring')
        data = super().get(url=url, params=params)
        return RetrieveMonitoringSettingsForWorkspaceResponse.parse_obj(data)

    def modify_monitoring_settings_for(self, workspace_id: str, enable_call_park_notification: bool, monitored_elements: List[str], org_id: str = None):
        """
        Modify Monitoring settings for a Workspace.
        Allow workspaces to monitor the line status of specified agents, workspaces, or call park extensions. The line
        status indicates if a monitored agent or a workspace is on a call, or if a call has been parked on the
        monitored call park extension.
        This API requires a full or user administrator auth token with the spark-admin:workspaces_write scope or a user
        auth token with spark:workspaces_write scope can be used to update workspace settings.

        :param workspace_id: Unique identifier for the workspace.
        :type workspace_id: str
        :param enable_call_park_notification: Enable or disable call park notification.
        :type enable_call_park_notification: bool
        :param monitored_elements: Identifiers of monitored elements whose monitoring settings will be modified.
            Possible values: Y2lzY29zcGFyazovL3VzL1BFT1BMRS85OWNlZjRmYS03YTM5LTQ1ZDItOTNmNi1jNjA5YTRiMjgzODY
        :type monitored_elements: List[str]
        :param org_id: ID of the organization within which the workspace resides. Only admin users of another
            organization (such as partners) may use this parameter as the default is the same organization as the token
            used to access API.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-workspace-settings/modify-monitoring-settings-for-a-workspace
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = ModifypersonsMonitoringSettingsBody()
        if enable_call_park_notification is not None:
            body.enable_call_park_notification = enable_call_park_notification
        if monitored_elements is not None:
            body.monitored_elements = monitored_elements
        url = self.ep(f'workspaces/{workspace_id}/features/monitoring')
        super().put(url=url, params=params, data=body.json())
        return

    def list_numbers_associated_withspecific(self, workspace_id: str, org_id: str = None):
        """
        List the PSTN phone numbers associated with a specific workspace, by ID, within the organization. Also shows
        the location and organization associated with the workspace.
        Retrieving this list requires a full or read-only administrator auth token with a scope of
        spark-admin:workspaces_read.

        :param workspace_id: List numbers for this workspace.
        :type workspace_id: str
        :param org_id: Workspace is in this organization. Only admin users of another organization (such as partners)
            can use this parameter as the default is the same organization as the token used to access API.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-workspace-settings/list-numbers-associated-with-a-specific-workspace
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'workspaces/{workspace_id}/features/numbers')
        super().get(url=url, params=params)
        return $!$!$!   # this is weird. Check the spec at https://developer.webex.com/docs/api/v1/webex-calling-workspace-settings/list-numbers-associated-with-a-specific-workspace

    def retrieve_incoming_permission_settings_for(self, workspace_id: str, org_id: str = None) -> ReadIncomingPermissionSettingsForPersonResponse:
        """
        Retrieve Incoming Permission settings for a Workspace.
        Incoming permission settings allow modifying permissions for a workspace that can be different from the
        organization's default to manage different call types.
        This API requires a full or read-only administrator auth token with a scope of spark-admin:workspaces_read or a
        user auth token with spark:workspaces_read scope can be used to read workspace settings.

        :param workspace_id: Unique identifier for the workspace.
        :type workspace_id: str
        :param org_id: ID of the organization within which the workspace resides. Only admin users of another
            organization (such as partners) may use this parameter as the default is the same organization as the token
            used to access API.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-workspace-settings/retrieve-incoming-permission-settings-for-a-workspace
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'workspaces/{workspace_id}/features/incomingPermission')
        data = super().get(url=url, params=params)
        return ReadIncomingPermissionSettingsForPersonResponse.parse_obj(data)

    def modify_incoming_permission_settings_for(self, workspace_id: str, org_id: str = None, use_custom_enabled: bool = None, external_transfer: ExternalTransfer = None, internal_calls_enabled: bool = None, collect_calls_enabled: bool = None):
        """
        Modify Incoming Permission settings for a Workspace.
        Incoming permission settings allow modifying permissions for a workspace that can be different from the
        organization's default to manage different call types.
        This API requires a full or user administrator auth token with the spark-admin:workspaces_write scope or a user
        auth token with spark:workspaces_write scope can be used to update workspace settings.

        :param workspace_id: Unique identifier for the workspace.
        :type workspace_id: str
        :param org_id: ID of the organization within which the workspace resides. Only admin users of another
            organization (such as partners) may use this parameter as the default is the same organization as the token
            used to access API.
        :type org_id: str
        :param use_custom_enabled: When true, indicates that this person uses the specified calling permissions for
            receiving inbound calls rather than the organizational defaults.
        :type use_custom_enabled: bool
        :param external_transfer: Specifies the transfer behavior for incoming, external calls.
        :type external_transfer: ExternalTransfer
        :param internal_calls_enabled: Internal calls are allowed to be received.
        :type internal_calls_enabled: bool
        :param collect_calls_enabled: Collect calls are allowed to be received.
        :type collect_calls_enabled: bool

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-workspace-settings/modify-incoming-permission-settings-for-a-workspace
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = ReadIncomingPermissionSettingsForPersonResponse()
        if use_custom_enabled is not None:
            body.use_custom_enabled = use_custom_enabled
        if external_transfer is not None:
            body.external_transfer = external_transfer
        if internal_calls_enabled is not None:
            body.internal_calls_enabled = internal_calls_enabled
        if collect_calls_enabled is not None:
            body.collect_calls_enabled = collect_calls_enabled
        url = self.ep(f'workspaces/{workspace_id}/features/incomingPermission')
        super().put(url=url, params=params, data=body.json())
        return

    def retrieve_outgoing_permission_settings_for(self, workspace_id: str, org_id: str = None) -> RetrieveOutgoingPermissionSettingsForWorkspaceResponse:
        """
        Retrieve Outgoing Permission settings for a Workspace.
        Turn on outgoing call settings for this workspace to override the calling settings from the location that are
        used by default.
        This API requires a full or read-only administrator auth token with a scope of spark-admin:workspaces_read or a
        user auth token with spark:workspaces_read scope can be used to read workspace settings.

        :param workspace_id: Unique identifier for the workspace.
        :type workspace_id: str
        :param org_id: ID of the organization within which the workspace resides. Only admin users of another
            organization (such as partners) may use this parameter as the default is the same organization as the token
            used to access API.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-workspace-settings/retrieve-outgoing-permission-settings-for-a-workspace
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'workspaces/{workspace_id}/features/outgoingPermission')
        data = super().get(url=url, params=params)
        return RetrieveOutgoingPermissionSettingsForWorkspaceResponse.parse_obj(data)

    def modify_outgoing_permission_settings_for(self, workspace_id: str, org_id: str = None, use_custom_enabled: bool = None, calling_permissions: CallingPermissionObject = None):
        """
        Modify Outgoing Permission settings for a Place.
        Turn on outgoing call settings for this workspace to override the calling settings from the location that are
        used by default.
        This API requires a full or user administrator auth token with the spark-admin:workspaces_write scope or a user
        auth token with spark:workspaces_write scope can be used to update workspace settings.

        :param workspace_id: Unique identifier for the workspace.
        :type workspace_id: str
        :param org_id: ID of the organization within which the workspace resides. Only admin users of another
            organization (such as partners) may use this parameter as the default is the same organization as the token
            used to access API.
        :type org_id: str
        :param use_custom_enabled: Outgoing Permission state. If disabled, the default settings are used.
        :type use_custom_enabled: bool
        :param calling_permissions: Workspace's list of outgoing permissions.
        :type calling_permissions: CallingPermissionObject

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-workspace-settings/modify-outgoing-permission-settings-for-a-workspace
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = ModifyOutgoingPermissionSettingsForWorkspaceBody()
        if use_custom_enabled is not None:
            body.use_custom_enabled = use_custom_enabled
        if calling_permissions is not None:
            body.calling_permissions = calling_permissions
        url = self.ep(f'workspaces/{workspace_id}/features/outgoingPermission')
        super().put(url=url, params=params, data=body.json())
        return

    def retrieve_access_codes_for(self, workspace_id: str, org_id: str = None) -> list[ReportError]:
        """
        Retrieve Access codes for a Workspace.
        Access codes are used to bypass permissions.
        This API requires a full or read-only administrator auth token with a scope of spark-admin:workspaces_read or a
        user auth token with spark:workspaces_read scope can be used to read workspace settings.

        :param workspace_id: Unique identifier for the workspace.
        :type workspace_id: str
        :param org_id: ID of the organization within which the workspace resides. Only admin users of another
            organization (such as partners) may use this parameter as the default is the same organization as the token
            used to access API.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-workspace-settings/retrieve-access-codes-for-a-workspace
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'workspaces/{workspace_id}/features/outgoingPermission/accessCodes')
        data = super().get(url=url, params=params)
        return parse_obj_as(list[ReportError], data["accessCodes"])

    def modify_access_codes_for(self, workspace_id: str, org_id: str = None, delete_codes: List[str] = None):
        """
        Modify Access codes for a workspace.
        Access codes are used to bypass permissions.
        This API requires a full or user administrator auth token with the spark-admin:workspaces_write scope or a user
        auth token with spark:workspaces_write scope can be used to update workspace settings.

        :param workspace_id: Unique identifier for the workspace.
        :type workspace_id: str
        :param org_id: ID of the organization within which the workspace resides. Only admin users of another
            organization (such as partners) may use this parameter as the default is the same organization as the token
            used to access API.
        :type org_id: str
        :param delete_codes: Indicates access codes to delete.
        :type delete_codes: List[str]

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-workspace-settings/modify-access-codes-for-a-workspace
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = ModifyAccessCodesForWorkspaceBody()
        if delete_codes is not None:
            body.delete_codes = delete_codes
        url = self.ep(f'workspaces/{workspace_id}/features/outgoingPermission/accessCodes')
        super().put(url=url, params=params, data=body.json())
        return

    def create_access_codes_for(self, workspace_id: str, org_id: str = None, code: int = None, description: str = None):
        """
        Create new Access codes for the given workspace.
        Access codes are used to bypass permissions.
        This API requires a full or user administrator auth token with the spark-admin:workspaces_write scope or a user
        auth token with spark:workspaces_write scope can be used to update workspace settings.

        :param workspace_id: Unique identifier for the workspace.
        :type workspace_id: str
        :param org_id: ID of the organization within which the workspace resides. Only admin users of another
            organization (such as partners) may use this parameter as the default is the same organization as the token
            used to access API.
        :type org_id: str
        :param code: The error code itself.
        :type code: int
        :param description: A textual representation of the error code.
        :type description: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-workspace-settings/create-access-codes-for-a-workspace
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = ReportError()
        if code is not None:
            body.code = code
        if description is not None:
            body.description = description
        url = self.ep(f'workspaces/{workspace_id}/features/outgoingPermission/accessCodes')
        super().post(url=url, params=params, data=body.json())
        return

    def read_call_intercept_settings_for(self, workspace_id: str, org_id: str = None) -> ReadCallInterceptSettingsForWorkspaceResponse:
        """
        Retrieves Workspace's Call Intercept Settings
        The intercept feature gracefully takes a workspace's phone out of service, while providing callers with
        informative announcements and alternative routing options. Depending on the service configuration, none, some,
        or all incoming calls to the specified workspace are intercepted. Also depending on the service configuration,
        outgoing calls are intercepted or rerouted to another location.
        This API requires a full or read-only administrator auth token with a scope of spark-admin:workspaces_read or a
        user auth token with spark:workspaces_read scope can be used to read workspace settings.

        :param workspace_id: Unique identifier for the workspace.
        :type workspace_id: str
        :param org_id: ID of the organization within which the workspace resides. Only admin users of another
            organization (such as partners) may use this parameter as the default is the same organization as the token
            used to access API.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-workspace-settings/read-call-intercept-settings-for-a-workspace
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'workspaces/{workspace_id}/features/intercept')
        data = super().get(url=url, params=params)
        return ReadCallInterceptSettingsForWorkspaceResponse.parse_obj(data)

    def configure_call_intercept_settings_for(self, workspace_id: str, org_id: str = None, enabled: bool = None, incoming: InterceptIncomingPatch = None, outgoing: Outgoing = None):
        """
        Configures a Workspace's Call Intercept Settings
        The intercept feature gracefully takes a workspace's phone out of service, while providing callers with
        informative announcements and alternative routing options. Depending on the service configuration, none, some,
        or all incoming calls to the specified person are intercepted. Also depending on the service configuration,
        outgoing calls are intercepted or rerouted to another location.
        This API requires a full or read-only administrator auth token with a scope of spark-admin:workspaces_write or
        a user auth token with spark:workspaces_read scope can be used by a person to read their settings.

        :param workspace_id: Unique identifier for the workspace.
        :type workspace_id: str
        :param org_id: ID of the organization within which the workspace resides. Only admin users of another
            organization (such as partners) may use this parameter as the default is the same organization as the token
            used to access API.
        :type org_id: str
        :param enabled: true if call interception is enabled.
        :type enabled: bool
        :param incoming: Settings related to how incoming calls are handled when the intercept feature is enabled.
        :type incoming: InterceptIncomingPatch
        :param outgoing: Settings related to how outgoing calls are handled when the intercept feature is enabled.
        :type outgoing: Outgoing

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-workspace-settings/configure-call-intercept-settings-for-a-workspace
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = ConfigureCallInterceptSettingsForWorkspaceBody()
        if enabled is not None:
            body.enabled = enabled
        if incoming is not None:
            body.incoming = incoming
        if outgoing is not None:
            body.outgoing = outgoing
        url = self.ep(f'workspaces/{workspace_id}/features/intercept')
        super().put(url=url, params=params, data=body.json())
        return

    def retrieve_transfer_numbers_settings_for(self, workspace_id: str, org_id: str = None) -> GetOutgoingPermissionAutoTransferNumberResponse:
        """
        Retrieve Transfer Numbers Settings for a Workspace.
        When calling a specific call type, this workspace will be automatically transferred to another number. The
        person assigned the Auto Transfer Number can then approve the call and send it through or reject the call type.
        You can add up to 3 numbers.
        This API requires a full or read-only administrator auth token with a scope of spark-admin:workspaces_read or a
        user auth token with spark:workspaces_read scope can be used to read workspace settings.

        :param workspace_id: Unique identifier for the workspace.
        :type workspace_id: str
        :param org_id: ID of the organization within which the workspace resides. Only admin users of another
            organization (such as partners) may use this parameter as the default is the same organization as the token
            used to access API.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-workspace-settings/retrieve-transfer-numbers-settings-for-a-workspace
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'workspaces/{workspace_id}/features/outgoingPermission/autoTransferNumbers')
        data = super().get(url=url, params=params)
        return GetOutgoingPermissionAutoTransferNumberResponse.parse_obj(data)

    def modify_transfer_numbers_settings_for(self, workspace_id: str, org_id: str = None, auto_transfer_number1: str = None, auto_transfer_number2: str = None, auto_transfer_number3: str = None):
        """
        Modify Transfer Numbers Settings for a place.
        When calling a specific call type, this workspace will be automatically transferred to another number. The
        person assigned the Auto Transfer Number can then approve the call and send it through or reject the call type.
        You can add up to 3 numbers.
        This API requires a full or user administrator auth token with the spark-admin:workspaces_write scope or a user
        auth token with spark:workspaces_write scope can be used to update workspace settings.

        :param workspace_id: Unique identifier for the workspace.
        :type workspace_id: str
        :param org_id: ID of the organization within which the workspace resides. Only admin users of another
            organization (such as partners) may use this parameter as the default is the same organization as the token
            used to access API.
        :type org_id: str
        :param auto_transfer_number1: Calls placed meeting the criteria in an outbound rule whose action is
            TRANSFER_NUMBER_1 will be transferred to this number.
        :type auto_transfer_number1: str
        :param auto_transfer_number2: Calls placed meeting the criteria in an outbound rule whose action is
            TRANSFER_NUMBER_2 will be transferred to this number.
        :type auto_transfer_number2: str
        :param auto_transfer_number3: Calls placed meeting the criteria in an outbound rule whose action is
            TRANSFER_NUMBER_3 will be transferred to this number.
        :type auto_transfer_number3: str

        documentation: https://developer.webex.com/docs/api/v1/webex-calling-workspace-settings/modify-transfer-numbers-settings-for-a-workspace
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = GetOutgoingPermissionAutoTransferNumberResponse()
        if auto_transfer_number1 is not None:
            body.auto_transfer_number1 = auto_transfer_number1
        if auto_transfer_number2 is not None:
            body.auto_transfer_number2 = auto_transfer_number2
        if auto_transfer_number3 is not None:
            body.auto_transfer_number3 = auto_transfer_number3
        url = self.ep(f'workspaces/{workspace_id}/features/outgoingPermission/autoTransferNumbers')
        super().put(url=url, params=params, data=body.json())
        return

class Resource(str, Enum):
    #: The Attachment Actions resource.
    attachment_actions = 'attachmentActions'
    #: The Memberships resource.
    memberships = 'memberships'
    #: The Messages resource.
    messages = 'messages'
    #: The Rooms resource.
    rooms = 'rooms'
    #: The Meetings resource.
    meetings = 'meetings'
    #: The Recordings resource.
    recordings = 'recordings'
    #: The Meeting Participants resource.
    meeting_participants = 'meetingParticipants'
    #: The Meeting Transcripts resource.
    meeting_transcripts = 'meetingTranscripts'


class Event1(EventTypeEnum):
    #: A meeting was started.
    started = 'started'
    #: A participant joined.
    joined = 'joined'
    #: A participant left.
    left = 'left'
    #: A room was migrated to a different geography. The roomId has changed.
    migrated = 'migrated'


class CreateWebhookBody(ApiModel):
    #: A user-friendly name for the webhook.
    name: Optional[str]
    #: The URL that receives POST requests for each event.
    target_url: Optional[str]
    #: The resource type for the webhook. Creating a webhook requires 'read' scope on the resource the webhook is for.
    resource: Optional[Resource]
    #: The event type for the webhook.
    event: Optional[Event1]
    #: The filter that defines the webhook scope. See Filtering Webhooks for more information.
    filter: Optional[str]
    #: The secret used to generate payload signature.
    secret: Optional[str]
    #: Specified when creating an org/admin level webhook. Supported for meetings, recordings, meetingParticipants, and
    #: meetingTranscripts resources.
    owned_by: Optional[str]


class Webhook(CreateWebhookBody):
    #: A unique identifier for the webhook.
    id: Optional[str]
    #: The status of the webhook. Use active to reactivate a disabled webhook.
    status: Optional[Status32]
    #: The date and time the webhook was created.
    created: Optional[str]


class ListWebhooksResponse(ApiModel):
    items: Optional[list[Webhook]]


class UpdateWebhookBody(ApiModel):
    #: A user-friendly name for the webhook.
    name: Optional[str]
    #: The URL that receives POST requests for each event.
    target_url: Optional[str]
    #: The secret used to generate payload signature.
    secret: Optional[str]
    #: Specified when creating an org/admin level webhook. Supported for meetings, recordings, meetingParticipants and
    #: meetingTranscripts resources.
    owned_by: Optional[str]
    #: The status of the webhook. Use "active" to reactivate a disabled webhook.
    status: Optional[Status32]


class WebhooksApi(ApiChild, base='webhooks'):
    """
    For Webex for Government (FedRAMP), the following resource types are not available for Webhooks: meetings,
    recordings, meetingParticipants, and meetingTranscripts.
    Webhooks allow your app to be notified via HTTP when a specific event occurs in Webex. For example, your app can
    register a webhook to be notified when a new message is posted into a specific room.
    Events trigger in near real-time allowing your app and backend IT systems to stay in sync with new content and room
    activity.
    Check The Webhooks Guide and our blog regularly for announcements of additional webhook resources and event types.
    Long result sets will be split into pages.
    """

    def list(self, owned_by: str = None, **params) -> Generator[Webhook, None, None]:
        """
        List all of your webhooks.

        :param owned_by: Limit the result list to org wide webhooks. Only allowed value is org.
        :type owned_by: str

        documentation: https://developer.webex.com/docs/api/v1/webhooks/list-webhooks
        """
        if owned_by is not None:
            params['ownedBy'] = owned_by
        url = self.ep()
        return self.session.follow_pagination(url=url, model=Webhook, params=params)

    def create(self, name: str, target_url: str, resource: Resource, event: Event1, filter: str = None, secret: str = None, owned_by: str = None) -> Webhook:
        """
        Creates a webhook.
        To learn more about how to create and use webhooks, see The Webhooks Guide.

        :param name: A user-friendly name for the webhook.
        :type name: str
        :param target_url: The URL that receives POST requests for each event.
        :type target_url: str
        :param resource: The resource type for the webhook. Creating a webhook requires 'read' scope on the resource
            the webhook is for.
        :type resource: Resource
        :param event: The event type for the webhook.
        :type event: Event1
        :param filter: The filter that defines the webhook scope. See Filtering Webhooks for more information.
        :type filter: str
        :param secret: The secret used to generate payload signature.
        :type secret: str
        :param owned_by: Specified when creating an org/admin level webhook. Supported for meetings, recordings,
            meetingParticipants, and meetingTranscripts resources.
        :type owned_by: str

        documentation: https://developer.webex.com/docs/api/v1/webhooks/create-a-webhook
        """
        body = CreateWebhookBody()
        if name is not None:
            body.name = name
        if target_url is not None:
            body.target_url = target_url
        if resource is not None:
            body.resource = resource
        if event is not None:
            body.event = event
        if filter is not None:
            body.filter = filter
        if secret is not None:
            body.secret = secret
        if owned_by is not None:
            body.owned_by = owned_by
        url = self.ep()
        data = super().post(url=url, data=body.json())
        return Webhook.parse_obj(data)

    def details(self, webhook_id: str) -> Webhook:
        """
        Shows details for a webhook, by ID.
        Specify the webhook ID in the webhookId parameter in the URI.

        :param webhook_id: The unique identifier for the webhook.
        :type webhook_id: str

        documentation: https://developer.webex.com/docs/api/v1/webhooks/get-webhook-details
        """
        url = self.ep(f'{webhook_id}')
        data = super().get(url=url)
        return Webhook.parse_obj(data)

    def update(self, webhook_id: str, name: str, target_url: str, secret: str = None, owned_by: str = None, status: Status32 = None) -> Webhook:
        """
        Updates a webhook, by ID. You cannot use this call to deactivate a webhook, only to activate a webhook that was
        auto deactivated.
        The fields that can be updated are name, targetURL, secret and status. All other fields, if supplied, are
        ignored.
        Specify the webhook ID in the webhookId parameter in the URI.

        :param webhook_id: The unique identifier for the webhook.
        :type webhook_id: str
        :param name: A user-friendly name for the webhook.
        :type name: str
        :param target_url: The URL that receives POST requests for each event.
        :type target_url: str
        :param secret: The secret used to generate payload signature.
        :type secret: str
        :param owned_by: Specified when creating an org/admin level webhook. Supported for meetings, recordings,
            meetingParticipants and meetingTranscripts resources.
        :type owned_by: str
        :param status: The status of the webhook. Use "active" to reactivate a disabled webhook.
        :type status: Status32

        documentation: https://developer.webex.com/docs/api/v1/webhooks/update-a-webhook
        """
        body = UpdateWebhookBody()
        if name is not None:
            body.name = name
        if target_url is not None:
            body.target_url = target_url
        if secret is not None:
            body.secret = secret
        if owned_by is not None:
            body.owned_by = owned_by
        if status is not None:
            body.status = status
        url = self.ep(f'{webhook_id}')
        data = super().put(url=url, data=body.json())
        return Webhook.parse_obj(data)

    def delete(self, webhook_id: str):
        """
        Deletes a webhook, by ID.
        Specify the webhook ID in the webhookId parameter in the URI.

        :param webhook_id: The unique identifier for the webhook.
        :type webhook_id: str

        documentation: https://developer.webex.com/docs/api/v1/webhooks/delete-a-webhook
        """
        url = self.ep(f'{webhook_id}')
        super().delete(url=url)
        return

class Type70(str, Enum):
    user = 'USER'
    customer = 'CUSTOMER'
    partner = 'PARTNER'


class CreateWholesaleBillingReportResponse(ApiModel):
    #: A unique report ID that corresponds to a billing report.
    id: Optional[str]
    #: Billing report startDate.
    billing_start_date: Optional[str]
    #: Billing report endDate.
    billing_end_date: Optional[str]
    #: Billing Report Type
    type: Optional[Type70]


class ListReport1(CreateWholesaleBillingReportResponse):
    #: The status of the billing report
    status: Optional[Status]


class ListWholesaleBillingReportsResponse(ApiModel):
    #: An array of report objects.
    items: Optional[list[ListReport1]]


class GetWholesaleBillingReportResponse(ListReport1):
    #: The date and time the report was generated.
    created: Optional[str]
    #: The person ID of the partner administrator who created the report.
    created_by: Optional[str]
    #: The URL for partners to download the billing report.
    temp_download_url: Optional[str]
    #: List of errors that occurred during report generation.
    #: Note:
    #:   * This list captures errors that occurred during asynchronous or background report generation, after the
    #:     request has been accepted and a 202 OK response is returned.
    errors: Optional[list[ReportError]]


class CreateWholesaleBillingReportBody(ApiModel):
    #: The startDate (YYYY-MM-DD) for which the partner requests the billing report.
    billing_start_date: Optional[str]
    #: The endDate (YYYY-MM-DD) for which the partner requests the billing report.
    billing_end_date: Optional[str]
    #: Create report of the given type, PARTNER, CUSTOMER, or USER. Default: PARTNER.
    type: Optional[str]
    #: The Organization ID of the sub partner on Cisco Webex.
    sub_partner_org_id: Optional[str]


class WholesaleBillingReportsApi(ApiChild, base='wholesale/billing/reports'):
    """
    The Wholesale Billing Report APIs are targeted at Service Providers who sign up for the Webex for Wholesale
    solution. These APIs provides customer and user breakdown reports to the service providers or partners. Service
    providers can use these reports to reconcile their monthly invoices.
    Viewing Webex for Wholesale billing reports information requires a partner administrator auth token with the
    spark-admin:wholesale_billing_reports_read scope. Creating, Deleting billing reports require a partner
    administrator auth token with the spark-admin:wholesale_billing_reports_write scope.
    Each Webex Developer Sandbox for Webex Wholesale use is limited to a maximum of 10 account users for validation and
    test purposes only. Cisco may from time to time audit Webex Developer Sandbox accounts and reserves the right to
    remove users in excess of 10 account users, or terminate the Webex Developer Sandbox environment for any Developer
    resource misuse.
    """

    def list_billing_reports(self, billing_start_date: str = None, billing_end_date: str = None, sort_by: str = None, type_: str = None, status: str = None, sub_partner_org_id: str = None, **params) -> Generator[ListReport1, None, None]:
        """
        Search for associated wholesale billing reconciliation reports.

        :param billing_start_date: Only include billing reports having this billing startDate.
        :type billing_start_date: str
        :param billing_end_date: Only include billing reports having this billing endDate.
        :type billing_end_date: str
        :param sort_by: Sort the reports. Possible values: id, billingStartDate, billingEndDate, status
        :type sort_by: str
        :param type_: Only include reports of this type. Possible values: PARTNER, CUSTOMER, USER
        :type type_: str
        :param status: The status of the billing report Possible values: IN_PROGRESS, COMPLETED, FAILED
        :type status: str
        :param sub_partner_org_id: The Organization ID of the sub partner on Cisco Webex.
        :type sub_partner_org_id: str

        documentation: https://developer.webex.com/docs/api/v1/wholesale-billing-reports/list-wholesale-billing-reports
        """
        if billing_start_date is not None:
            params['billingStartDate'] = billing_start_date
        if billing_end_date is not None:
            params['billingEndDate'] = billing_end_date
        if sort_by is not None:
            params['sortBy'] = sort_by
        if type_ is not None:
            params['type'] = type_
        if status is not None:
            params['status'] = status
        if sub_partner_org_id is not None:
            params['subPartnerOrgId'] = sub_partner_org_id
        url = self.ep()
        return self.session.follow_pagination(url=url, model=ListReport1, params=params)

    def billing_report(self, id: str) -> GetWholesaleBillingReportResponse:
        """
        Retrieve a specific wholesale billing reconciliation report.

        :param id: A unique identifier for the report being requested.
        :type id: str

        documentation: https://developer.webex.com/docs/api/v1/wholesale-billing-reports/get-a-wholesale-billing-report
        """
        url = self.ep(f'{id}')
        data = super().get(url=url)
        return GetWholesaleBillingReportResponse.parse_obj(data)

    def create_billing_report(self, billing_start_date: str, billing_end_date: str, type_: str = None, sub_partner_org_id: str = None) -> CreateWholesaleBillingReportResponse:
        """
        Generate a wholesale billing reconciliation report.

        :param billing_start_date: The startDate (YYYY-MM-DD) for which the partner requests the billing report.
        :type billing_start_date: str
        :param billing_end_date: The endDate (YYYY-MM-DD) for which the partner requests the billing report.
        :type billing_end_date: str
        :param type_: Create report of the given type, PARTNER, CUSTOMER, or USER. Default: PARTNER.
        :type type_: str
        :param sub_partner_org_id: The Organization ID of the sub partner on Cisco Webex.
        :type sub_partner_org_id: str

        documentation: https://developer.webex.com/docs/api/v1/wholesale-billing-reports/create-a-wholesale-billing-report
        """
        body = CreateWholesaleBillingReportBody()
        if billing_start_date is not None:
            body.billing_start_date = billing_start_date
        if billing_end_date is not None:
            body.billing_end_date = billing_end_date
        if type_ is not None:
            body.type_ = type_
        if sub_partner_org_id is not None:
            body.sub_partner_org_id = sub_partner_org_id
        url = self.ep()
        data = super().post(url=url, data=body.json())
        return CreateWholesaleBillingReportResponse.parse_obj(data)

    def delete_billing_report(self, id: str):
        """
        Delete a monthly reconciliation report by report ID.

        :param id: A unique report ID that corresponds to a billing report.
        :type id: str

        documentation: https://developer.webex.com/docs/api/v1/wholesale-billing-reports/delete-a-wholesale-billing-report
        """
        url = self.ep(f'{id}')
        super().delete(url=url)
        return

class Address5(ApiModel):
    #: Address Line 1.
    address_line1: Optional[str]
    #: Address Line 2.
    address_line2: Optional[str]
    #: City of the customer.
    city: Optional[str]
    #: State or Province of the customer.
    state_or_province: Optional[str]
    #: Postal/Zip code of the customer.
    zip_or_postal_code: Optional[str]
    #: ISO2 country code of the customer size = 2.
    country: Optional[str]


class Status40(str, Enum):
    #: Customer is fully provisioned on Cisco Webex.
    provisioned = 'provisioned'
    #: Customer is provisioning.
    provisioning = 'provisioning'
    #: Customer is being deleted.
    deleting = 'deleting'
    #: An error occurred provisioning the customer on Cisco Webex.
    error = 'error'


class Status39(Status40):
    #: Customer is provisioned with errors.
    provisioned_with_errors = 'provisioned_with_errors'
    #: Customer is updating.
    updating = 'updating'
    #: The customer is pending a Denied Party List compliance check.
    pending_rpl_review = 'pending_rpl_review'


class Package8(str, Enum):
    #: Calling Basic Package.
    webex_calling = 'webex_calling'
    #: Meetings Package.
    webex_meetings = 'webex_meetings'
    #: Suite Package.
    webex_suite = 'webex_suite'
    #: Voice Package.
    webex_voice = 'webex_voice'


class Name(Package8):
    #: Webex Common Area Calling Package.
    common_area_calling = 'common_area_calling'


class Package6(ApiModel):
    #: The Webex Wholesale Packages assigned to the customer.
    name: Optional[Name]
    #: The provisioning status of the a particular package.
    status: Optional[Status40]
    #: List of warnings that occurred during that last attempt to provision/update this customer.
    #: Note:
    #:   * This list captures errors that occurred during asynchronous or background provisioning of the customer,
    #:     after the API has been accepted and 202 response returned.
    #:   * Any errors that occur during initial API request validation will be captured directly in error response with
    #:     appropriate HTTP status code.
    warnings: Optional[list[Errors]]
    #: List of errors that occurred during that last attempt to provision/update this customer.
    #: Note:
    #:   * This list captures errors that occurred during asynchronous or background provisioning of the customer,
    #:     after the API has been accepted and 202 response returned.
    #:   * Any errors that occur during initial API request validation will be captured directly in error response with
    #:     appropriate HTTP status code.
    errors: Optional[list[Errors]]


class ResourceDetails(ApiModel):
    packages: Optional[list[Package6]]


class Customer2(ApiModel):
    #: A unique Cisco identifier for the customer. This value should be used for the customerId parameter in the
    #: Wholesale Customers and Wholesale Subscribers API.
    id: Optional[str]
    #: The Organization ID of the enterprise on Cisco Webex, to be used when referencing this customer on other Cisco
    #: Webex APIs. Only presented when status is provisioned.
    org_id: Optional[str]
    #: External ID of the Customer.
    external_id: Optional[str]
    address: Optional[Address5]
    #: The provisioning status of the customer.
    status: Optional[Status39]
    #: List of package names provisioned
    packages: Optional[list[str]]
    resource_details: Optional[ResourceDetails]
    #: List of errors that occurred during that last attempt to provision/update this customer.
    #: Note:
    #:   * This list captures errors that occurred during asynchronous or background provisioning of the customer,
    #:     after the API has been accepted and 202 response returned.
    #:   * Any errors that occur during initial API request validation will be captured directly in error response with
    #:     appropriate HTTP status code.
    errors: Optional[list[Errors]]


class CustomerInfo1(ApiModel):
    #: The name of the Wholesale customer.
    name: Optional[str]
    #: The primary email address of the Wholesale customer.
    primary_email: Optional[str]


class CustomerInfo(CustomerInfo1):
    #: The {ISO-639-1}_{ISO-3166} or {ISO-639-1} locale or language code used as preferred language for organization
    #: and Webex Meeting Sites. Refer to the help page for more information.
    language: Optional[str]


class Numbers(ApiModel):
    +17205557878: Optional[str]
    +17205557879: Optional[str]
    +17205557880: Optional[str]
    +17205557881: Optional[str]


class Location16(ApiModel):
    #: Name of the wholesale customer office.
    name: Optional[str]
    #: Address of the wholesale customer.
    address: Optional[Address5]
    #: Customer timezone for calling package.
    timezone: Optional[str]
    #: Determine language for all generated emails and voice announcements.
    language: Optional[str]
    #: SIP Header for any emergency calls from this location.
    emergency_location_identifier: Optional[str]
    #: List of numbers to be assigned to the location.
    numbers: Optional[list[Numbers]]
    #: Main number of the Wholesale customer.
    main_number: Optional[str]


class Calling(ApiModel):
    location: Optional[Location16]


class ProvisioningParameters(ApiModel):
    calling: Optional[Calling]
    #: Customer timezone for meetings package.
    meetings: Optional[object]


class UpdateWholesaleCustomerBody(ApiModel):
    #: External ID of the Wholesale customer.
    external_id: Optional[str]
    #: The complete list of Webex Wholesale packages to be assigned to the customer, including any packages already
    #: provisioned. If a package has already been assigned to this customer and is not present in this list, then that
    #: package will be removed.
    #: Possible values: common_area_calling, webex_calling, webex_meetings, webex_suite, webex_voice
    packages: Optional[list[str]]
    #: Billing Address of the customer.
    address: Optional[Address5]
    #: Provisioning parameters are required when updating an existing package.
    provisioning_parameters: Optional[ProvisioningParameters]


class ProvisionWholesaleCustomerBody(UpdateWholesaleCustomerBody):
    #: This Provisioning ID defines how this customer is to be provisioned for Webex Services.
    #: Each Customer Template will have their own unique Provisioning ID. This ID will be displayed under the chosen
    #: Customer Template
    #: on Webex Control Hub.
    provisioning_id: Optional[str]
    #: The Organization ID of the enterprise on Webex. Mandatory for existing customer.
    org_id: Optional[str]
    #: Mandatory for new customer. Optional if Organization ID is provided.
    customer_info: Optional[CustomerInfo]


class ListWholesaleCustomersResponse(ApiModel):
    #: An array of Customer objects.
    items: Optional[list[Customer2]]


class ProvisionWholesaleCustomerResponse(ApiModel):
    #: A URL which points to the Get a Wholesale Customer endpoint for the provisioned customer.
    url: Optional[str]


class UpdateWholesaleCustomerResponse(ApiModel):
    #: A URL which points to the Get a Wholesale Customer endpoint for the provisioned customer.
    url: Optional[str]


class WholesaleCustomersApi(ApiChild, base='wholesale/customers'):
    """
    These are a set of APIs that are specifically targeted at Service Providers who sign up for Webex Wholesale. They
    enable Service Providers to provision Webex Services for their Customers.
    Viewing Webex Wholesale customer information requires an administrator API access token with
    spark-admin:wholesale_customers_read scope. Provisioning, updating, and removing customers requires an
    administrator API token with the spark-admin:wholesale_customers_write scope.
    Additional information codes are given for all success cases. To learn more about the error and info codes used in
    Wholesale Customer Provisioning Precheck APIs, see the Provisioning Precheck API Error Codes guide.
    Each Webex Developer Sandbox for Webex Wholesale use is limited to a maximum of 10 account users for validation and
    test purposes only. Cisco may from time to time audit Webex Developer Sandbox accounts and reserves the right to
    remove users in excess of 10 account users, or terminate the Webex Developer Sandbox environment for any Developer
    resource misuse.
    """

    def list_customers(self, external_id: str = None, status: list = None, offset: int = None, **params) -> Generator[Customer2, None, None]:
        """
        This API allows a Service Provider to search for their customers. There are a number of filter options, which
        can be combined in a single request.

        :param external_id: Customer external ID.
        :type external_id: str
        :param status: Customer API status.
        :type status: list
        :param offset: Offset value for implementing pagination.
        :type offset: int

        documentation: https://developer.webex.com/docs/api/v1/wholesale-customers/list-wholesale-customers
        """
        if external_id is not None:
            params['externalId'] = external_id
        if status is not None:
            params['status'] = status
        if offset is not None:
            params['offset'] = offset
        url = self.ep()
        return self.session.follow_pagination(url=url, model=Customer2, params=params)

    def provision_customer(self, packages: List[str], provisioning_id: str, external_id: str = None, address: Address5 = None, provisioning_parameters: ProvisioningParameters = None, org_id: str = None, customer_info: CustomerInfo = None) -> str:
        """
        Provision a Wholesale customer for Cisco Webex services.
        This API will allow a Service Provider to map the Wholesale customer and assign the required licenses and
        entitlements for Webex, Calling and Meetings.
        The Wholesale customer provisioning is asynchronous and thus a background task is created when this endpoint is
        invoked.

        :param packages: The complete list of Webex Wholesale packages to be assigned to the customer, including any
            packages already provisioned. If a package has already been assigned to this customer and is not present in
            this list, then that package will be removed. Possible values: common_area_calling, webex_calling,
            webex_meetings, webex_suite, webex_voice
        :type packages: List[str]
        :param provisioning_id: This Provisioning ID defines how this customer is to be provisioned for Webex Services.
            Each Customer Template will have their own unique Provisioning ID. This ID will be displayed under the
            chosen Customer Template on Webex Control Hub.
        :type provisioning_id: str
        :param external_id: External ID of the Wholesale customer.
        :type external_id: str
        :param address: Billing Address of the customer.
        :type address: Address5
        :param provisioning_parameters: Provisioning parameters are required when updating an existing package.
        :type provisioning_parameters: ProvisioningParameters
        :param org_id: The Organization ID of the enterprise on Webex. Mandatory for existing customer.
        :type org_id: str
        :param customer_info: Mandatory for new customer. Optional if Organization ID is provided.
        :type customer_info: CustomerInfo

        documentation: https://developer.webex.com/docs/api/v1/wholesale-customers/provision-a-wholesale-customer
        """
        body = ProvisionWholesaleCustomerBody()
        if packages is not None:
            body.packages = packages
        if provisioning_id is not None:
            body.provisioning_id = provisioning_id
        if external_id is not None:
            body.external_id = external_id
        if address is not None:
            body.address = address
        if provisioning_parameters is not None:
            body.provisioning_parameters = provisioning_parameters
        if org_id is not None:
            body.org_id = org_id
        if customer_info is not None:
            body.customer_info = customer_info
        url = self.ep()
        data = super().post(url=url, data=body.json())
        return data["url"]

    def customer(self, customer_id: str) -> Customer2:
        """
        This API will allow a Service Provider to retrieve details of a provisioned Wholesale customer on Cisco Webex.

        :param customer_id: A unique identifier for the customer in question.
        :type customer_id: str

        documentation: https://developer.webex.com/docs/api/v1/wholesale-customers/get-a-wholesale-customer
        """
        url = self.ep(f'{customer_id}')
        data = super().get(url=url)
        return Customer2.parse_obj(data)

    def update_customer(self, customer_id: str, packages: List[str], external_id: str = None, address: Address5 = None, provisioning_parameters: ProvisioningParameters = None) -> str:
        """
        This API allows a Service Provider to update certain details of a provisioned Wholesale customer.
        The Wholesale customer provisioning is asynchronous and thus a background task is created when this endpoint is
        invoked.

        :param customer_id: A unique identifier for the customer to be updated.
        :type customer_id: str
        :param packages: The complete list of Webex Wholesale packages to be assigned to the customer, including any
            packages already provisioned. If a package has already been assigned to this customer and is not present in
            this list, then that package will be removed. Possible values: common_area_calling, webex_calling,
            webex_meetings, webex_suite, webex_voice
        :type packages: List[str]
        :param external_id: External ID of the Wholesale customer.
        :type external_id: str
        :param address: Billing Address of the customer.
        :type address: Address5
        :param provisioning_parameters: Provisioning parameters are required when updating an existing package.
        :type provisioning_parameters: ProvisioningParameters

        documentation: https://developer.webex.com/docs/api/v1/wholesale-customers/update-a-wholesale-customer
        """
        body = UpdateWholesaleCustomerBody()
        if packages is not None:
            body.packages = packages
        if external_id is not None:
            body.external_id = external_id
        if address is not None:
            body.address = address
        if provisioning_parameters is not None:
            body.provisioning_parameters = provisioning_parameters
        url = self.ep(f'{customer_id}')
        data = super().put(url=url, data=body.json())
        return data["url"]

    def remove_customer(self, customer_id: str):
        """
        Allows a Service Provider to remove the mapping between a Wholesale Customer and a Cisco Webex organization.

        :param customer_id: A unique identifier for the customer in question.
        :type customer_id: str

        documentation: https://developer.webex.com/docs/api/v1/wholesale-customers/remove-a-wholesale-customer
        """
        url = self.ep(f'{customer_id}')
        super().delete(url=url)
        return

    def precheck_customer_provisioning(self, packages: List[str], provisioning_id: str, external_id: str = None, address: Address5 = None, provisioning_parameters: ProvisioningParameters = None, org_id: str = None, customer_info: CustomerInfo = None) -> PrecheckBroadworksSubscriberProvisioningResponse:
        """
        This API will allow the Partner sales team to verify likely success of provisioning a Wholesale customer.

        :param packages: The complete list of Webex Wholesale packages to be assigned to the customer, including any
            packages already provisioned. If a package has already been assigned to this customer and is not present in
            this list, then that package will be removed. Possible values: common_area_calling, webex_calling,
            webex_meetings, webex_suite, webex_voice
        :type packages: List[str]
        :param provisioning_id: This Provisioning ID defines how this customer is to be provisioned for Webex Services.
            Each Customer Template will have their own unique Provisioning ID. This ID will be displayed under the
            chosen Customer Template on Webex Control Hub.
        :type provisioning_id: str
        :param external_id: External ID of the Wholesale customer.
        :type external_id: str
        :param address: Billing Address of the customer.
        :type address: Address5
        :param provisioning_parameters: Provisioning parameters are required when updating an existing package.
        :type provisioning_parameters: ProvisioningParameters
        :param org_id: The Organization ID of the enterprise on Webex. Mandatory for existing customer.
        :type org_id: str
        :param customer_info: Mandatory for new customer. Optional if Organization ID is provided.
        :type customer_info: CustomerInfo

        documentation: https://developer.webex.com/docs/api/v1/wholesale-customers/precheck-a-wholesale-customer-provisioning
        """
        body = ProvisionWholesaleCustomerBody()
        if packages is not None:
            body.packages = packages
        if provisioning_id is not None:
            body.provisioning_id = provisioning_id
        if external_id is not None:
            body.external_id = external_id
        if address is not None:
            body.address = address
        if provisioning_parameters is not None:
            body.provisioning_parameters = provisioning_parameters
        if org_id is not None:
            body.org_id = org_id
        if customer_info is not None:
            body.customer_info = customer_info
        url = self.ep('validate')
        data = super().post(url=url, data=body.json())
        return PrecheckBroadworksSubscriberProvisioningResponse.parse_obj(data)

class Subscriber1(ApiModel):
    #: A unique Cisco identifier for the subscriber.
    id: Optional[str]
    #: The person id of the subscriber used in the /people API. Only presented when status is provisioned.
    person_id: Optional[str]
    #: The email address of the subscriber.
    email: Optional[str]
    #: A unique identifier for the customer.
    customer_id: Optional[str]
    #: External ID of the Wholesale customer.
    external_customer_id: Optional[str]
    #: The Webex Wholesale Package assigned to the subscriber.
    package: Optional[Package8]
    #: The provisioning status of the user.
    status: Optional[Status43]
    #: List of errors that occurred during that last attempt to provision/update this subscriber.
    #: Note:
    #:   * This list captures errors that occurred during provisioning of the subscriber.
    #:   * Any errors that occur during initial API request validation will be captured directly in error response with
    #:     appropriate HTTP status code.
    errors: Optional[list[Errors]]
    #: The date and time the subscriber was provisioned.
    created: Optional[str]
    #: The date and time the provisioning status of the subscriber last changed.
    last_status_change: Optional[str]


class ProvisioningParameters4(ApiModel):
    #: The primary phone number configured for the subscriber.
    primary_phone_number: Optional[str]
    #: The extension configured for the subscriber.
    extension: Optional[str]
    #: A unique identifier for the location. This id should be retrieved via the List Locations API.
    location_id: Optional[str]


class UpdateWholesaleSubscriberBody(ApiModel):
    #: The Webex Wholesale package to be assigned to the subscriber.
    package: Optional[Package8]
    #: The following attributes should only be supplied when changing from the Meetings Package to a package that
    #: requires calling-specific attributes.
    provisioning_parameters: Optional[ProvisioningParameters4]


class ProvisionWholesaleSubscriberBody(UpdateWholesaleSubscriberBody):
    #: ID of the Provisioned Customer for Webex Wholesale.
    customer_id: Optional[str]
    #: The email address of the subscriber (mandatory for the trusted email provisioning flow).
    email: Optional[str]


class ListWholesaleSubscribersResponse(ApiModel):
    #: An array of Subscriber objects.
    items: Optional[list[Subscriber1]]


class PrecheckWholesaleSubscriberProvisioningBody(ProvisionWholesaleSubscriberBody):
    #: This Provisioning ID defines how this wholesale subscriber is to be provisioned for Cisco Webex Services.
    #: Each Customer template has its unique provisioning ID. This ID is displayed under the chosen customer template
    #: on Cisco Webex Control Hub.
    provisioning_id: Optional[str]
    #: The primary email address of the customer.
    customer_info: Optional[object]


class WholesaleSubscribersApi(ApiChild, base='wholesale/subscribers'):
    """
    These are a set of APIs that are specifically targeted at Service Providers who sign up for Webex Wholesale. They
    enable Service Providers to provision Cisco Webex Services for their subscribers.
    Viewing Webex Wholesale subscriber information requires an administrator auth token with
    spark-admin:wholesale_subscribers_read scope. Provisioning, updating, and removing subscribers requires an
    administrator auth token with the spark-admin:wholesale_subscribers_write scope.
    Additional information codes are given for all success cases. To learn more about the error and info codes used in
    Wholesale Subscriber Provisioning Precheck APIs, see the Provisioning Precheck API Error Codes guide.
    Each Webex Developer Sandbox for Webex Wholesale use is limited to a maximum of 10 account users for validation and
    test purposes only. Cisco may from time to time audit Webex Developer Sandbox accounts and reserves the right to
    remove users in excess of 10 account users, or terminate the Webex Developer Sandbox environment for any Developer
    resource misuse.
    """

    def list_subscribers(self, offset: integer = None, customer_id: str = None, person_id: str = None, external_customer_id: str = None, email: str = None, status: str = None, after: str = None, last_status_change: str = None, sort_by: str = None, sort_order: str = None, **params) -> Generator[Subscriber1, None, None]:
        """
        This API allows a Service Provider to search for their associated subscribers. There are a number of filter
        options, which can be combined in a single request.

        :param offset: Offset value to implement pagination.
        :type offset: integer
        :param customer_id: Wholesale customer ID.
        :type customer_id: str
        :param person_id: The person ID of the subscriber used in the /v1/people API.
        :type person_id: str
        :param external_customer_id: Customer external ID.
        :type external_customer_id: str
        :param email: The email address of the subscriber.
        :type email: str
        :param status: The provisioning status of the subscriber.
        :type status: str
        :param after: Only include subscribers created after this date and time. Epoch time (in milliseconds)
            preferred, but ISO 8601 date format also accepted.
        :type after: str
        :param last_status_change: Only include subscribers with a provisioning status change after this date and time.
            Epoch time (in milliseconds) preferred, but ISO 8601 date format also accepted.
        :type last_status_change: str
        :param sort_by: Supported sortBy attributes are created and lastStatusChange. Default is created.
        :type sort_by: str
        :param sort_order: Sort by ASC (ascending) or DESC (descending).
        :type sort_order: str

        documentation: https://developer.webex.com/docs/api/v1/wholesale-subscribers/list-wholesale-subscribers
        """
        if offset is not None:
            params['offset'] = offset
        if customer_id is not None:
            params['customerId'] = customer_id
        if person_id is not None:
            params['personId'] = person_id
        if external_customer_id is not None:
            params['externalCustomerId'] = external_customer_id
        if email is not None:
            params['email'] = email
        if status is not None:
            params['status'] = status
        if after is not None:
            params['after'] = after
        if last_status_change is not None:
            params['lastStatusChange'] = last_status_change
        if sort_by is not None:
            params['sortBy'] = sort_by
        if sort_order is not None:
            params['sortOrder'] = sort_order
        url = self.ep()
        return self.session.follow_pagination(url=url, model=Subscriber1, params=params)

    def provision_subscriber(self, package: Package8, customer_id: str, email: str, provisioning_parameters: ProvisioningParameters4 = None) -> Subscriber1:
        """
        Provision a new Wholesale subscriber for Cisco Webex services.
        This API allows a Service Provider to map the Wholesale subscriber to a Cisco Webex Wholesale customer and
        assign the required licenses and entitlements for Webex, Calling and Meetings.

        :param package: The Webex Wholesale package to be assigned to the subscriber.
        :type package: Package8
        :param customer_id: ID of the Provisioned Customer for Webex Wholesale.
        :type customer_id: str
        :param email: The email address of the subscriber (mandatory for the trusted email provisioning flow).
        :type email: str
        :param provisioning_parameters: The following attributes should only be supplied when changing from the
            Meetings Package to a package that requires calling-specific attributes.
        :type provisioning_parameters: ProvisioningParameters4

        documentation: https://developer.webex.com/docs/api/v1/wholesale-subscribers/provision-a-wholesale-subscriber
        """
        body = ProvisionWholesaleSubscriberBody()
        if package is not None:
            body.package = package
        if customer_id is not None:
            body.customer_id = customer_id
        if email is not None:
            body.email = email
        if provisioning_parameters is not None:
            body.provisioning_parameters = provisioning_parameters
        url = self.ep()
        data = super().post(url=url, data=body.json())
        return Subscriber1.parse_obj(data)

    def subscriber(self, subscriber_id: str) -> Subscriber1:
        """
        This API allow a Service Provider to retrieve details of a provisioned Wholesale subscriber on Cisco Webex.

        :param subscriber_id: A unique identifier for the subscriber in question.
        :type subscriber_id: str

        documentation: https://developer.webex.com/docs/api/v1/wholesale-subscribers/get-a-wholesale-subscriber
        """
        url = self.ep(f'{subscriber_id}')
        data = super().get(url=url)
        return Subscriber1.parse_obj(data)

    def update_subscriber(self, subscriber_id: str, package: Package8, provisioning_parameters: ProvisioningParameters4 = None) -> Subscriber1:
        """
        This API allows a Service Provider to update certain details of a provisioned Wholesale subscriber.
        Note: The locationId cannot be updated with this API.

        :param subscriber_id: A unique identifier for the subscriber in question.
        :type subscriber_id: str
        :param package: The Webex Wholesale package to be assigned to the subscriber.
        :type package: Package8
        :param provisioning_parameters: The following attributes should only be supplied when changing from the
            Meetings Package to a package that requires calling-specific attributes.
        :type provisioning_parameters: ProvisioningParameters4

        documentation: https://developer.webex.com/docs/api/v1/wholesale-subscribers/update-a-wholesale-subscriber
        """
        body = UpdateWholesaleSubscriberBody()
        if package is not None:
            body.package = package
        if provisioning_parameters is not None:
            body.provisioning_parameters = provisioning_parameters
        url = self.ep(f'{subscriber_id}')
        data = super().put(url=url, data=body.json())
        return Subscriber1.parse_obj(data)

    def remove_subscriber(self, subscriber_id: str):
        """
        This API allows a Service Provider to remove the mapping between Wholesale Subscriber and a Webex user.

        :param subscriber_id: A unique identifier for the subscriber in question.
        :type subscriber_id: str

        documentation: https://developer.webex.com/docs/api/v1/wholesale-subscribers/remove-a-wholesale-subscriber
        """
        url = self.ep(f'{subscriber_id}')
        super().delete(url=url)
        return

    def precheck_subscriber_provisioning(self, package: Package8, customer_id: str, email: str, provisioning_parameters: ProvisioningParameters4 = None, provisioning_id: str = None, customer_info: object = None) -> PrecheckBroadworksSubscriberProvisioningResponse:
        """
        This API will allow the Partner sales team to verify likely success of provisioning a wholesale subscriber.

        :param package: The Webex Wholesale package to be assigned to the subscriber.
        :type package: Package8
        :param customer_id: ID of the Provisioned Customer for Webex Wholesale.
        :type customer_id: str
        :param email: The email address of the subscriber (mandatory for the trusted email provisioning flow).
        :type email: str
        :param provisioning_parameters: The following attributes should only be supplied when changing from the
            Meetings Package to a package that requires calling-specific attributes.
        :type provisioning_parameters: ProvisioningParameters4
        :param provisioning_id: This Provisioning ID defines how this wholesale subscriber is to be provisioned for
            Cisco Webex Services. Each Customer template has its unique provisioning ID. This ID is displayed under the
            chosen customer template on Cisco Webex Control Hub.
        :type provisioning_id: str
        :param customer_info: The primary email address of the customer.
        :type customer_info: object

        documentation: https://developer.webex.com/docs/api/v1/wholesale-subscribers/precheck-a-wholesale-subscriber-provisioning
        """
        body = PrecheckWholesaleSubscriberProvisioningBody()
        if package is not None:
            body.package = package
        if customer_id is not None:
            body.customer_id = customer_id
        if email is not None:
            body.email = email
        if provisioning_parameters is not None:
            body.provisioning_parameters = provisioning_parameters
        if provisioning_id is not None:
            body.provisioning_id = provisioning_id
        if customer_info is not None:
            body.customer_info = customer_info
        url = self.ep('validate')
        data = super().post(url=url, data=body.json())
        return PrecheckBroadworksSubscriberProvisioningResponse.parse_obj(data)

class CreateWorkspaceLocationBody(ApiModel):
    #: A friendly name for the location.
    display_name: Optional[str]
    #: The location address.
    address: Optional[str]
    #: The location country code (ISO 3166-1).
    country_code: Optional[str]
    #: The location city name.
    city_name: Optional[str]
    #: The location latitude.
    latitude: Optional[int]
    #: The location longitude.
    longitude: Optional[int]
    #: Notes associated with the location.
    notes: Optional[str]


class Location19(CreateWorkspaceLocationBody):
    #: Unique identifier for the location.
    id: Optional[str]
    #: Unique identifier for the location org ID.
    org_id: Optional[str]


class ListWorkspaceLocationsResponse(ApiModel):
    #: An array of location objects.
    items: Optional[list[Location19]]


class UpdateWorkspaceLocationBody(CreateWorkspaceLocationBody):
    #: Unique identifier for the location.
    id: Optional[str]


class ListWorkspaceLocationFloorsResponse(ApiModel):
    #: An array of floor objects.
    items: Optional[list[Floor]]


class WorkspaceLocationsApi(ApiChild, base='workspaceLocations'):
    """
    A Workspace Location is a physical location with a name, address, country, city, latitude and longitude.
    Viewing the list of locations in an organization requires an administrator auth token with the
    spark-admin:workspace_locations_read scope. Adding, updating, or deleting workspace locations in an organization
    requires an administrator auth token with the spark-admin:workspace_locations_write scope.
    The Workspace Locations API can also be used by partner administrators acting as administrators of a different
    organization than their own. In those cases an orgId value must be supplied, as indicated in the reference
    documentation for the relevant endpoints.
    """

    def list_locations(self, display_name: str = None, address: str = None, country_code: str = None, city_name: str = None) -> list[Location19]:
        """
        List workspace locations.

        :param display_name: Location display name.
        :type display_name: str
        :param address: Location address.
        :type address: str
        :param country_code: Location country code (ISO 3166-1).
        :type country_code: str
        :param city_name: Location city name.
        :type city_name: str

        documentation: https://developer.webex.com/docs/api/v1/workspace-locations/list-workspace-locations
        """
        params = {}
        if display_name is not None:
            params['displayName'] = display_name
        if address is not None:
            params['address'] = address
        if country_code is not None:
            params['countryCode'] = country_code
        if city_name is not None:
            params['cityName'] = city_name
        url = self.ep()
        data = super().get(url=url, params=params)
        return parse_obj_as(list[Location19], data["items"])

    def create_location(self, display_name: str, address: str, country_code: str, latitude: int, longitude: int, city_name: str = None, notes: str = None) -> Location19:
        """
        Create a location. The cityName and notes parameters are optional, and omitting them will result in the
        creation of a location without values for those attributes.

        :param display_name: A friendly name for the location.
        :type display_name: str
        :param address: The location address.
        :type address: str
        :param country_code: The location country code (ISO 3166-1).
        :type country_code: str
        :param latitude: The location latitude.
        :type latitude: int
        :param longitude: The location longitude.
        :type longitude: int
        :param city_name: The location city name.
        :type city_name: str
        :param notes: Notes associated with the location.
        :type notes: str

        documentation: https://developer.webex.com/docs/api/v1/workspace-locations/create-a-workspace-location
        """
        body = CreateWorkspaceLocationBody()
        if display_name is not None:
            body.display_name = display_name
        if address is not None:
            body.address = address
        if country_code is not None:
            body.country_code = country_code
        if latitude is not None:
            body.latitude = latitude
        if longitude is not None:
            body.longitude = longitude
        if city_name is not None:
            body.city_name = city_name
        if notes is not None:
            body.notes = notes
        url = self.ep()
        data = super().post(url=url, data=body.json())
        return Location19.parse_obj(data)

    def location_details(self, location_id: str) -> Location19:
        """
        Shows details for a location, by ID. Specify the location ID in the locationId parameter in the URI.

        :param location_id: A unique identifier for the location.
        :type location_id: str

        documentation: https://developer.webex.com/docs/api/v1/workspace-locations/get-a-workspace-location-details
        """
        url = self.ep(f'{location_id}')
        data = super().get(url=url)
        return Location19.parse_obj(data)

    def update_location(self, location_id: str, display_name: str, address: str, country_code: str, latitude: int, longitude: int, city_name: str = None, notes: str = None, id: str = None) -> Location19:
        """
        Updates details for a location, by ID. Specify the location ID in the locationId parameter in the URI. The
        request should include all details for the location returned in a previous call to Get Workspace Location
        Details. Omitting the optional cityName or notes fields will result in those fields no longer being defined for
        the location.

        :param location_id: A unique identifier for the location.
        :type location_id: str
        :param display_name: A friendly name for the location.
        :type display_name: str
        :param address: The location address.
        :type address: str
        :param country_code: The location country code (ISO 3166-1).
        :type country_code: str
        :param latitude: The location latitude.
        :type latitude: int
        :param longitude: The location longitude.
        :type longitude: int
        :param city_name: The location city name.
        :type city_name: str
        :param notes: Notes associated with the location.
        :type notes: str
        :param id: Unique identifier for the location.
        :type id: str

        documentation: https://developer.webex.com/docs/api/v1/workspace-locations/update-a-workspace-location
        """
        body = UpdateWorkspaceLocationBody()
        if display_name is not None:
            body.display_name = display_name
        if address is not None:
            body.address = address
        if country_code is not None:
            body.country_code = country_code
        if latitude is not None:
            body.latitude = latitude
        if longitude is not None:
            body.longitude = longitude
        if city_name is not None:
            body.city_name = city_name
        if notes is not None:
            body.notes = notes
        if id is not None:
            body.id = id
        url = self.ep(f'{location_id}')
        data = super().put(url=url, data=body.json())
        return Location19.parse_obj(data)

    def delete_location(self, location_id: str):
        """
        Deletes a location, by ID. The workspaces associated to that location will no longer have a location, but a new
        location can be reassigned to them.

        :param location_id: A unique identifier for the location.
        :type location_id: str

        documentation: https://developer.webex.com/docs/api/v1/workspace-locations/delete-a-workspace-location
        """
        url = self.ep(f'{location_id}')
        super().delete(url=url)
        return

    def list_location_floors(self, location_id: str) -> list[Floor]:
        """
        List workspace location floors.

        :param location_id: A unique identifier for the location.
        :type location_id: str

        documentation: https://developer.webex.com/docs/api/v1/workspace-locations/list-workspace-location-floors
        """
        url = self.ep(f'{location_id}/floors')
        data = super().get(url=url)
        return parse_obj_as(list[Floor], data["items"])

    def create_location_floor(self, location_id: str, floor_number: int, display_name: str = None) -> Floor:
        """
        Create a new floor in the given location. The displayName parameter is optional, and omitting it will result in
        the creation of a floor without that value set.

        :param location_id: A unique identifier for the location.
        :type location_id: str
        :param floor_number: The floor number.
        :type floor_number: int
        :param display_name: The floor display name.
        :type display_name: str

        documentation: https://developer.webex.com/docs/api/v1/workspace-locations/create-a-workspace-location-floor
        """
        body = CreateLocationFloorBody()
        if floor_number is not None:
            body.floor_number = floor_number
        if display_name is not None:
            body.display_name = display_name
        url = self.ep(f'{location_id}/floors')
        data = super().post(url=url, data=body.json())
        return Floor.parse_obj(data)

    def location_floor_details(self, location_id: str, floor_id: str) -> Floor:
        """
        Shows details for a floor, by ID. Specify the floor ID in the floorId parameter in the URI.

        :param location_id: A unique identifier for the location.
        :type location_id: str
        :param floor_id: A unique identifier for the floor.
        :type floor_id: str

        documentation: https://developer.webex.com/docs/api/v1/workspace-locations/get-a-workspace-location-floor-details
        """
        url = self.ep(f'{location_id}/floors/{floor_id}')
        data = super().get(url=url)
        return Floor.parse_obj(data)

    def update_location_floor(self, location_id: str, floor_id: str, floor_number: int, display_name: str = None) -> Floor:
        """
        Updates details for a floor, by ID. Specify the floor ID in the floorId parameter in the URI. Include all
        details for the floor returned by a previous call to Get Workspace Location Floor Details. Omitting the
        optional displayName field will result in that field no longer being defined for the floor.

        :param location_id: A unique identifier for the location.
        :type location_id: str
        :param floor_id: A unique identifier for the floor.
        :type floor_id: str
        :param floor_number: The floor number.
        :type floor_number: int
        :param display_name: The floor display name.
        :type display_name: str

        documentation: https://developer.webex.com/docs/api/v1/workspace-locations/update-a-workspace-location-floor
        """
        body = CreateLocationFloorBody()
        if floor_number is not None:
            body.floor_number = floor_number
        if display_name is not None:
            body.display_name = display_name
        url = self.ep(f'{location_id}/floors/{floor_id}')
        data = super().put(url=url, data=body.json())
        return Floor.parse_obj(data)

    def delete_location_floor(self, location_id: str, floor_id: str):
        """
        Deletes a floor, by ID.

        :param location_id: A unique identifier for the location.
        :type location_id: str
        :param floor_id: A unique identifier for the floor.
        :type floor_id: str

        documentation: https://developer.webex.com/docs/api/v1/workspace-locations/delete-a-workspace-location-floor
        """
        url = self.ep(f'{location_id}/floors/{floor_id}')
        super().delete(url=url)
        return

class MetricName(str, Enum):
    sound_level = 'soundLevel'
    ambient_noise = 'ambientNoise'
    temperature = 'temperature'
    humidity = 'humidity'
    tvoc = 'tvoc'
    people_count = 'peopleCount'


class Aggregation1(str, Enum):
    hourly = 'hourly'
    daily = 'daily'


class Aggregation(Aggregation1):
    none = 'none'


class Unit(str, Enum):
    celsius = 'celsius'
    fahrenheit = 'fahrenheit'


class SortBy(str, Enum):
    newest_first = 'newestFirst'
    oldest_first = 'oldestFirst'


class Measurement(str, Enum):
    time_used = 'timeUsed'
    time_booked = 'timeBooked'


class WorkspaceMetricsResponse(ApiModel):
    workspace_id: Optional[str]
    metric_name: Optional[MetricName]
    aggregation: Optional[Aggregation]
    from: Optional[str]
    to: Optional[str]
    #: Output data unit (only present if metricName is temperature).
    unit: Optional[Unit]
    sort_by: Optional[SortBy]
    items: Optional[list[str]]


class WorkspaceDurationMetricsResponse(ApiModel):
    workspace_id: Optional[str]
    aggregation: Optional[Aggregation1]
    measurement: Optional[Measurement]
    from: Optional[str]
    to: Optional[str]
    #: The time unit.
    unit: Optional[str]
    items: Optional[list[DurationMetric]]


class WorkspaceMetricsApi(ApiChild, base='workspace'):
    """
    Workspace metrics contain various measurements, such as sound level or temperature, collected by devices in a
    workspace.
    Getting the workspace metrics in an organization requires an administrator auth token with the
    spark-admin:workspace_metrics_read scope.
    """

    def workspace_metrics(self, workspace_id: str, metric_name: str, aggregation: str = None, from_: str = None, to_: str = None, unit: str = None, sort_by: str = None) -> WorkspaceMetricsResponse:
        """
        Get metric data for the specified workspace and metric name, optionally aggregated over a specified time
        period.

        :param workspace_id: ID of the workspace to get metrics for.
        :type workspace_id: str
        :param metric_name: The type of data to extract. Possible values: soundLevel, ambientNoise, temperature,
            humidity, tvoc, peopleCount
        :type metric_name: str
        :param aggregation: Time unit over which to aggregate measurements. Possible values: none, hourly, daily
        :type aggregation: str
        :param from_: List only data points after a specific date and time (ISO 8601 timestamp)
        :type from_: str
        :param to_: List data points before a specific date and time (ISO 8601 timestamp)
        :type to_: str
        :param unit: Output data unit (only a valid parameter if metricName is temperature). Possible values: celsius,
            fahrenheit
        :type unit: str
        :param sort_by: Sort results. Possible values: newestFirst, oldestFirst
        :type sort_by: str

        documentation: https://developer.webex.com/docs/api/v1/workspace-metrics/workspace-metrics
        """
        params = {}
        params['workspaceId'] = workspace_id
        params['metricName'] = metric_name
        if aggregation is not None:
            params['aggregation'] = aggregation
        if from_ is not None:
            params['from'] = from_
        if to_ is not None:
            params['to'] = to_
        if unit is not None:
            params['unit'] = unit
        if sort_by is not None:
            params['sortBy'] = sort_by
        url = self.ep('Metrics')
        data = super().get(url=url, params=params)
        return WorkspaceMetricsResponse.parse_obj(data)

    def workspace_duration_metrics(self, workspace_id: str, aggregation: str = None, measurement: str = None, from_: str = None, to_: str = None) -> WorkspaceDurationMetricsResponse:
        """
        Get metrics for how much time a workspace has been in the state given by the measurement parameter.
        For example, if the measurement is timeBooked then the duration for which the workspace has been booked is
        returned. The workspaceId parameter indicates which workspace to fetch metrics for. If no measurement is given,
        the default value is timeUsed.

        :param workspace_id: ID of the workspace to get metrics for.
        :type workspace_id: str
        :param aggregation: Unit of time over which to aggregate measurements. Possible values: hourly, daily
        :type aggregation: str
        :param measurement: The measurement to return duration for. Possible values: timeUsed, timeBooked
        :type measurement: str
        :param from_: Include data points after a specific date and time (ISO 8601 timestamp).
        :type from_: str
        :param to_: Include data points before a specific date and time (ISO 8601 timestamp).
        :type to_: str

        documentation: https://developer.webex.com/docs/api/v1/workspace-metrics/workspace-duration-metrics
        """
        params = {}
        params['workspaceId'] = workspace_id
        if aggregation is not None:
            params['aggregation'] = aggregation
        if measurement is not None:
            params['measurement'] = measurement
        if from_ is not None:
            params['from'] = from_
        if to_ is not None:
            params['to'] = to_
        url = self.ep('DurationMetrics')
        data = super().get(url=url, params=params)
        return WorkspaceDurationMetricsResponse.parse_obj(data)

class PersonalizeWorkspaceBody(ApiModel):
    #: The user that the device will become personalised for.
    email: Optional[str]


class GetPersonalizationTaskResponse(ApiModel):
    #: Describes if the personalization was successful.
    success: Optional[bool]
    #: A description of the error will be provided if the personalization was not successful.
    error_description: Optional[str]


class WorkspacePersonalizationApi(ApiChild, base='workspaces/'):
    """
    This API collection applies only to Webex Edge registered devices.
    The Workspace Personalization API is designed to help administrators enable Personal Mode for Webex Edge registered
    devices. This one-time operation allows for end users to receive calls and meeting notifications directly on their
    device, without needing to pair. This API aids with the process of the migration from on-premise to
    cloud-registered personal mode systems.
    For the personalization of a device to be successful, the following requirements must be satisfied:
    The workspace must contain a single, Webex Edge registered, shared mode device.
    The workspace must not have any calendars configured.
    The device belonging to the workspace must be online.
    Invoking this API requires the spark-admin:devices_write, spark:xapi_commands, spark:xapi_statuses and
    Identity:one_time_password scopes.
    """

    def personalize_workspace(self, workspace_id: str, email: str):
        """
        Initializes the personalization for a given workspace for the user email provided.
        The personalization process is asynchronous and thus a background task is created when this endpoint is
        invoked.
        After successful invocation of this endpoint a personalization task status URL will be returned in the Location
        header, which will point to the Get Personalization Task endpoint for this workspace.
        The task should be completed in approximately 30 seconds.

        :param workspace_id: A unique identifier for the workspace.
        :type workspace_id: str
        :param email: The user that the device will become personalised for.
        :type email: str

        documentation: https://developer.webex.com/docs/api/v1/workspace-personalization/personalize-a-workspace
        """
        body = PersonalizeWorkspaceBody()
        if email is not None:
            body.email = email
        url = self.ep(f'{workspace_id}/personalize')
        super().post(url=url, data=body.json())
        return

    def personalization_task(self, workspace_id: str) -> GetPersonalizationTaskResponse:
        """
        Returns the status of a personalization task for a given workspace.
        Whilst in progress the endpoint will return Accepted and provide a Retry-After header indicating the number of
        seconds a client should wait before retrying.
        Upon completion of the task, the endpoint will return OK with a body detailing if the personalization was
        successful and an error description if appropriate.

        :param workspace_id: A unique identifier for the workspace.
        :type workspace_id: str

        documentation: https://developer.webex.com/docs/api/v1/workspace-personalization/get-personalization-task
        """
        url = self.ep(f'{workspace_id}/personalizationTask')
        data = super().get(url=url)
        return GetPersonalizationTaskResponse.parse_obj(data)

class SupportedDevices(str, Enum):
    #: Workspace supports collaborationDevices.
    collaboration_devices = 'collaborationDevices'
    #: Workspace supports MPP phones.
    phones = 'phones'


class Type73(str, Enum):
    #: No workspace type set.
    not_set = 'notSet'
    #: High concentration.
    focus = 'focus'
    #: Brainstorm/collaboration.
    huddle = 'huddle'
    #: Dedicated meeting space.
    meeting_room = 'meetingRoom'
    #: Unstructured agile.
    open = 'open'
    #: Individual.
    desk = 'desk'
    #: Unspecified.
    other = 'other'


class Calendar1(ApiModel):
    type: Optional[str]
    #: Workspace email address. Will not be set when the calendar type is none.
    email_address: Optional[str]


class UpdateWorkspaceBody(ApiModel):
    #: A friendly name for the workspace.
    display_name: Optional[str]
    #: Location associated with the workspace. Must be provided when the floorId is set.
    workspace_location_id: Optional[str]
    #: Floor associated with the workspace.
    floor_id: Optional[str]
    #: How many people the workspace is suitable for. If set, must be 0 or higher.
    capacity: Optional[int]
    #: The type that best describes the workspace.
    type: Optional[Type73]
    #: An empty/null calendar field will not cause any changes. Provide a type (microsoft, google or none) and an
    #: emailAddress. Removing calendar is done by setting the none type, and setting none type does not require an
    #: emailAddress.
    calendar: Optional[Calendar1]
    #: The sipAddress field can only be provided when calling type is thirdPartySipCalling
    sip_address: Optional[str]
    #: Calling types supported on update are freeCalling, thirdPartySipCalling and none.
    #: Calling type.
    calling: Optional[object]
    #: Notes associated to the workspace.
    notes: Optional[str]
    #: Hot desking status of the workspace.
    hotdesking_status: Optional[Video]


class Workspace(UpdateWorkspaceBody):
    #: Unique identifier for the Workspace.
    id: Optional[str]
    #: OrgId associate with the workspace.
    org_id: Optional[str]
    #: The date and time that the workspace was registered, in ISO8601 format.
    created: Optional[str]
    #: The supported devices for the workspace.
    supported_devices: Optional[SupportedDevices]


class SupportAndConfiguredInfo(ApiModel):
    #: Is the workspace capability supported or not.
    supported: Optional[bool]
    #: Is the workspace capability configured or not.
    configured: Optional[bool]


class CapabilityMap(ApiModel):
    #: Occupancy detection.
    occupancy_detection: Optional[SupportAndConfiguredInfo]
    #: Presence detection.
    presence_detection: Optional[SupportAndConfiguredInfo]
    #: Ambient noise.
    ambient_noise: Optional[SupportAndConfiguredInfo]
    #: Sound level.
    sound_level: Optional[SupportAndConfiguredInfo]
    #: Temperature.
    temperature: Optional[SupportAndConfiguredInfo]
    #: Air quality.
    air_quality: Optional[SupportAndConfiguredInfo]
    #: Relative humidity.
    relative_humidity: Optional[SupportAndConfiguredInfo]


class ListWorkspacesResponse(ApiModel):
    #: An array of workspace objects.
    items: Optional[list[Workspace]]


class CreateWorkspaceBody(UpdateWorkspaceBody):
    #: OrgId associated with the workspace. Only admin users of another organization (such as partners) may use this
    #: parameter.
    org_id: Optional[str]


class GetWorkspaceCapabilitiesResponse(ApiModel):
    #: The map of workspace capabilities.
    capabilities: Optional[CapabilityMap]


class WorkspacesApi(ApiChild, base='workspaces'):
    """
    Workspaces represent where people work, such as conference rooms, meeting spaces, lobbies, and lunch rooms. Devices
    may be associated with workspaces.
    Viewing the list of workspaces in an organization requires an administrator auth token with the
    spark-admin:workspaces_read scope. Adding, updating, or deleting workspaces in an organization requires an
    administrator auth token with the scopes spark-admin:workspaces_write and spark-admin:telephony_config_write.
    The Workspaces API can also be used by partner administrators acting as administrators of a different organization
    than their own. In those cases an orgId value must be supplied, as indicated in the reference documentation for the
    relevant endpoints.
    """

    def list(self, org_id: str = None, workspace_location_id: str = None, floor_id: str = None, display_name: str = None, capacity: int = None, type_: str = None, calling: str = None, calendar: str = None, **params) -> Generator[Workspace, None, None]:
        """
        List workspaces.
        Use query parameters to filter the response. The orgId parameter can only be used by admin users of another
        organization (such as partners). The workspaceLocationId, floorId, capacity and type fields will only be
        present for workspaces that have a value set for them. The special values notSet (for filtering on category)
        and -1 (for filtering on capacity) can be used to filter for workspaces without a type and/or capacity.

        :param org_id: List workspaces in this organization. Only admin users of another organization (such as
            partners) may use this parameter.
        :type org_id: str
        :param workspace_location_id: Location associated with the workspace.
        :type workspace_location_id: str
        :param floor_id: Floor associated with the workspace.
        :type floor_id: str
        :param display_name: List workspaces by display name.
        :type display_name: str
        :param capacity: List workspaces with the given capacity. Must be -1 or higher. A value of -1 lists workspaces
            with no capacity set.
        :type capacity: int
        :param type_: List workspaces by type. Possible values: notSet, focus, huddle, meetingRoom, open, desk, other
        :type type_: str
        :param calling: List workspaces by calling type. Possible values: freeCalling, hybridCalling, webexCalling,
            webexEdgeForDevices, thirdPartySipCalling, none
        :type calling: str
        :param calendar: List workspaces by calendar type. Possible values: none, google, microsoft
        :type calendar: str

        documentation: https://developer.webex.com/docs/api/v1/workspaces/list-workspaces
        """
        if org_id is not None:
            params['orgId'] = org_id
        if workspace_location_id is not None:
            params['workspaceLocationId'] = workspace_location_id
        if floor_id is not None:
            params['floorId'] = floor_id
        if display_name is not None:
            params['displayName'] = display_name
        if capacity is not None:
            params['capacity'] = capacity
        if type_ is not None:
            params['type'] = type_
        if calling is not None:
            params['calling'] = calling
        if calendar is not None:
            params['calendar'] = calendar
        url = self.ep()
        return self.session.follow_pagination(url=url, model=Workspace, params=params)

    def create(self, display_name: str = None, workspace_location_id: str = None, floor_id: str = None, capacity: int = None, type_: Type73 = None, calendar: Calendar1 = None, sip_address: str = None, calling: object = None, notes: str = None, hotdesking_status: Video = None, org_id: str = None) -> Workspace:
        """
        Create a workspace.
        The workspaceLocationId, floorId, capacity, type, notes and hotdeskingStatus parameters are optional, and
        omitting them will result in the creation of a workspace without these values set, or set to their default. A
        workspaceLocationId must be provided when the floorId is set. Calendar and calling can also be set for a new
        workspace. Omitting them will default to free calling and no calendaring. The orgId parameter can only be used
        by admin users of another organization (such as partners).

        :param display_name: A friendly name for the workspace.
        :type display_name: str
        :param workspace_location_id: Location associated with the workspace. Must be provided when the floorId is set.
        :type workspace_location_id: str
        :param floor_id: Floor associated with the workspace.
        :type floor_id: str
        :param capacity: How many people the workspace is suitable for. If set, must be 0 or higher.
        :type capacity: int
        :param type_: The type that best describes the workspace.
        :type type_: Type73
        :param calendar: An empty/null calendar field will not cause any changes. Provide a type (microsoft, google or
            none) and an emailAddress. Removing calendar is done by setting the none type, and setting none type does
            not require an emailAddress.
        :type calendar: Calendar1
        :param sip_address: The sipAddress field can only be provided when calling type is thirdPartySipCalling
        :type sip_address: str
        :param calling: Calling types supported on update are freeCalling, thirdPartySipCalling and none. Calling type.
        :type calling: object
        :param notes: Notes associated to the workspace.
        :type notes: str
        :param hotdesking_status: Hot desking status of the workspace.
        :type hotdesking_status: Video
        :param org_id: OrgId associated with the workspace. Only admin users of another organization (such as partners)
            may use this parameter.
        :type org_id: str

        documentation: https://developer.webex.com/docs/api/v1/workspaces/create-a-workspace
        """
        body = CreateWorkspaceBody()
        if display_name is not None:
            body.display_name = display_name
        if workspace_location_id is not None:
            body.workspace_location_id = workspace_location_id
        if floor_id is not None:
            body.floor_id = floor_id
        if capacity is not None:
            body.capacity = capacity
        if type_ is not None:
            body.type_ = type_
        if calendar is not None:
            body.calendar = calendar
        if sip_address is not None:
            body.sip_address = sip_address
        if calling is not None:
            body.calling = calling
        if notes is not None:
            body.notes = notes
        if hotdesking_status is not None:
            body.hotdesking_status = hotdesking_status
        if org_id is not None:
            body.org_id = org_id
        url = self.ep()
        data = super().post(url=url, data=body.json())
        return Workspace.parse_obj(data)

    def details(self, workspace_id: str) -> Workspace:
        """
        Shows details for a workspace, by ID.
        The workspaceLocationId, floorId, capacity, type and notes fields will only be present if they have been set
        for the workspace. Specify the workspace ID in the workspaceId parameter in the URI.

        :param workspace_id: A unique identifier for the workspace.
        :type workspace_id: str

        documentation: https://developer.webex.com/docs/api/v1/workspaces/get-workspace-details
        """
        url = self.ep(f'{workspace_id}')
        data = super().get(url=url)
        return Workspace.parse_obj(data)

    def update(self, workspace_id: str, display_name: str = None, workspace_location_id: str = None, floor_id: str = None, capacity: int = None, type_: Type73 = None, calendar: Calendar1 = None, sip_address: str = None, calling: object = None, notes: str = None, hotdesking_status: Video = None) -> Workspace:
        """
        Updates details for a workspace by ID.
        Specify the workspace ID in the workspaceId parameter in the URI. Include all details for the workspace that
        are present in a GET request for the workspace details. Not including the optional capacity, type or notes
        fields will result in the fields no longer being defined for the workspace. A workspaceLocationId must be
        provided when the floorId is set. The workspaceLocationId, floorId, calendar and calling fields do not change
        when omitted from the update request.
        Updating the calling parameter is only supported if the existing calling type is freeCalling, none or
        thirdPartySipCalling.
        Updating the calling parameter to none or thirdPartySipCalling is not supported if the workspace contains any
        devices.

        :param workspace_id: A unique identifier for the workspace.
        :type workspace_id: str
        :param display_name: A friendly name for the workspace.
        :type display_name: str
        :param workspace_location_id: Location associated with the workspace. Must be provided when the floorId is set.
        :type workspace_location_id: str
        :param floor_id: Floor associated with the workspace.
        :type floor_id: str
        :param capacity: How many people the workspace is suitable for. If set, must be 0 or higher.
        :type capacity: int
        :param type_: The type that best describes the workspace.
        :type type_: Type73
        :param calendar: An empty/null calendar field will not cause any changes. Provide a type (microsoft, google or
            none) and an emailAddress. Removing calendar is done by setting the none type, and setting none type does
            not require an emailAddress.
        :type calendar: Calendar1
        :param sip_address: The sipAddress field can only be provided when calling type is thirdPartySipCalling
        :type sip_address: str
        :param calling: Calling types supported on update are freeCalling, thirdPartySipCalling and none. Calling type.
        :type calling: object
        :param notes: Notes associated to the workspace.
        :type notes: str
        :param hotdesking_status: Hot desking status of the workspace.
        :type hotdesking_status: Video

        documentation: https://developer.webex.com/docs/api/v1/workspaces/update-a-workspace
        """
        body = UpdateWorkspaceBody()
        if display_name is not None:
            body.display_name = display_name
        if workspace_location_id is not None:
            body.workspace_location_id = workspace_location_id
        if floor_id is not None:
            body.floor_id = floor_id
        if capacity is not None:
            body.capacity = capacity
        if type_ is not None:
            body.type_ = type_
        if calendar is not None:
            body.calendar = calendar
        if sip_address is not None:
            body.sip_address = sip_address
        if calling is not None:
            body.calling = calling
        if notes is not None:
            body.notes = notes
        if hotdesking_status is not None:
            body.hotdesking_status = hotdesking_status
        url = self.ep(f'{workspace_id}')
        data = super().put(url=url, data=body.json())
        return Workspace.parse_obj(data)

    def delete(self, workspace_id: str):
        """
        Deletes a workspace by ID.
        Also deletes all devices associated with the workspace. Any deleted devices will need to be reactivated.
        Specify the workspace ID in the workspaceId parameter in the URI.

        :param workspace_id: A unique identifier for the workspace.
        :type workspace_id: str

        documentation: https://developer.webex.com/docs/api/v1/workspaces/delete-a-workspace
        """
        url = self.ep(f'{workspace_id}')
        super().delete(url=url)
        return

    def capabilities(self, workspace_id: str) -> CapabilityMap:
        """
        Shows the capabilities for a workspace by ID.
        Returns a set of capabilities, including whether or not the capability is supported by any device in the
        workspace, and if the capability is configured (enabled). For example for a specific capability like
        occupancyDetection, the API will return if the capability is supported and/or configured such that occupancy
        detection data will flow from the workspace (device) to the cloud. Specify the workspace ID in the workspaceId
        parameter in the URI.

        :param workspace_id: A unique identifier for the workspace.
        :type workspace_id: str

        documentation: https://developer.webex.com/docs/api/v1/workspaces/get-workspace-capabilities
        """
        url = self.ep(f'{workspace_id}/capabilities')
        data = super().get(url=url)
        return CapabilityMap.parse_obj(data["capabilities"])

class Audio1(ApiModel):
    volume: Optional[int]


class Result9(ApiModel):
    audio: Optional[Audio1]


class Time(ApiModel):
    start_time: Optional[str]
    duration: Optional[int]


class Booking(ApiModel):
    id: Optional[str]
    title: Optional[str]
    protocol: Optional[str]
    time: Optional[Time]
    organizer: Optional[object]
    number: Optional[str]


class Body6(ApiModel):
    booking: Optional[Booking]


class Arguments(ApiModel):
    level: Optional[int]


class QueryStatusResponse(ApiModel):
    #: The unique identifier for the Webex RoomOS Device.
    device_id: Optional[str]
    #: xAPI status result
    result: Optional[Result9]


class ExecuteCommandBody(ApiModel):
    #: The unique identifier for the Webex RoomOS Device.
    device_id: Optional[str]
    #: xAPI command arguments
    arguments: Optional[object]
    #: xAPI command body, as a complex JSON object or as a string, for example: import xapi from
    #: 'xapi';\n\nconsole.log('Hello, World!');\n
    body: Optional[Body6]


class ExecuteCommandResponse(QueryStatusResponse):
    #: xAPI command arguments
    arguments: Optional[Arguments]


class xAPIApi(ApiChild, base='xapi/'):
    """
    The xAPI allows developers to programmatically invoke commands and query the status of devices that run Webex
    RoomOS software.
    Executing commands requires an auth token with the spark:xapi_commands scope. Querying devices requires an auth
    token with the spark:xapi_statuses scope.
    All xAPI requests require a deviceId which can be obtained using the Devices API. xAPI commands and statuses are
    described in the Cisco Collaboration Endpoint Software API Reference Guide. For more information about developing
    applications for cloud connected devices, see the Device Developers Guide.
    """

    def query_status(self, device_id: str, name: str) -> QueryStatusResponse:
        """
        Query the current status of the Webex RoomOS Device. You specify the target device in the deviceId parameter in
        the URI. The target device is queried for statuses according to the expression in the name parameter.
        See the xAPI section of the Device Developers Guide for a description of status expressions.

        :param device_id: The unique identifier for the Webex RoomOS Device.
        :type device_id: str
        :param name: Status expression used to query the Webex RoomOS Device. See the xAPI section of the Device
            Developers Guide for a description of status expressions.
        :type name: str

        documentation: https://developer.webex.com/docs/api/v1/xapi/query-status
        """
        params = {}
        params['deviceId'] = device_id
        params['name'] = name
        url = self.ep('status')
        data = super().get(url=url, params=params)
        return QueryStatusResponse.parse_obj(data)

    def execute_command(self, command_name: str, device_id: str, arguments: object, body: Body6 = None) -> ExecuteCommandResponse:
        """
        Executes a command on the Webex RoomOS Device. Specify the command to execute in the commandName URI parameter.
        See the xAPI section of the Device Developers Guide for a description of command expressions.

        :param command_name: Command to execute on the Webex RoomOS Device.
        :type command_name: str
        :param device_id: The unique identifier for the Webex RoomOS Device.
        :type device_id: str
        :param arguments: xAPI command arguments
        :type arguments: object
        :param body: xAPI command body, as a complex JSON object or as a string, for example: import xapi from
            'xapi';\n\nconsole.log('Hello, World!');\n
        :type body: Body6

        documentation: https://developer.webex.com/docs/api/v1/xapi/execute-command
        """
        body = ExecuteCommandBody()
        if device_id is not None:
            body.device_id = device_id
        if arguments is not None:
            body.arguments = arguments
        if body is not None:
            body.body = body
        url = self.ep(f'command/{command_name}')
        data = super().post(url=url, data=body.json())
        return ExecuteCommandResponse.parse_obj(data)
